
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/grafana/grafana/pkg/api/admin.go (0.0%)</option>
				
				<option value="file1">github.com/grafana/grafana/pkg/api/admin_users.go (0.0%)</option>
				
				<option value="file2">github.com/grafana/grafana/pkg/api/alerting.go (0.0%)</option>
				
				<option value="file3">github.com/grafana/grafana/pkg/api/annotations.go (0.0%)</option>
				
				<option value="file4">github.com/grafana/grafana/pkg/api/api.go (0.0%)</option>
				
				<option value="file5">github.com/grafana/grafana/pkg/api/apikey.go (0.0%)</option>
				
				<option value="file6">github.com/grafana/grafana/pkg/api/app_routes.go (0.0%)</option>
				
				<option value="file7">github.com/grafana/grafana/pkg/api/cloudwatch/cloudwatch.go (0.6%)</option>
				
				<option value="file8">github.com/grafana/grafana/pkg/api/cloudwatch/metrics.go (35.0%)</option>
				
				<option value="file9">github.com/grafana/grafana/pkg/api/common.go (43.5%)</option>
				
				<option value="file10">github.com/grafana/grafana/pkg/api/dashboard.go (0.0%)</option>
				
				<option value="file11">github.com/grafana/grafana/pkg/api/dashboard_snapshot.go (0.0%)</option>
				
				<option value="file12">github.com/grafana/grafana/pkg/api/dataproxy.go (22.2%)</option>
				
				<option value="file13">github.com/grafana/grafana/pkg/api/datasources.go (11.0%)</option>
				
				<option value="file14">github.com/grafana/grafana/pkg/api/frontendsettings.go (0.0%)</option>
				
				<option value="file15">github.com/grafana/grafana/pkg/api/gnetproxy.go (0.0%)</option>
				
				<option value="file16">github.com/grafana/grafana/pkg/api/http_server.go (0.0%)</option>
				
				<option value="file17">github.com/grafana/grafana/pkg/api/index.go (0.0%)</option>
				
				<option value="file18">github.com/grafana/grafana/pkg/api/login.go (0.0%)</option>
				
				<option value="file19">github.com/grafana/grafana/pkg/api/login_oauth.go (0.0%)</option>
				
				<option value="file20">github.com/grafana/grafana/pkg/api/metrics.go (0.0%)</option>
				
				<option value="file21">github.com/grafana/grafana/pkg/api/org.go (0.0%)</option>
				
				<option value="file22">github.com/grafana/grafana/pkg/api/org_invite.go (0.0%)</option>
				
				<option value="file23">github.com/grafana/grafana/pkg/api/org_users.go (0.0%)</option>
				
				<option value="file24">github.com/grafana/grafana/pkg/api/password.go (0.0%)</option>
				
				<option value="file25">github.com/grafana/grafana/pkg/api/playlist.go (0.0%)</option>
				
				<option value="file26">github.com/grafana/grafana/pkg/api/playlist_play.go (0.0%)</option>
				
				<option value="file27">github.com/grafana/grafana/pkg/api/pluginproxy/pluginproxy.go (34.2%)</option>
				
				<option value="file28">github.com/grafana/grafana/pkg/api/plugins.go (0.0%)</option>
				
				<option value="file29">github.com/grafana/grafana/pkg/api/preferences.go (0.0%)</option>
				
				<option value="file30">github.com/grafana/grafana/pkg/api/quota.go (0.0%)</option>
				
				<option value="file31">github.com/grafana/grafana/pkg/api/render.go (0.0%)</option>
				
				<option value="file32">github.com/grafana/grafana/pkg/api/search.go (0.0%)</option>
				
				<option value="file33">github.com/grafana/grafana/pkg/api/signup.go (0.0%)</option>
				
				<option value="file34">github.com/grafana/grafana/pkg/api/stars.go (0.0%)</option>
				
				<option value="file35">github.com/grafana/grafana/pkg/api/user.go (14.8%)</option>
				
				<option value="file36">github.com/grafana/grafana/pkg/bus/bus.go (53.1%)</option>
				
				<option value="file37">github.com/grafana/grafana/pkg/cmd/grafana-cli/commands/command_line.go (0.0%)</option>
				
				<option value="file38">github.com/grafana/grafana/pkg/cmd/grafana-cli/commands/commands.go (10.5%)</option>
				
				<option value="file39">github.com/grafana/grafana/pkg/cmd/grafana-cli/commands/install_command.go (2.3%)</option>
				
				<option value="file40">github.com/grafana/grafana/pkg/cmd/grafana-cli/commands/listremote_command.go (0.0%)</option>
				
				<option value="file41">github.com/grafana/grafana/pkg/cmd/grafana-cli/commands/listversions_command.go (0.0%)</option>
				
				<option value="file42">github.com/grafana/grafana/pkg/cmd/grafana-cli/commands/ls_command.go (27.8%)</option>
				
				<option value="file43">github.com/grafana/grafana/pkg/cmd/grafana-cli/commands/remove_command.go (0.0%)</option>
				
				<option value="file44">github.com/grafana/grafana/pkg/cmd/grafana-cli/commands/reset_password_command.go (0.0%)</option>
				
				<option value="file45">github.com/grafana/grafana/pkg/cmd/grafana-cli/commands/upgrade_all_command.go (26.7%)</option>
				
				<option value="file46">github.com/grafana/grafana/pkg/cmd/grafana-cli/commands/upgrade_command.go (0.0%)</option>
				
				<option value="file47">github.com/grafana/grafana/pkg/components/apikeygen/apikeygen.go (78.9%)</option>
				
				<option value="file48">github.com/grafana/grafana/pkg/components/dynmap/dynmap.go (58.0%)</option>
				
				<option value="file49">github.com/grafana/grafana/pkg/components/imguploader/imguploader.go (75.0%)</option>
				
				<option value="file50">github.com/grafana/grafana/pkg/components/imguploader/s3uploader.go (6.7%)</option>
				
				<option value="file51">github.com/grafana/grafana/pkg/components/imguploader/webdavuploader.go (7.1%)</option>
				
				<option value="file52">github.com/grafana/grafana/pkg/components/renderer/renderer.go (0.0%)</option>
				
				<option value="file53">github.com/grafana/grafana/pkg/components/simplejson/simplejson.go (69.5%)</option>
				
				<option value="file54">github.com/grafana/grafana/pkg/components/simplejson/simplejson_go11.go (36.4%)</option>
				
				<option value="file55">github.com/grafana/grafana/pkg/events/events.go (85.7%)</option>
				
				<option value="file56">github.com/grafana/grafana/pkg/login/auth.go (0.0%)</option>
				
				<option value="file57">github.com/grafana/grafana/pkg/login/ldap.go (49.7%)</option>
				
				<option value="file58">github.com/grafana/grafana/pkg/login/ldap_user.go (100.0%)</option>
				
				<option value="file59">github.com/grafana/grafana/pkg/login/settings.go (0.0%)</option>
				
				<option value="file60">github.com/grafana/grafana/pkg/metrics/EMWA.go (0.0%)</option>
				
				<option value="file61">github.com/grafana/grafana/pkg/metrics/common.go (26.3%)</option>
				
				<option value="file62">github.com/grafana/grafana/pkg/metrics/counter.go (44.4%)</option>
				
				<option value="file63">github.com/grafana/grafana/pkg/metrics/delta.go (0.0%)</option>
				
				<option value="file64">github.com/grafana/grafana/pkg/metrics/gauge.go (35.7%)</option>
				
				<option value="file65">github.com/grafana/grafana/pkg/metrics/graphite.go (30.6%)</option>
				
				<option value="file66">github.com/grafana/grafana/pkg/metrics/histogram.go (39.5%)</option>
				
				<option value="file67">github.com/grafana/grafana/pkg/metrics/meter.go (0.0%)</option>
				
				<option value="file68">github.com/grafana/grafana/pkg/metrics/metrics.go (100.0%)</option>
				
				<option value="file69">github.com/grafana/grafana/pkg/metrics/publish.go (0.0%)</option>
				
				<option value="file70">github.com/grafana/grafana/pkg/metrics/registry.go (50.0%)</option>
				
				<option value="file71">github.com/grafana/grafana/pkg/metrics/sample.go (78.0%)</option>
				
				<option value="file72">github.com/grafana/grafana/pkg/metrics/settings.go (0.0%)</option>
				
				<option value="file73">github.com/grafana/grafana/pkg/metrics/timer.go (7.4%)</option>
				
				<option value="file74">github.com/grafana/grafana/pkg/middleware/auth.go (54.3%)</option>
				
				<option value="file75">github.com/grafana/grafana/pkg/middleware/auth_proxy.go (72.1%)</option>
				
				<option value="file76">github.com/grafana/grafana/pkg/middleware/logger.go (0.0%)</option>
				
				<option value="file77">github.com/grafana/grafana/pkg/middleware/middleware.go (78.6%)</option>
				
				<option value="file78">github.com/grafana/grafana/pkg/middleware/org_redirect.go (82.4%)</option>
				
				<option value="file79">github.com/grafana/grafana/pkg/middleware/perf.go (0.0%)</option>
				
				<option value="file80">github.com/grafana/grafana/pkg/middleware/quota.go (75.9%)</option>
				
				<option value="file81">github.com/grafana/grafana/pkg/middleware/recovery.go (0.0%)</option>
				
				<option value="file82">github.com/grafana/grafana/pkg/middleware/render_auth.go (15.0%)</option>
				
				<option value="file83">github.com/grafana/grafana/pkg/middleware/request_metrics.go (0.0%)</option>
				
				<option value="file84">github.com/grafana/grafana/pkg/middleware/session.go (82.4%)</option>
				
				<option value="file85">github.com/grafana/grafana/pkg/middleware/util.go (0.0%)</option>
				
				<option value="file86">github.com/grafana/grafana/pkg/middleware/validate_host.go (0.0%)</option>
				
				<option value="file87">github.com/grafana/grafana/pkg/models/alert.go (52.9%)</option>
				
				<option value="file88">github.com/grafana/grafana/pkg/models/dashboards.go (58.3%)</option>
				
				<option value="file89">github.com/grafana/grafana/pkg/models/datasource.go (0.0%)</option>
				
				<option value="file90">github.com/grafana/grafana/pkg/models/datasource_cache.go (81.5%)</option>
				
				<option value="file91">github.com/grafana/grafana/pkg/models/helpflags.go (0.0%)</option>
				
				<option value="file92">github.com/grafana/grafana/pkg/models/org_user.go (0.0%)</option>
				
				<option value="file93">github.com/grafana/grafana/pkg/models/playlist.go (0.0%)</option>
				
				<option value="file94">github.com/grafana/grafana/pkg/models/plugin_settings.go (0.0%)</option>
				
				<option value="file95">github.com/grafana/grafana/pkg/models/quotas.go (0.0%)</option>
				
				<option value="file96">github.com/grafana/grafana/pkg/models/user.go (0.0%)</option>
				
				<option value="file97">github.com/grafana/grafana/pkg/plugins/app_plugin.go (72.7%)</option>
				
				<option value="file98">github.com/grafana/grafana/pkg/plugins/dashboard_importer.go (85.2%)</option>
				
				<option value="file99">github.com/grafana/grafana/pkg/plugins/dashboards.go (83.7%)</option>
				
				<option value="file100">github.com/grafana/grafana/pkg/plugins/dashboards_updater.go (8.8%)</option>
				
				<option value="file101">github.com/grafana/grafana/pkg/plugins/datasource_plugin.go (66.7%)</option>
				
				<option value="file102">github.com/grafana/grafana/pkg/plugins/frontend_plugin.go (90.0%)</option>
				
				<option value="file103">github.com/grafana/grafana/pkg/plugins/models.go (81.2%)</option>
				
				<option value="file104">github.com/grafana/grafana/pkg/plugins/panel_plugin.go (66.7%)</option>
				
				<option value="file105">github.com/grafana/grafana/pkg/plugins/plugins.go (67.9%)</option>
				
				<option value="file106">github.com/grafana/grafana/pkg/plugins/queries.go (0.0%)</option>
				
				<option value="file107">github.com/grafana/grafana/pkg/plugins/update_checker.go (3.3%)</option>
				
				<option value="file108">github.com/grafana/grafana/pkg/services/alerting/commands.go (14.3%)</option>
				
				<option value="file109">github.com/grafana/grafana/pkg/services/alerting/conditions/evaluator.go (80.0%)</option>
				
				<option value="file110">github.com/grafana/grafana/pkg/services/alerting/conditions/query.go (77.2%)</option>
				
				<option value="file111">github.com/grafana/grafana/pkg/services/alerting/conditions/reducer.go (100.0%)</option>
				
				<option value="file112">github.com/grafana/grafana/pkg/services/alerting/engine.go (0.0%)</option>
				
				<option value="file113">github.com/grafana/grafana/pkg/services/alerting/eval_context.go (20.0%)</option>
				
				<option value="file114">github.com/grafana/grafana/pkg/services/alerting/eval_handler.go (95.0%)</option>
				
				<option value="file115">github.com/grafana/grafana/pkg/services/alerting/extractor.go (80.6%)</option>
				
				<option value="file116">github.com/grafana/grafana/pkg/services/alerting/interfaces.go (0.0%)</option>
				
				<option value="file117">github.com/grafana/grafana/pkg/services/alerting/notifier.go (8.6%)</option>
				
				<option value="file118">github.com/grafana/grafana/pkg/services/alerting/notifiers/base.go (28.6%)</option>
				
				<option value="file119">github.com/grafana/grafana/pkg/services/alerting/notifiers/email.go (33.3%)</option>
				
				<option value="file120">github.com/grafana/grafana/pkg/services/alerting/notifiers/hipchat.go (20.0%)</option>
				
				<option value="file121">github.com/grafana/grafana/pkg/services/alerting/notifiers/line.go (20.8%)</option>
				
				<option value="file122">github.com/grafana/grafana/pkg/services/alerting/notifiers/opsgenie.go (13.6%)</option>
				
				<option value="file123">github.com/grafana/grafana/pkg/services/alerting/notifiers/pagerduty.go (15.8%)</option>
				
				<option value="file124">github.com/grafana/grafana/pkg/services/alerting/notifiers/sensu.go (16.1%)</option>
				
				<option value="file125">github.com/grafana/grafana/pkg/services/alerting/notifiers/slack.go (21.2%)</option>
				
				<option value="file126">github.com/grafana/grafana/pkg/services/alerting/notifiers/telegram.go (26.7%)</option>
				
				<option value="file127">github.com/grafana/grafana/pkg/services/alerting/notifiers/victorops.go (17.2%)</option>
				
				<option value="file128">github.com/grafana/grafana/pkg/services/alerting/notifiers/webhook.go (19.2%)</option>
				
				<option value="file129">github.com/grafana/grafana/pkg/services/alerting/reader.go (0.0%)</option>
				
				<option value="file130">github.com/grafana/grafana/pkg/services/alerting/result_handler.go (0.0%)</option>
				
				<option value="file131">github.com/grafana/grafana/pkg/services/alerting/rule.go (69.4%)</option>
				
				<option value="file132">github.com/grafana/grafana/pkg/services/alerting/scheduler.go (0.0%)</option>
				
				<option value="file133">github.com/grafana/grafana/pkg/services/alerting/test_notification.go (4.8%)</option>
				
				<option value="file134">github.com/grafana/grafana/pkg/services/alerting/test_rule.go (5.3%)</option>
				
				<option value="file135">github.com/grafana/grafana/pkg/services/alerting/ticker.go (100.0%)</option>
				
				<option value="file136">github.com/grafana/grafana/pkg/services/notifications/codes.go (95.3%)</option>
				
				<option value="file137">github.com/grafana/grafana/pkg/services/notifications/email.go (85.7%)</option>
				
				<option value="file138">github.com/grafana/grafana/pkg/services/notifications/mailer.go (35.7%)</option>
				
				<option value="file139">github.com/grafana/grafana/pkg/services/notifications/notifications.go (45.3%)</option>
				
				<option value="file140">github.com/grafana/grafana/pkg/services/notifications/webhook.go (15.6%)</option>
				
				<option value="file141">github.com/grafana/grafana/pkg/services/search/handlers.go (63.6%)</option>
				
				<option value="file142">github.com/grafana/grafana/pkg/services/search/json_index.go (72.2%)</option>
				
				<option value="file143">github.com/grafana/grafana/pkg/services/search/models.go (100.0%)</option>
				
				<option value="file144">github.com/grafana/grafana/pkg/services/sqlstore/alert.go (62.7%)</option>
				
				<option value="file145">github.com/grafana/grafana/pkg/services/sqlstore/alert_notification.go (79.3%)</option>
				
				<option value="file146">github.com/grafana/grafana/pkg/services/sqlstore/annotation.go (0.0%)</option>
				
				<option value="file147">github.com/grafana/grafana/pkg/services/sqlstore/apikey.go (47.1%)</option>
				
				<option value="file148">github.com/grafana/grafana/pkg/services/sqlstore/dashboard.go (67.6%)</option>
				
				<option value="file149">github.com/grafana/grafana/pkg/services/sqlstore/dashboard_snapshot.go (41.9%)</option>
				
				<option value="file150">github.com/grafana/grafana/pkg/services/sqlstore/datasource.go (50.9%)</option>
				
				<option value="file151">github.com/grafana/grafana/pkg/services/sqlstore/migrations/alert_mig.go (100.0%)</option>
				
				<option value="file152">github.com/grafana/grafana/pkg/services/sqlstore/migrations/annotation_mig.go (100.0%)</option>
				
				<option value="file153">github.com/grafana/grafana/pkg/services/sqlstore/migrations/apikey_mig.go (100.0%)</option>
				
				<option value="file154">github.com/grafana/grafana/pkg/services/sqlstore/migrations/common.go (100.0%)</option>
				
				<option value="file155">github.com/grafana/grafana/pkg/services/sqlstore/migrations/dashboard_mig.go (100.0%)</option>
				
				<option value="file156">github.com/grafana/grafana/pkg/services/sqlstore/migrations/dashboard_snapshot_mig.go (100.0%)</option>
				
				<option value="file157">github.com/grafana/grafana/pkg/services/sqlstore/migrations/datasource_mig.go (100.0%)</option>
				
				<option value="file158">github.com/grafana/grafana/pkg/services/sqlstore/migrations/migrations.go (100.0%)</option>
				
				<option value="file159">github.com/grafana/grafana/pkg/services/sqlstore/migrations/org_mig.go (100.0%)</option>
				
				<option value="file160">github.com/grafana/grafana/pkg/services/sqlstore/migrations/playlist_mig.go (100.0%)</option>
				
				<option value="file161">github.com/grafana/grafana/pkg/services/sqlstore/migrations/plugin_setting.go (100.0%)</option>
				
				<option value="file162">github.com/grafana/grafana/pkg/services/sqlstore/migrations/preferences_mig.go (100.0%)</option>
				
				<option value="file163">github.com/grafana/grafana/pkg/services/sqlstore/migrations/quota_mig.go (100.0%)</option>
				
				<option value="file164">github.com/grafana/grafana/pkg/services/sqlstore/migrations/session_mig.go (100.0%)</option>
				
				<option value="file165">github.com/grafana/grafana/pkg/services/sqlstore/migrations/temp_user.go (100.0%)</option>
				
				<option value="file166">github.com/grafana/grafana/pkg/services/sqlstore/migrations/user_mig.go (100.0%)</option>
				
				<option value="file167">github.com/grafana/grafana/pkg/services/sqlstore/org.go (26.5%)</option>
				
				<option value="file168">github.com/grafana/grafana/pkg/services/sqlstore/org_users.go (81.6%)</option>
				
				<option value="file169">github.com/grafana/grafana/pkg/services/sqlstore/playlist.go (60.9%)</option>
				
				<option value="file170">github.com/grafana/grafana/pkg/services/sqlstore/plugin_setting.go (9.1%)</option>
				
				<option value="file171">github.com/grafana/grafana/pkg/services/sqlstore/preferences.go (7.5%)</option>
				
				<option value="file172">github.com/grafana/grafana/pkg/services/sqlstore/quota.go (82.2%)</option>
				
				<option value="file173">github.com/grafana/grafana/pkg/services/sqlstore/shared.go (75.9%)</option>
				
				<option value="file174">github.com/grafana/grafana/pkg/services/sqlstore/sqlstore.go (7.1%)</option>
				
				<option value="file175">github.com/grafana/grafana/pkg/services/sqlstore/star.go (53.3%)</option>
				
				<option value="file176">github.com/grafana/grafana/pkg/services/sqlstore/stats.go (13.0%)</option>
				
				<option value="file177">github.com/grafana/grafana/pkg/services/sqlstore/temp_user.go (91.9%)</option>
				
				<option value="file178">github.com/grafana/grafana/pkg/services/sqlstore/tls_mysql.go (0.0%)</option>
				
				<option value="file179">github.com/grafana/grafana/pkg/services/sqlstore/user.go (52.4%)</option>
				
				<option value="file180">github.com/grafana/grafana/pkg/setting/setting.go (80.5%)</option>
				
				<option value="file181">github.com/grafana/grafana/pkg/setting/setting_quota.go (23.8%)</option>
				
				<option value="file182">github.com/grafana/grafana/pkg/setting/setting_smtp.go (100.0%)</option>
				
				<option value="file183">github.com/grafana/grafana/pkg/tsdb/batch.go (97.0%)</option>
				
				<option value="file184">github.com/grafana/grafana/pkg/tsdb/executor.go (87.5%)</option>
				
				<option value="file185">github.com/grafana/grafana/pkg/tsdb/graphite/graphite.go (20.3%)</option>
				
				<option value="file186">github.com/grafana/grafana/pkg/tsdb/influxdb/influxdb.go (3.4%)</option>
				
				<option value="file187">github.com/grafana/grafana/pkg/tsdb/influxdb/model_parser.go (86.4%)</option>
				
				<option value="file188">github.com/grafana/grafana/pkg/tsdb/influxdb/query.go (94.0%)</option>
				
				<option value="file189">github.com/grafana/grafana/pkg/tsdb/influxdb/query_part.go (93.3%)</option>
				
				<option value="file190">github.com/grafana/grafana/pkg/tsdb/influxdb/response_parser.go (93.7%)</option>
				
				<option value="file191">github.com/grafana/grafana/pkg/tsdb/interval.go (43.8%)</option>
				
				<option value="file192">github.com/grafana/grafana/pkg/tsdb/models.go (0.0%)</option>
				
				<option value="file193">github.com/grafana/grafana/pkg/tsdb/mqe/httpClient.go (0.0%)</option>
				
				<option value="file194">github.com/grafana/grafana/pkg/tsdb/mqe/model_parser.go (90.0%)</option>
				
				<option value="file195">github.com/grafana/grafana/pkg/tsdb/mqe/mqe.go (3.6%)</option>
				
				<option value="file196">github.com/grafana/grafana/pkg/tsdb/mqe/response_parser.go (83.3%)</option>
				
				<option value="file197">github.com/grafana/grafana/pkg/tsdb/mqe/token_client.go (2.8%)</option>
				
				<option value="file198">github.com/grafana/grafana/pkg/tsdb/mqe/types.go (94.9%)</option>
				
				<option value="file199">github.com/grafana/grafana/pkg/tsdb/opentsdb/opentsdb.go (33.0%)</option>
				
				<option value="file200">github.com/grafana/grafana/pkg/tsdb/prometheus/prometheus.go (18.3%)</option>
				
				<option value="file201">github.com/grafana/grafana/pkg/tsdb/query_context.go (100.0%)</option>
				
				<option value="file202">github.com/grafana/grafana/pkg/tsdb/request.go (93.1%)</option>
				
				<option value="file203">github.com/grafana/grafana/pkg/tsdb/time_range.go (84.4%)</option>
				
				<option value="file204">github.com/grafana/grafana/pkg/util/encoding.go (84.3%)</option>
				
				<option value="file205">github.com/grafana/grafana/pkg/util/encryption.go (84.6%)</option>
				
				<option value="file206">github.com/grafana/grafana/pkg/util/filepath.go (0.0%)</option>
				
				<option value="file207">github.com/grafana/grafana/pkg/util/strings.go (83.3%)</option>
				
				<option value="file208">github.com/grafana/grafana/pkg/util/url.go (53.8%)</option>
				
				<option value="file209">github.com/grafana/grafana/pkg/util/validation.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package api

import (
        "strings"

        "github.com/grafana/grafana/pkg/bus"
        "github.com/grafana/grafana/pkg/middleware"
        m "github.com/grafana/grafana/pkg/models"
        "github.com/grafana/grafana/pkg/setting"
)

func AdminGetSettings(c *middleware.Context) <span class="cov0" title="0">{
        settings := make(map[string]interface{})

        for _, section := range setting.Cfg.Sections() </span><span class="cov0" title="0">{
                jsonSec := make(map[string]interface{})
                settings[section.Name()] = jsonSec

                for _, key := range section.Keys() </span><span class="cov0" title="0">{
                        keyName := key.Name()
                        value := key.Value()
                        if strings.Contains(keyName, "secret") || strings.Contains(keyName, "password") || (strings.Contains(keyName, "provider_config")) </span><span class="cov0" title="0">{
                                value = "************"
                        }</span>

                        <span class="cov0" title="0">jsonSec[keyName] = value</span>
                }
        }

        <span class="cov0" title="0">c.JSON(200, settings)</span>
}

func AdminGetStats(c *middleware.Context) <span class="cov0" title="0">{

        statsQuery := m.GetAdminStatsQuery{}

        if err := bus.Dispatch(&amp;statsQuery); err != nil </span><span class="cov0" title="0">{
                c.JsonApiErr(500, "Failed to get admin stats from database", err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(200, statsQuery.Result)</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package api

import (
        "github.com/grafana/grafana/pkg/api/dtos"
        "github.com/grafana/grafana/pkg/bus"
        "github.com/grafana/grafana/pkg/metrics"
        "github.com/grafana/grafana/pkg/middleware"
        m "github.com/grafana/grafana/pkg/models"
        "github.com/grafana/grafana/pkg/util"
)

func AdminCreateUser(c *middleware.Context, form dtos.AdminCreateUserForm) <span class="cov0" title="0">{
        cmd := m.CreateUserCommand{
                Login:    form.Login,
                Email:    form.Email,
                Password: form.Password,
                Name:     form.Name,
        }

        if len(cmd.Login) == 0 </span><span class="cov0" title="0">{
                cmd.Login = cmd.Email
                if len(cmd.Login) == 0 </span><span class="cov0" title="0">{
                        c.JsonApiErr(400, "Validation error, need specify either username or email", nil)
                        return
                }</span>
        }

        <span class="cov0" title="0">if len(cmd.Password) &lt; 4 </span><span class="cov0" title="0">{
                c.JsonApiErr(400, "Password is missing or too short", nil)
                return
        }</span>

        <span class="cov0" title="0">if err := bus.Dispatch(&amp;cmd); err != nil </span><span class="cov0" title="0">{
                c.JsonApiErr(500, "failed to create user", err)
                return
        }</span>

        <span class="cov0" title="0">metrics.M_Api_Admin_User_Create.Inc(1)

        user := cmd.Result

        result := m.UserIdDTO{
                Message: "User created",
                Id:      user.Id,
        }

        c.JSON(200, result)</span>
}

func AdminUpdateUserPassword(c *middleware.Context, form dtos.AdminUpdateUserPasswordForm) <span class="cov0" title="0">{
        userId := c.ParamsInt64(":id")

        if len(form.Password) &lt; 4 </span><span class="cov0" title="0">{
                c.JsonApiErr(400, "New password too short", nil)
                return
        }</span>

        <span class="cov0" title="0">userQuery := m.GetUserByIdQuery{Id: userId}

        if err := bus.Dispatch(&amp;userQuery); err != nil </span><span class="cov0" title="0">{
                c.JsonApiErr(500, "Could not read user from database", err)
                return
        }</span>

        <span class="cov0" title="0">passwordHashed := util.EncodePassword(form.Password, userQuery.Result.Salt)

        cmd := m.ChangeUserPasswordCommand{
                UserId:      userId,
                NewPassword: passwordHashed,
        }

        if err := bus.Dispatch(&amp;cmd); err != nil </span><span class="cov0" title="0">{
                c.JsonApiErr(500, "Failed to update user password", err)
                return
        }</span>

        <span class="cov0" title="0">c.JsonOK("User password updated")</span>
}

func AdminUpdateUserPermissions(c *middleware.Context, form dtos.AdminUpdateUserPermissionsForm) <span class="cov0" title="0">{
        userId := c.ParamsInt64(":id")

        cmd := m.UpdateUserPermissionsCommand{
                UserId:         userId,
                IsGrafanaAdmin: form.IsGrafanaAdmin,
        }

        if err := bus.Dispatch(&amp;cmd); err != nil </span><span class="cov0" title="0">{
                c.JsonApiErr(500, "Failed to update user permissions", err)
                return
        }</span>

        <span class="cov0" title="0">c.JsonOK("User permissions updated")</span>
}

func AdminDeleteUser(c *middleware.Context) <span class="cov0" title="0">{
        userId := c.ParamsInt64(":id")

        cmd := m.DeleteUserCommand{UserId: userId}

        if err := bus.Dispatch(&amp;cmd); err != nil </span><span class="cov0" title="0">{
                c.JsonApiErr(500, "Failed to delete user", err)
                return
        }</span>

        <span class="cov0" title="0">c.JsonOK("User deleted")</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package api

import (
        "fmt"

        "github.com/grafana/grafana/pkg/api/dtos"
        "github.com/grafana/grafana/pkg/bus"
        "github.com/grafana/grafana/pkg/middleware"
        "github.com/grafana/grafana/pkg/models"
        "github.com/grafana/grafana/pkg/services/alerting"
)

func ValidateOrgAlert(c *middleware.Context) <span class="cov0" title="0">{
        id := c.ParamsInt64(":alertId")
        query := models.GetAlertByIdQuery{Id: id}

        if err := bus.Dispatch(&amp;query); err != nil </span><span class="cov0" title="0">{
                c.JsonApiErr(404, "Alert not found", nil)
                return
        }</span>

        <span class="cov0" title="0">if c.OrgId != query.Result.OrgId </span><span class="cov0" title="0">{
                c.JsonApiErr(403, "You are not allowed to edit/view alert", nil)
                return
        }</span>
}

func GetAlertStatesForDashboard(c *middleware.Context) Response <span class="cov0" title="0">{
        dashboardId := c.QueryInt64("dashboardId")

        if dashboardId == 0 </span><span class="cov0" title="0">{
                return ApiError(400, "Missing query parameter dashboardId", nil)
        }</span>

        <span class="cov0" title="0">query := models.GetAlertStatesForDashboardQuery{
                OrgId:       c.OrgId,
                DashboardId: c.QueryInt64("dashboardId"),
        }

        if err := bus.Dispatch(&amp;query); err != nil </span><span class="cov0" title="0">{
                return ApiError(500, "Failed to fetch alert states", err)
        }</span>

        <span class="cov0" title="0">return Json(200, query.Result)</span>
}

// GET /api/alerts
func GetAlerts(c *middleware.Context) Response <span class="cov0" title="0">{
        query := models.GetAlertsQuery{
                OrgId:       c.OrgId,
                DashboardId: c.QueryInt64("dashboardId"),
                PanelId:     c.QueryInt64("panelId"),
                Limit:       c.QueryInt64("limit"),
        }

        states := c.QueryStrings("state")
        if len(states) &gt; 0 </span><span class="cov0" title="0">{
                query.State = states
        }</span>

        <span class="cov0" title="0">if err := bus.Dispatch(&amp;query); err != nil </span><span class="cov0" title="0">{
                return ApiError(500, "List alerts failed", err)
        }</span>

        <span class="cov0" title="0">dashboardIds := make([]int64, 0)
        alertDTOs := make([]*dtos.AlertRule, 0)
        for _, alert := range query.Result </span><span class="cov0" title="0">{
                dashboardIds = append(dashboardIds, alert.DashboardId)
                alertDTOs = append(alertDTOs, &amp;dtos.AlertRule{
                        Id:             alert.Id,
                        DashboardId:    alert.DashboardId,
                        PanelId:        alert.PanelId,
                        Name:           alert.Name,
                        Message:        alert.Message,
                        State:          alert.State,
                        NewStateDate:   alert.NewStateDate,
                        ExecutionError: alert.ExecutionError,
                        EvalData:       alert.EvalData,
                })
        }</span>

        <span class="cov0" title="0">dashboardsQuery := models.GetDashboardsQuery{
                DashboardIds: dashboardIds,
        }

        if len(alertDTOs) &gt; 0 </span><span class="cov0" title="0">{
                if err := bus.Dispatch(&amp;dashboardsQuery); err != nil </span><span class="cov0" title="0">{
                        return ApiError(500, "List alerts failed", err)
                }</span>
        }

        //TODO: should be possible to speed this up with lookup table
        <span class="cov0" title="0">for _, alert := range alertDTOs </span><span class="cov0" title="0">{
                for _, dash := range dashboardsQuery.Result </span><span class="cov0" title="0">{
                        if alert.DashboardId == dash.Id </span><span class="cov0" title="0">{
                                alert.DashbboardUri = "db/" + dash.Slug
                        }</span>
                }
        }

        <span class="cov0" title="0">return Json(200, alertDTOs)</span>
}

// POST /api/alerts/test
func AlertTest(c *middleware.Context, dto dtos.AlertTestCommand) Response <span class="cov0" title="0">{
        if _, idErr := dto.Dashboard.Get("id").Int64(); idErr != nil </span><span class="cov0" title="0">{
                return ApiError(400, "The dashboard needs to be saved at least once before you can test an alert rule", nil)
        }</span>

        <span class="cov0" title="0">backendCmd := alerting.AlertTestCommand{
                OrgId:     c.OrgId,
                Dashboard: dto.Dashboard,
                PanelId:   dto.PanelId,
        }

        if err := bus.Dispatch(&amp;backendCmd); err != nil </span><span class="cov0" title="0">{
                if validationErr, ok := err.(alerting.ValidationError); ok </span><span class="cov0" title="0">{
                        return ApiError(422, validationErr.Error(), nil)
                }</span>
                <span class="cov0" title="0">return ApiError(500, "Failed to test rule", err)</span>
        }

        <span class="cov0" title="0">res := backendCmd.Result
        dtoRes := &amp;dtos.AlertTestResult{
                Firing:         res.Firing,
                ConditionEvals: res.ConditionEvals,
                State:          res.Rule.State,
        }

        if res.Error != nil </span><span class="cov0" title="0">{
                dtoRes.Error = res.Error.Error()
        }</span>

        <span class="cov0" title="0">for _, log := range res.Logs </span><span class="cov0" title="0">{
                dtoRes.Logs = append(dtoRes.Logs, &amp;dtos.AlertTestResultLog{Message: log.Message, Data: log.Data})
        }</span>
        <span class="cov0" title="0">for _, match := range res.EvalMatches </span><span class="cov0" title="0">{
                dtoRes.EvalMatches = append(dtoRes.EvalMatches, &amp;dtos.EvalMatch{Metric: match.Metric, Value: match.Value})
        }</span>

        <span class="cov0" title="0">dtoRes.TimeMs = fmt.Sprintf("%1.3fms", res.GetDurationMs())

        return Json(200, dtoRes)</span>
}

// GET /api/alerts/:id
func GetAlert(c *middleware.Context) Response <span class="cov0" title="0">{
        id := c.ParamsInt64(":alertId")
        query := models.GetAlertByIdQuery{Id: id}

        if err := bus.Dispatch(&amp;query); err != nil </span><span class="cov0" title="0">{
                return ApiError(500, "List alerts failed", err)
        }</span>

        <span class="cov0" title="0">return Json(200, &amp;query.Result)</span>
}

// DEL /api/alerts/:id
func DelAlert(c *middleware.Context) Response <span class="cov0" title="0">{
        alertId := c.ParamsInt64(":alertId")

        if alertId == 0 </span><span class="cov0" title="0">{
                return ApiError(401, "Failed to parse alertid", nil)
        }</span>

        <span class="cov0" title="0">cmd := models.DeleteAlertCommand{AlertId: alertId}

        if err := bus.Dispatch(&amp;cmd); err != nil </span><span class="cov0" title="0">{
                return ApiError(500, "Failed to delete alert", err)
        }</span>

        <span class="cov0" title="0">var resp = map[string]interface{}{"alertId": alertId}
        return Json(200, resp)</span>
}

func GetAlertNotifiers(c *middleware.Context) Response <span class="cov0" title="0">{
        return Json(200, alerting.GetNotifiers())
}</span>

func GetAlertNotifications(c *middleware.Context) Response <span class="cov0" title="0">{
        query := &amp;models.GetAllAlertNotificationsQuery{OrgId: c.OrgId}

        if err := bus.Dispatch(query); err != nil </span><span class="cov0" title="0">{
                return ApiError(500, "Failed to get alert notifications", err)
        }</span>

        <span class="cov0" title="0">result := make([]*dtos.AlertNotification, 0)

        for _, notification := range query.Result </span><span class="cov0" title="0">{
                result = append(result, &amp;dtos.AlertNotification{
                        Id:        notification.Id,
                        Name:      notification.Name,
                        Type:      notification.Type,
                        IsDefault: notification.IsDefault,
                        Created:   notification.Created,
                        Updated:   notification.Updated,
                })
        }</span>

        <span class="cov0" title="0">return Json(200, result)</span>
}

func GetAlertNotificationById(c *middleware.Context) Response <span class="cov0" title="0">{
        query := &amp;models.GetAlertNotificationsQuery{
                OrgId: c.OrgId,
                Id:    c.ParamsInt64("notificationId"),
        }

        if err := bus.Dispatch(query); err != nil </span><span class="cov0" title="0">{
                return ApiError(500, "Failed to get alert notifications", err)
        }</span>

        <span class="cov0" title="0">return Json(200, query.Result)</span>
}

func CreateAlertNotification(c *middleware.Context, cmd models.CreateAlertNotificationCommand) Response <span class="cov0" title="0">{
        cmd.OrgId = c.OrgId

        if err := bus.Dispatch(&amp;cmd); err != nil </span><span class="cov0" title="0">{
                return ApiError(500, "Failed to create alert notification", err)
        }</span>

        <span class="cov0" title="0">return Json(200, cmd.Result)</span>
}

func UpdateAlertNotification(c *middleware.Context, cmd models.UpdateAlertNotificationCommand) Response <span class="cov0" title="0">{
        cmd.OrgId = c.OrgId

        if err := bus.Dispatch(&amp;cmd); err != nil </span><span class="cov0" title="0">{
                return ApiError(500, "Failed to update alert notification", err)
        }</span>

        <span class="cov0" title="0">return Json(200, cmd.Result)</span>
}

func DeleteAlertNotification(c *middleware.Context) Response <span class="cov0" title="0">{
        cmd := models.DeleteAlertNotificationCommand{
                OrgId: c.OrgId,
                Id:    c.ParamsInt64("notificationId"),
        }

        if err := bus.Dispatch(&amp;cmd); err != nil </span><span class="cov0" title="0">{
                return ApiError(500, "Failed to delete alert notification", err)
        }</span>

        <span class="cov0" title="0">return ApiSuccess("Notification deleted")</span>
}

//POST /api/alert-notifications/test
func NotificationTest(c *middleware.Context, dto dtos.NotificationTestCommand) Response <span class="cov0" title="0">{
        cmd := &amp;alerting.NotificationTestCommand{
                Name:     dto.Name,
                Type:     dto.Type,
                Settings: dto.Settings,
        }

        if err := bus.Dispatch(cmd); err != nil </span><span class="cov0" title="0">{
                return ApiError(500, "Failed to send alert notifications", err)
        }</span>

        <span class="cov0" title="0">return ApiSuccess("Test notification sent")</span>
}

//POST /api/alerts/:alertId/pause
func PauseAlert(c *middleware.Context, dto dtos.PauseAlertCommand) Response <span class="cov0" title="0">{
        alertId := c.ParamsInt64("alertId")
        cmd := models.PauseAlertCommand{
                OrgId:    c.OrgId,
                AlertIds: []int64{alertId},
                Paused:   dto.Paused,
        }

        if err := bus.Dispatch(&amp;cmd); err != nil </span><span class="cov0" title="0">{
                return ApiError(500, "", err)
        }</span>

        <span class="cov0" title="0">var response models.AlertStateType = models.AlertStatePending
        pausedState := "un paused"
        if cmd.Paused </span><span class="cov0" title="0">{
                response = models.AlertStatePaused
                pausedState = "paused"
        }</span>

        <span class="cov0" title="0">result := map[string]interface{}{
                "alertId": alertId,
                "state":   response,
                "message": "alert " + pausedState,
        }

        return Json(200, result)</span>
}

//POST /api/admin/pause-all-alerts
func PauseAllAlerts(c *middleware.Context, dto dtos.PauseAllAlertsCommand) Response <span class="cov0" title="0">{
        updateCmd := models.PauseAllAlertCommand{
                Paused: dto.Paused,
        }

        if err := bus.Dispatch(&amp;updateCmd); err != nil </span><span class="cov0" title="0">{
                return ApiError(500, "Failed to pause alerts", err)
        }</span>

        <span class="cov0" title="0">var response models.AlertStateType = models.AlertStatePending
        pausedState := "un paused"
        if updateCmd.Paused </span><span class="cov0" title="0">{
                response = models.AlertStatePaused
                pausedState = "paused"
        }</span>

        <span class="cov0" title="0">result := map[string]interface{}{
                "state":          response,
                "message":        "alerts " + pausedState,
                "alertsAffected": updateCmd.ResultCount,
        }

        return Json(200, result)</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package api

import (
        "github.com/grafana/grafana/pkg/api/dtos"
        "github.com/grafana/grafana/pkg/middleware"
        "github.com/grafana/grafana/pkg/services/annotations"
)

func GetAnnotations(c *middleware.Context) Response <span class="cov0" title="0">{

        query := &amp;annotations.ItemQuery{
                From:        c.QueryInt64("from") / 1000,
                To:          c.QueryInt64("to") / 1000,
                Type:        annotations.ItemType(c.Query("type")),
                OrgId:       c.OrgId,
                AlertId:     c.QueryInt64("alertId"),
                DashboardId: c.QueryInt64("dashboardId"),
                PanelId:     c.QueryInt64("panelId"),
                Limit:       c.QueryInt64("limit"),
                NewState:    c.QueryStrings("newState"),
        }

        repo := annotations.GetRepository()

        items, err := repo.Find(query)
        if err != nil </span><span class="cov0" title="0">{
                return ApiError(500, "Failed to get annotations", err)
        }</span>

        <span class="cov0" title="0">result := make([]dtos.Annotation, 0)

        for _, item := range items </span><span class="cov0" title="0">{
                result = append(result, dtos.Annotation{
                        AlertId:   item.AlertId,
                        Time:      item.Epoch * 1000,
                        Data:      item.Data,
                        NewState:  item.NewState,
                        PrevState: item.PrevState,
                        Text:      item.Text,
                        Metric:    item.Metric,
                        Title:     item.Title,
                })
        }</span>

        <span class="cov0" title="0">return Json(200, result)</span>
}

func DeleteAnnotations(c *middleware.Context, cmd dtos.DeleteAnnotationsCmd) Response <span class="cov0" title="0">{
        repo := annotations.GetRepository()

        err := repo.Delete(&amp;annotations.DeleteParams{
                AlertId:     cmd.PanelId,
                DashboardId: cmd.DashboardId,
                PanelId:     cmd.PanelId,
        })

        if err != nil </span><span class="cov0" title="0">{
                return ApiError(500, "Failed to delete annotations", err)
        }</span>

        <span class="cov0" title="0">return ApiSuccess("Annotations deleted")</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package api

import (
        "github.com/go-macaron/binding"
        "github.com/grafana/grafana/pkg/api/avatar"
        "github.com/grafana/grafana/pkg/api/dtos"
        "github.com/grafana/grafana/pkg/middleware"
        m "github.com/grafana/grafana/pkg/models"
)

// Register adds http routes
func (hs *HttpServer) registerRoutes() <span class="cov0" title="0">{
        r := hs.macaron
        reqSignedIn := middleware.Auth(&amp;middleware.AuthOptions{ReqSignedIn: true})
        reqGrafanaAdmin := middleware.Auth(&amp;middleware.AuthOptions{ReqSignedIn: true, ReqGrafanaAdmin: true})
        reqEditorRole := middleware.RoleAuth(m.ROLE_EDITOR, m.ROLE_ADMIN)
        reqOrgAdmin := middleware.RoleAuth(m.ROLE_ADMIN)
        quota := middleware.Quota
        bind := binding.Bind

        // automatically set HEAD for every GET
        r.SetAutoHead(true)

        // not logged in views
        r.Get("/", reqSignedIn, Index)
        r.Get("/logout", Logout)
        r.Post("/login", quota("session"), bind(dtos.LoginCommand{}), wrap(LoginPost))
        r.Get("/login/:name", quota("session"), OAuthLogin)
        r.Get("/login", LoginView)
        r.Get("/invite/:code", Index)

        // authed views
        r.Get("/profile/", reqSignedIn, Index)
        r.Get("/profile/password", reqSignedIn, Index)
        r.Get("/profile/switch-org/:id", reqSignedIn, ChangeActiveOrgAndRedirectToHome)
        r.Get("/org/", reqSignedIn, Index)
        r.Get("/org/new", reqSignedIn, Index)
        r.Get("/datasources/", reqSignedIn, Index)
        r.Get("/datasources/new", reqSignedIn, Index)
        r.Get("/datasources/edit/*", reqSignedIn, Index)
        r.Get("/org/users/", reqSignedIn, Index)
        r.Get("/org/apikeys/", reqSignedIn, Index)
        r.Get("/dashboard/import/", reqSignedIn, Index)
        r.Get("/admin", reqGrafanaAdmin, Index)
        r.Get("/admin/settings", reqGrafanaAdmin, Index)
        r.Get("/admin/users", reqGrafanaAdmin, Index)
        r.Get("/admin/users/create", reqGrafanaAdmin, Index)
        r.Get("/admin/users/edit/:id", reqGrafanaAdmin, Index)
        r.Get("/admin/orgs", reqGrafanaAdmin, Index)
        r.Get("/admin/orgs/edit/:id", reqGrafanaAdmin, Index)
        r.Get("/admin/stats", reqGrafanaAdmin, Index)

        r.Get("/styleguide", reqSignedIn, Index)

        r.Get("/plugins", reqSignedIn, Index)
        r.Get("/plugins/:id/edit", reqSignedIn, Index)
        r.Get("/plugins/:id/page/:page", reqSignedIn, Index)

        r.Get("/dashboard/*", reqSignedIn, Index)
        r.Get("/dashboard-solo/snapshot/*", Index)
        r.Get("/dashboard-solo/*", reqSignedIn, Index)
        r.Get("/import/dashboard", reqSignedIn, Index)
        r.Get("/dashboards/*", reqSignedIn, Index)

        r.Get("/playlists/", reqSignedIn, Index)
        r.Get("/playlists/*", reqSignedIn, Index)
        r.Get("/alerting/", reqSignedIn, Index)
        r.Get("/alerting/*", reqSignedIn, Index)

        // sign up
        r.Get("/signup", Index)
        r.Get("/api/user/signup/options", wrap(GetSignUpOptions))
        r.Post("/api/user/signup", quota("user"), bind(dtos.SignUpForm{}), wrap(SignUp))
        r.Post("/api/user/signup/step2", bind(dtos.SignUpStep2Form{}), wrap(SignUpStep2))

        // invited
        r.Get("/api/user/invite/:code", wrap(GetInviteInfoByCode))
        r.Post("/api/user/invite/complete", bind(dtos.CompleteInviteForm{}), wrap(CompleteInvite))

        // reset password
        r.Get("/user/password/send-reset-email", Index)
        r.Get("/user/password/reset", Index)

        r.Post("/api/user/password/send-reset-email", bind(dtos.SendResetPasswordEmailForm{}), wrap(SendResetPasswordEmail))
        r.Post("/api/user/password/reset", bind(dtos.ResetUserPasswordForm{}), wrap(ResetPassword))

        // dashboard snapshots
        r.Get("/dashboard/snapshot/*", Index)
        r.Get("/dashboard/snapshots/", reqSignedIn, Index)

        // api for dashboard snapshots
        r.Post("/api/snapshots/", bind(m.CreateDashboardSnapshotCommand{}), CreateDashboardSnapshot)
        r.Get("/api/snapshot/shared-options/", GetSharingOptions)
        r.Get("/api/snapshots/:key", GetDashboardSnapshot)
        r.Get("/api/snapshots-delete/:key", reqEditorRole, DeleteDashboardSnapshot)

        // api renew session based on remember cookie
        r.Get("/api/login/ping", quota("session"), LoginApiPing)

        // authed api
        r.Group("/api", func() </span><span class="cov0" title="0">{

                // user (signed in)
                r.Group("/user", func() </span><span class="cov0" title="0">{
                        r.Get("/", wrap(GetSignedInUser))
                        r.Put("/", bind(m.UpdateUserCommand{}), wrap(UpdateSignedInUser))
                        r.Post("/using/:id", wrap(UserSetUsingOrg))
                        r.Get("/orgs", wrap(GetSignedInUserOrgList))

                        r.Post("/stars/dashboard/:id", wrap(StarDashboard))
                        r.Delete("/stars/dashboard/:id", wrap(UnstarDashboard))

                        r.Put("/password", bind(m.ChangeUserPasswordCommand{}), wrap(ChangeUserPassword))
                        r.Get("/quotas", wrap(GetUserQuotas))
                        r.Put("/helpflags/:id", wrap(SetHelpFlag))
                        // For dev purpose
                        r.Get("/helpflags/clear", wrap(ClearHelpFlags))

                        r.Get("/preferences", wrap(GetUserPreferences))
                        r.Put("/preferences", bind(dtos.UpdatePrefsCmd{}), wrap(UpdateUserPreferences))
                }</span>)

                // users (admin permission required)
                <span class="cov0" title="0">r.Group("/users", func() </span><span class="cov0" title="0">{
                        r.Get("/", wrap(SearchUsers))
                        r.Get("/search", wrap(SearchUsersWithPaging))
                        r.Get("/:id", wrap(GetUserById))
                        r.Get("/:id/orgs", wrap(GetUserOrgList))
                        // query parameters /users/lookup?loginOrEmail=admin@example.com
                        r.Get("/lookup", wrap(GetUserByLoginOrEmail))
                        r.Put("/:id", bind(m.UpdateUserCommand{}), wrap(UpdateUser))
                        r.Post("/:id/using/:orgId", wrap(UpdateUserActiveOrg))
                }</span>, reqGrafanaAdmin)

                // org information available to all users.
                <span class="cov0" title="0">r.Group("/org", func() </span><span class="cov0" title="0">{
                        r.Get("/", wrap(GetOrgCurrent))
                        r.Get("/quotas", wrap(GetOrgQuotas))
                }</span>)

                // current org
                <span class="cov0" title="0">r.Group("/org", func() </span><span class="cov0" title="0">{
                        r.Put("/", bind(dtos.UpdateOrgForm{}), wrap(UpdateOrgCurrent))
                        r.Put("/address", bind(dtos.UpdateOrgAddressForm{}), wrap(UpdateOrgAddressCurrent))
                        r.Post("/users", quota("user"), bind(m.AddOrgUserCommand{}), wrap(AddOrgUserToCurrentOrg))
                        r.Get("/users", wrap(GetOrgUsersForCurrentOrg))
                        r.Patch("/users/:userId", bind(m.UpdateOrgUserCommand{}), wrap(UpdateOrgUserForCurrentOrg))
                        r.Delete("/users/:userId", wrap(RemoveOrgUserForCurrentOrg))

                        // invites
                        r.Get("/invites", wrap(GetPendingOrgInvites))
                        r.Post("/invites", quota("user"), bind(dtos.AddInviteForm{}), wrap(AddOrgInvite))
                        r.Patch("/invites/:code/revoke", wrap(RevokeInvite))

                        // prefs
                        r.Get("/preferences", wrap(GetOrgPreferences))
                        r.Put("/preferences", bind(dtos.UpdatePrefsCmd{}), wrap(UpdateOrgPreferences))
                }</span>, reqOrgAdmin)

                // create new org
                <span class="cov0" title="0">r.Post("/orgs", quota("org"), bind(m.CreateOrgCommand{}), wrap(CreateOrg))

                // search all orgs
                r.Get("/orgs", reqGrafanaAdmin, wrap(SearchOrgs))

                // orgs (admin routes)
                r.Group("/orgs/:orgId", func() </span><span class="cov0" title="0">{
                        r.Get("/", wrap(GetOrgById))
                        r.Put("/", bind(dtos.UpdateOrgForm{}), wrap(UpdateOrg))
                        r.Put("/address", bind(dtos.UpdateOrgAddressForm{}), wrap(UpdateOrgAddress))
                        r.Delete("/", wrap(DeleteOrgById))
                        r.Get("/users", wrap(GetOrgUsers))
                        r.Post("/users", bind(m.AddOrgUserCommand{}), wrap(AddOrgUser))
                        r.Patch("/users/:userId", bind(m.UpdateOrgUserCommand{}), wrap(UpdateOrgUser))
                        r.Delete("/users/:userId", wrap(RemoveOrgUser))
                        r.Get("/quotas", wrap(GetOrgQuotas))
                        r.Put("/quotas/:target", bind(m.UpdateOrgQuotaCmd{}), wrap(UpdateOrgQuota))
                }</span>, reqGrafanaAdmin)

                // orgs (admin routes)
                <span class="cov0" title="0">r.Group("/orgs/name/:name", func() </span><span class="cov0" title="0">{
                        r.Get("/", wrap(GetOrgByName))
                }</span>, reqGrafanaAdmin)

                // auth api keys
                <span class="cov0" title="0">r.Group("/auth/keys", func() </span><span class="cov0" title="0">{
                        r.Get("/", wrap(GetApiKeys))
                        r.Post("/", quota("api_key"), bind(m.AddApiKeyCommand{}), wrap(AddApiKey))
                        r.Delete("/:id", wrap(DeleteApiKey))
                }</span>, reqOrgAdmin)

                // Preferences
                <span class="cov0" title="0">r.Group("/preferences", func() </span><span class="cov0" title="0">{
                        r.Post("/set-home-dash", bind(m.SavePreferencesCommand{}), wrap(SetHomeDashboard))
                }</span>)

                // Data sources
                <span class="cov0" title="0">r.Group("/datasources", func() </span><span class="cov0" title="0">{
                        r.Get("/", wrap(GetDataSources))
                        r.Post("/", quota("data_source"), bind(m.AddDataSourceCommand{}), AddDataSource)
                        r.Put("/:id", bind(m.UpdateDataSourceCommand{}), wrap(UpdateDataSource))
                        r.Delete("/:id", DeleteDataSourceById)
                        r.Delete("/name/:name", DeleteDataSourceByName)
                        r.Get("/:id", wrap(GetDataSourceById))
                        r.Get("/name/:name", wrap(GetDataSourceByName))
                }</span>, reqOrgAdmin)

                <span class="cov0" title="0">r.Get("/datasources/id/:name", wrap(GetDataSourceIdByName), reqSignedIn)

                r.Get("/plugins", wrap(GetPluginList))
                r.Get("/plugins/:pluginId/settings", wrap(GetPluginSettingById))
                r.Get("/plugins/:pluginId/readme", wrap(GetPluginReadme))

                r.Group("/plugins", func() </span><span class="cov0" title="0">{
                        r.Get("/:pluginId/dashboards/", wrap(GetPluginDashboards))
                        r.Post("/:pluginId/settings", bind(m.UpdatePluginSettingCmd{}), wrap(UpdatePluginSetting))
                }</span>, reqOrgAdmin)

                <span class="cov0" title="0">r.Get("/frontend/settings/", GetFrontendSettings)
                r.Any("/datasources/proxy/:id/*", reqSignedIn, ProxyDataSourceRequest)
                r.Any("/datasources/proxy/:id", reqSignedIn, ProxyDataSourceRequest)

                // Dashboard
                r.Group("/dashboards", func() </span><span class="cov0" title="0">{
                        r.Combo("/db/:slug").Get(GetDashboard).Delete(DeleteDashboard)
                        r.Post("/db", reqEditorRole, bind(m.SaveDashboardCommand{}), wrap(PostDashboard))
                        r.Get("/file/:file", GetDashboardFromJsonFile)
                        r.Get("/home", wrap(GetHomeDashboard))
                        r.Get("/tags", GetDashboardTags)
                        r.Post("/import", bind(dtos.ImportDashboardCommand{}), wrap(ImportDashboard))
                }</span>)

                // Dashboard snapshots
                <span class="cov0" title="0">r.Group("/dashboard/snapshots", func() </span><span class="cov0" title="0">{
                        r.Get("/", wrap(SearchDashboardSnapshots))
                }</span>)

                // Playlist
                <span class="cov0" title="0">r.Group("/playlists", func() </span><span class="cov0" title="0">{
                        r.Get("/", wrap(SearchPlaylists))
                        r.Get("/:id", ValidateOrgPlaylist, wrap(GetPlaylist))
                        r.Get("/:id/items", ValidateOrgPlaylist, wrap(GetPlaylistItems))
                        r.Get("/:id/dashboards", ValidateOrgPlaylist, wrap(GetPlaylistDashboards))
                        r.Delete("/:id", reqEditorRole, ValidateOrgPlaylist, wrap(DeletePlaylist))
                        r.Put("/:id", reqEditorRole, bind(m.UpdatePlaylistCommand{}), ValidateOrgPlaylist, wrap(UpdatePlaylist))
                        r.Post("/", reqEditorRole, bind(m.CreatePlaylistCommand{}), wrap(CreatePlaylist))
                }</span>)

                // Search
                <span class="cov0" title="0">r.Get("/search/", Search)

                // metrics
                r.Post("/tsdb/query", bind(dtos.MetricRequest{}), wrap(QueryMetrics))
                r.Get("/tsdb/testdata/scenarios", wrap(GetTestDataScenarios))

                // metrics
                r.Get("/metrics", wrap(GetInternalMetrics))

                r.Group("/alerts", func() </span><span class="cov0" title="0">{
                        r.Post("/test", bind(dtos.AlertTestCommand{}), wrap(AlertTest))
                        r.Post("/:alertId/pause", bind(dtos.PauseAlertCommand{}), wrap(PauseAlert), reqEditorRole)
                        r.Get("/:alertId", ValidateOrgAlert, wrap(GetAlert))
                        r.Get("/", wrap(GetAlerts))
                        r.Get("/states-for-dashboard", wrap(GetAlertStatesForDashboard))
                }</span>)

                <span class="cov0" title="0">r.Get("/alert-notifications", wrap(GetAlertNotifications))
                r.Get("/alert-notifiers", wrap(GetAlertNotifiers))

                r.Group("/alert-notifications", func() </span><span class="cov0" title="0">{
                        r.Post("/test", bind(dtos.NotificationTestCommand{}), wrap(NotificationTest))
                        r.Post("/", bind(m.CreateAlertNotificationCommand{}), wrap(CreateAlertNotification))
                        r.Put("/:notificationId", bind(m.UpdateAlertNotificationCommand{}), wrap(UpdateAlertNotification))
                        r.Get("/:notificationId", wrap(GetAlertNotificationById))
                        r.Delete("/:notificationId", wrap(DeleteAlertNotification))
                }</span>, reqEditorRole)

                <span class="cov0" title="0">r.Get("/annotations", wrap(GetAnnotations))
                r.Post("/annotations/mass-delete", reqOrgAdmin, bind(dtos.DeleteAnnotationsCmd{}), wrap(DeleteAnnotations))

                // error test
                r.Get("/metrics/error", wrap(GenerateError))</span>

        }, reqSignedIn)

        // admin api
        <span class="cov0" title="0">r.Group("/api/admin", func() </span><span class="cov0" title="0">{
                r.Get("/settings", AdminGetSettings)
                r.Post("/users", bind(dtos.AdminCreateUserForm{}), AdminCreateUser)
                r.Put("/users/:id/password", bind(dtos.AdminUpdateUserPasswordForm{}), AdminUpdateUserPassword)
                r.Put("/users/:id/permissions", bind(dtos.AdminUpdateUserPermissionsForm{}), AdminUpdateUserPermissions)
                r.Delete("/users/:id", AdminDeleteUser)
                r.Get("/users/:id/quotas", wrap(GetUserQuotas))
                r.Put("/users/:id/quotas/:target", bind(m.UpdateUserQuotaCmd{}), wrap(UpdateUserQuota))
                r.Get("/stats", AdminGetStats)
                r.Post("/pause-all-alerts", bind(dtos.PauseAllAlertsCommand{}), wrap(PauseAllAlerts))
        }</span>, reqGrafanaAdmin)

        // rendering
        <span class="cov0" title="0">r.Get("/render/*", reqSignedIn, RenderToPng)

        // grafana.net proxy
        r.Any("/api/gnet/*", reqSignedIn, ProxyGnetRequest)

        // Gravatar service.
        avt := avatar.CacheServer()
        r.Get("/avatar/:hash", avt.ServeHTTP)

        // Websocket
        r.Any("/ws", hs.streamManager.Serve)

        // streams
        //r.Post("/api/streams/push", reqSignedIn, bind(dtos.StreamMessage{}), liveConn.PushToStream)

        InitAppPluginRoutes(r)

        r.NotFound(NotFoundHandler)</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package api

import (
        "github.com/grafana/grafana/pkg/api/dtos"
        "github.com/grafana/grafana/pkg/bus"
        "github.com/grafana/grafana/pkg/components/apikeygen"
        "github.com/grafana/grafana/pkg/middleware"
        m "github.com/grafana/grafana/pkg/models"
)

func GetApiKeys(c *middleware.Context) Response <span class="cov0" title="0">{
        query := m.GetApiKeysQuery{OrgId: c.OrgId}

        if err := bus.Dispatch(&amp;query); err != nil </span><span class="cov0" title="0">{
                return ApiError(500, "Failed to list api keys", err)
        }</span>

        <span class="cov0" title="0">result := make([]*m.ApiKeyDTO, len(query.Result))
        for i, t := range query.Result </span><span class="cov0" title="0">{
                result[i] = &amp;m.ApiKeyDTO{
                        Id:   t.Id,
                        Name: t.Name,
                        Role: t.Role,
                }
        }</span>

        <span class="cov0" title="0">return Json(200, result)</span>
}

func DeleteApiKey(c *middleware.Context) Response <span class="cov0" title="0">{
        id := c.ParamsInt64(":id")

        cmd := &amp;m.DeleteApiKeyCommand{Id: id, OrgId: c.OrgId}

        err := bus.Dispatch(cmd)
        if err != nil </span><span class="cov0" title="0">{
                return ApiError(500, "Failed to delete API key", err)
        }</span>

        <span class="cov0" title="0">return ApiSuccess("API key deleted")</span>
}

func AddApiKey(c *middleware.Context, cmd m.AddApiKeyCommand) Response <span class="cov0" title="0">{
        if !cmd.Role.IsValid() </span><span class="cov0" title="0">{
                return ApiError(400, "Invalid role specified", nil)
        }</span>

        <span class="cov0" title="0">cmd.OrgId = c.OrgId

        newKeyInfo := apikeygen.New(cmd.OrgId, cmd.Name)
        cmd.Key = newKeyInfo.HashedKey

        if err := bus.Dispatch(&amp;cmd); err != nil </span><span class="cov0" title="0">{
                return ApiError(500, "Failed to add API key", err)
        }</span>

        <span class="cov0" title="0">result := &amp;dtos.NewApiKeyResult{
                Name: cmd.Result.Name,
                Key:  newKeyInfo.ClientSecret}

        return Json(200, result)</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package api

import (
        "crypto/tls"
        "net"
        "net/http"
        "time"

        "gopkg.in/macaron.v1"

        "github.com/grafana/grafana/pkg/api/pluginproxy"
        "github.com/grafana/grafana/pkg/log"
        "github.com/grafana/grafana/pkg/middleware"
        m "github.com/grafana/grafana/pkg/models"
        "github.com/grafana/grafana/pkg/plugins"
        "github.com/grafana/grafana/pkg/util"
)

var pluginProxyTransport = &amp;http.Transport{
        TLSClientConfig: &amp;tls.Config{InsecureSkipVerify: true},
        Proxy:           http.ProxyFromEnvironment,
        Dial: (&amp;net.Dialer{
                Timeout:   30 * time.Second,
                KeepAlive: 30 * time.Second,
        }).Dial,
        TLSHandshakeTimeout: 10 * time.Second,
}

func InitAppPluginRoutes(r *macaron.Macaron) <span class="cov0" title="0">{
        for _, plugin := range plugins.Apps </span><span class="cov0" title="0">{
                for _, route := range plugin.Routes </span><span class="cov0" title="0">{
                        url := util.JoinUrlFragments("/api/plugin-proxy/"+plugin.Id, route.Path)
                        handlers := make([]macaron.Handler, 0)
                        handlers = append(handlers, middleware.Auth(&amp;middleware.AuthOptions{
                                ReqSignedIn:     true,
                                ReqGrafanaAdmin: route.ReqGrafanaAdmin,
                        }))

                        if route.ReqRole != "" </span><span class="cov0" title="0">{
                                if route.ReqRole == m.ROLE_ADMIN </span><span class="cov0" title="0">{
                                        handlers = append(handlers, middleware.RoleAuth(m.ROLE_ADMIN))
                                }</span><span class="cov0" title="0"> else if route.ReqRole == m.ROLE_EDITOR </span><span class="cov0" title="0">{
                                        handlers = append(handlers, middleware.RoleAuth(m.ROLE_EDITOR, m.ROLE_ADMIN))
                                }</span>
                        }
                        <span class="cov0" title="0">handlers = append(handlers, AppPluginRoute(route, plugin.Id))
                        r.Route(url, route.Method, handlers...)
                        log.Debug("Plugins: Adding proxy route %s", url)</span>
                }
        }
}

func AppPluginRoute(route *plugins.AppPluginRoute, appId string) macaron.Handler <span class="cov0" title="0">{
        return func(c *middleware.Context) </span><span class="cov0" title="0">{
                path := c.Params("*")

                proxy := pluginproxy.NewApiPluginProxy(c, path, route, appId)
                proxy.Transport = pluginProxyTransport
                proxy.ServeHTTP(c.Resp, c.Req.Request)
        }</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package cloudwatch

import (
        "encoding/json"
        "errors"
        "io/ioutil"
        "strings"
        "sync"
        "time"

        "github.com/aws/aws-sdk-go/aws"
        "github.com/aws/aws-sdk-go/aws/awsutil"
        "github.com/aws/aws-sdk-go/aws/credentials"
        "github.com/aws/aws-sdk-go/aws/credentials/ec2rolecreds"
        "github.com/aws/aws-sdk-go/aws/ec2metadata"
        "github.com/aws/aws-sdk-go/aws/session"
        "github.com/aws/aws-sdk-go/service/cloudwatch"
        "github.com/aws/aws-sdk-go/service/ec2"
        "github.com/aws/aws-sdk-go/service/sts"
        "github.com/grafana/grafana/pkg/metrics"
        "github.com/grafana/grafana/pkg/middleware"
        m "github.com/grafana/grafana/pkg/models"
)

type actionHandler func(*cwRequest, *middleware.Context)

var actionHandlers map[string]actionHandler

type cwRequest struct {
        Region     string `json:"region"`
        Action     string `json:"action"`
        Body       []byte `json:"-"`
        DataSource *m.DataSource
}

type datasourceInfo struct {
        Profile       string
        Region        string
        AssumeRoleArn string
        Namespace     string

        AccessKey string
        SecretKey string
}

func (req *cwRequest) GetDatasourceInfo() *datasourceInfo <span class="cov0" title="0">{
        assumeRoleArn := req.DataSource.JsonData.Get("assumeRoleArn").MustString()
        accessKey := ""
        secretKey := ""

        for key, value := range req.DataSource.SecureJsonData.Decrypt() </span><span class="cov0" title="0">{
                if key == "accessKey" </span><span class="cov0" title="0">{
                        accessKey = value
                }</span>
                <span class="cov0" title="0">if key == "secretKey" </span><span class="cov0" title="0">{
                        secretKey = value
                }</span>
        }

        <span class="cov0" title="0">return &amp;datasourceInfo{
                AssumeRoleArn: assumeRoleArn,
                Region:        req.Region,
                Profile:       req.DataSource.Database,
                AccessKey:     accessKey,
                SecretKey:     secretKey,
        }</span>
}

func init() <span class="cov8" title="1">{
        actionHandlers = map[string]actionHandler{
                "GetMetricStatistics":     handleGetMetricStatistics,
                "ListMetrics":             handleListMetrics,
                "DescribeAlarms":          handleDescribeAlarms,
                "DescribeAlarmsForMetric": handleDescribeAlarmsForMetric,
                "DescribeAlarmHistory":    handleDescribeAlarmHistory,
                "DescribeInstances":       handleDescribeInstances,
                "__GetRegions":            handleGetRegions,
                "__GetNamespaces":         handleGetNamespaces,
                "__GetMetrics":            handleGetMetrics,
                "__GetDimensions":         handleGetDimensions,
        }
}</span>

type cache struct {
        credential *credentials.Credentials
        expiration *time.Time
}

var awsCredentialCache map[string]cache = make(map[string]cache)
var credentialCacheLock sync.RWMutex

func getCredentials(dsInfo *datasourceInfo) (*credentials.Credentials, error) <span class="cov0" title="0">{
        cacheKey := dsInfo.Profile + ":" + dsInfo.AssumeRoleArn
        credentialCacheLock.RLock()
        if _, ok := awsCredentialCache[cacheKey]; ok </span><span class="cov0" title="0">{
                if awsCredentialCache[cacheKey].expiration != nil &amp;&amp;
                        (*awsCredentialCache[cacheKey].expiration).After(time.Now().UTC()) </span><span class="cov0" title="0">{
                        result := awsCredentialCache[cacheKey].credential
                        credentialCacheLock.RUnlock()
                        return result, nil
                }</span>
        }
        <span class="cov0" title="0">credentialCacheLock.RUnlock()

        accessKeyId := ""
        secretAccessKey := ""
        sessionToken := ""
        var expiration *time.Time
        expiration = nil
        if strings.Index(dsInfo.AssumeRoleArn, "arn:aws:iam:") == 0 </span><span class="cov0" title="0">{
                params := &amp;sts.AssumeRoleInput{
                        RoleArn:         aws.String(dsInfo.AssumeRoleArn),
                        RoleSessionName: aws.String("GrafanaSession"),
                        DurationSeconds: aws.Int64(900),
                }

                stsSess := session.New()
                stsCreds := credentials.NewChainCredentials(
                        []credentials.Provider{
                                &amp;credentials.EnvProvider{},
                                &amp;credentials.SharedCredentialsProvider{Filename: "", Profile: dsInfo.Profile},
                                &amp;ec2rolecreds.EC2RoleProvider{Client: ec2metadata.New(stsSess), ExpiryWindow: 5 * time.Minute},
                        })
                stsConfig := &amp;aws.Config{
                        Region:      aws.String(dsInfo.Region),
                        Credentials: stsCreds,
                }

                svc := sts.New(session.New(stsConfig), stsConfig)
                resp, err := svc.AssumeRole(params)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">if resp.Credentials != nil </span><span class="cov0" title="0">{
                        accessKeyId = *resp.Credentials.AccessKeyId
                        secretAccessKey = *resp.Credentials.SecretAccessKey
                        sessionToken = *resp.Credentials.SessionToken
                        expiration = resp.Credentials.Expiration
                }</span>
        }

        <span class="cov0" title="0">sess := session.New()
        creds := credentials.NewChainCredentials(
                []credentials.Provider{
                        &amp;credentials.StaticProvider{Value: credentials.Value{
                                AccessKeyID:     accessKeyId,
                                SecretAccessKey: secretAccessKey,
                                SessionToken:    sessionToken,
                        }},
                        &amp;credentials.EnvProvider{},
                        &amp;credentials.StaticProvider{Value: credentials.Value{
                                AccessKeyID:     dsInfo.AccessKey,
                                SecretAccessKey: dsInfo.SecretKey,
                        }},
                        &amp;credentials.SharedCredentialsProvider{Filename: "", Profile: dsInfo.Profile},
                        &amp;ec2rolecreds.EC2RoleProvider{Client: ec2metadata.New(sess), ExpiryWindow: 5 * time.Minute},
                })

        credentialCacheLock.Lock()
        awsCredentialCache[cacheKey] = cache{
                credential: creds,
                expiration: expiration,
        }
        credentialCacheLock.Unlock()

        return creds, nil</span>
}

func getAwsConfig(req *cwRequest) (*aws.Config, error) <span class="cov0" title="0">{
        creds, err := getCredentials(req.GetDatasourceInfo())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">cfg := &amp;aws.Config{
                Region:      aws.String(req.Region),
                Credentials: creds,
        }
        return cfg, nil</span>
}

func handleGetMetricStatistics(req *cwRequest, c *middleware.Context) <span class="cov0" title="0">{
        cfg, err := getAwsConfig(req)
        if err != nil </span><span class="cov0" title="0">{
                c.JsonApiErr(500, "Unable to call AWS API", err)
                return
        }</span>
        <span class="cov0" title="0">svc := cloudwatch.New(session.New(cfg), cfg)

        reqParam := &amp;struct {
                Parameters struct {
                        Namespace          string                  `json:"namespace"`
                        MetricName         string                  `json:"metricName"`
                        Dimensions         []*cloudwatch.Dimension `json:"dimensions"`
                        Statistics         []*string               `json:"statistics"`
                        ExtendedStatistics []*string               `json:"extendedStatistics"`
                        StartTime          int64                   `json:"startTime"`
                        EndTime            int64                   `json:"endTime"`
                        Period             int64                   `json:"period"`
                } `json:"parameters"`
        }{}
        json.Unmarshal(req.Body, reqParam)

        params := &amp;cloudwatch.GetMetricStatisticsInput{
                Namespace:  aws.String(reqParam.Parameters.Namespace),
                MetricName: aws.String(reqParam.Parameters.MetricName),
                Dimensions: reqParam.Parameters.Dimensions,
                StartTime:  aws.Time(time.Unix(reqParam.Parameters.StartTime, 0)),
                EndTime:    aws.Time(time.Unix(reqParam.Parameters.EndTime, 0)),
                Period:     aws.Int64(reqParam.Parameters.Period),
        }
        if len(reqParam.Parameters.Statistics) != 0 </span><span class="cov0" title="0">{
                params.Statistics = reqParam.Parameters.Statistics
        }</span>
        <span class="cov0" title="0">if len(reqParam.Parameters.ExtendedStatistics) != 0 </span><span class="cov0" title="0">{
                params.ExtendedStatistics = reqParam.Parameters.ExtendedStatistics
        }</span>

        <span class="cov0" title="0">resp, err := svc.GetMetricStatistics(params)
        if err != nil </span><span class="cov0" title="0">{
                c.JsonApiErr(500, "Unable to call AWS API", err)
                return
        }</span>
        <span class="cov0" title="0">metrics.M_Aws_CloudWatch_GetMetricStatistics.Inc(1)

        c.JSON(200, resp)</span>
}

func handleListMetrics(req *cwRequest, c *middleware.Context) <span class="cov0" title="0">{
        cfg, err := getAwsConfig(req)
        if err != nil </span><span class="cov0" title="0">{
                c.JsonApiErr(500, "Unable to call AWS API", err)
                return
        }</span>
        <span class="cov0" title="0">svc := cloudwatch.New(session.New(cfg), cfg)

        reqParam := &amp;struct {
                Parameters struct {
                        Namespace  string                        `json:"namespace"`
                        MetricName string                        `json:"metricName"`
                        Dimensions []*cloudwatch.DimensionFilter `json:"dimensions"`
                } `json:"parameters"`
        }{}
        json.Unmarshal(req.Body, reqParam)

        params := &amp;cloudwatch.ListMetricsInput{
                Namespace:  aws.String(reqParam.Parameters.Namespace),
                MetricName: aws.String(reqParam.Parameters.MetricName),
                Dimensions: reqParam.Parameters.Dimensions,
        }

        var resp cloudwatch.ListMetricsOutput
        err = svc.ListMetricsPages(params,
                func(page *cloudwatch.ListMetricsOutput, lastPage bool) bool </span><span class="cov0" title="0">{
                        metrics.M_Aws_CloudWatch_ListMetrics.Inc(1)
                        metrics, _ := awsutil.ValuesAtPath(page, "Metrics")
                        for _, metric := range metrics </span><span class="cov0" title="0">{
                                resp.Metrics = append(resp.Metrics, metric.(*cloudwatch.Metric))
                        }</span>
                        <span class="cov0" title="0">return !lastPage</span>
                })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                c.JsonApiErr(500, "Unable to call AWS API", err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(200, resp)</span>
}

func handleDescribeAlarms(req *cwRequest, c *middleware.Context) <span class="cov0" title="0">{
        cfg, err := getAwsConfig(req)
        if err != nil </span><span class="cov0" title="0">{
                c.JsonApiErr(500, "Unable to call AWS API", err)
                return
        }</span>
        <span class="cov0" title="0">svc := cloudwatch.New(session.New(cfg), cfg)

        reqParam := &amp;struct {
                Parameters struct {
                        ActionPrefix    string    `json:"actionPrefix"`
                        AlarmNamePrefix string    `json:"alarmNamePrefix"`
                        AlarmNames      []*string `json:"alarmNames"`
                        StateValue      string    `json:"stateValue"`
                } `json:"parameters"`
        }{}
        json.Unmarshal(req.Body, reqParam)

        params := &amp;cloudwatch.DescribeAlarmsInput{
                MaxRecords: aws.Int64(100),
        }
        if reqParam.Parameters.ActionPrefix != "" </span><span class="cov0" title="0">{
                params.ActionPrefix = aws.String(reqParam.Parameters.ActionPrefix)
        }</span>
        <span class="cov0" title="0">if reqParam.Parameters.AlarmNamePrefix != "" </span><span class="cov0" title="0">{
                params.AlarmNamePrefix = aws.String(reqParam.Parameters.AlarmNamePrefix)
        }</span>
        <span class="cov0" title="0">if len(reqParam.Parameters.AlarmNames) != 0 </span><span class="cov0" title="0">{
                params.AlarmNames = reqParam.Parameters.AlarmNames
        }</span>
        <span class="cov0" title="0">if reqParam.Parameters.StateValue != "" </span><span class="cov0" title="0">{
                params.StateValue = aws.String(reqParam.Parameters.StateValue)
        }</span>

        <span class="cov0" title="0">resp, err := svc.DescribeAlarms(params)
        if err != nil </span><span class="cov0" title="0">{
                c.JsonApiErr(500, "Unable to call AWS API", err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(200, resp)</span>
}

func handleDescribeAlarmsForMetric(req *cwRequest, c *middleware.Context) <span class="cov0" title="0">{
        cfg, err := getAwsConfig(req)
        if err != nil </span><span class="cov0" title="0">{
                c.JsonApiErr(500, "Unable to call AWS API", err)
                return
        }</span>
        <span class="cov0" title="0">svc := cloudwatch.New(session.New(cfg), cfg)

        reqParam := &amp;struct {
                Parameters struct {
                        Namespace         string                  `json:"namespace"`
                        MetricName        string                  `json:"metricName"`
                        Dimensions        []*cloudwatch.Dimension `json:"dimensions"`
                        Statistic         string                  `json:"statistic"`
                        ExtendedStatistic string                  `json:"extendedStatistic"`
                        Period            int64                   `json:"period"`
                } `json:"parameters"`
        }{}
        json.Unmarshal(req.Body, reqParam)

        params := &amp;cloudwatch.DescribeAlarmsForMetricInput{
                Namespace:  aws.String(reqParam.Parameters.Namespace),
                MetricName: aws.String(reqParam.Parameters.MetricName),
                Period:     aws.Int64(reqParam.Parameters.Period),
        }
        if len(reqParam.Parameters.Dimensions) != 0 </span><span class="cov0" title="0">{
                params.Dimensions = reqParam.Parameters.Dimensions
        }</span>
        <span class="cov0" title="0">if reqParam.Parameters.Statistic != "" </span><span class="cov0" title="0">{
                params.Statistic = aws.String(reqParam.Parameters.Statistic)
        }</span>
        <span class="cov0" title="0">if reqParam.Parameters.ExtendedStatistic != "" </span><span class="cov0" title="0">{
                params.ExtendedStatistic = aws.String(reqParam.Parameters.ExtendedStatistic)
        }</span>

        <span class="cov0" title="0">resp, err := svc.DescribeAlarmsForMetric(params)
        if err != nil </span><span class="cov0" title="0">{
                c.JsonApiErr(500, "Unable to call AWS API", err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(200, resp)</span>
}

func handleDescribeAlarmHistory(req *cwRequest, c *middleware.Context) <span class="cov0" title="0">{
        cfg, err := getAwsConfig(req)
        if err != nil </span><span class="cov0" title="0">{
                c.JsonApiErr(500, "Unable to call AWS API", err)
                return
        }</span>
        <span class="cov0" title="0">svc := cloudwatch.New(session.New(cfg), cfg)

        reqParam := &amp;struct {
                Parameters struct {
                        AlarmName       string `json:"alarmName"`
                        HistoryItemType string `json:"historyItemType"`
                        StartDate       int64  `json:"startDate"`
                        EndDate         int64  `json:"endDate"`
                } `json:"parameters"`
        }{}
        json.Unmarshal(req.Body, reqParam)

        params := &amp;cloudwatch.DescribeAlarmHistoryInput{
                AlarmName: aws.String(reqParam.Parameters.AlarmName),
                StartDate: aws.Time(time.Unix(reqParam.Parameters.StartDate, 0)),
                EndDate:   aws.Time(time.Unix(reqParam.Parameters.EndDate, 0)),
        }
        if reqParam.Parameters.HistoryItemType != "" </span><span class="cov0" title="0">{
                params.HistoryItemType = aws.String(reqParam.Parameters.HistoryItemType)
        }</span>

        <span class="cov0" title="0">resp, err := svc.DescribeAlarmHistory(params)
        if err != nil </span><span class="cov0" title="0">{
                c.JsonApiErr(500, "Unable to call AWS API", err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(200, resp)</span>
}

func handleDescribeInstances(req *cwRequest, c *middleware.Context) <span class="cov0" title="0">{
        cfg, err := getAwsConfig(req)
        if err != nil </span><span class="cov0" title="0">{
                c.JsonApiErr(500, "Unable to call AWS API", err)
                return
        }</span>
        <span class="cov0" title="0">svc := ec2.New(session.New(cfg), cfg)

        reqParam := &amp;struct {
                Parameters struct {
                        Filters     []*ec2.Filter `json:"filters"`
                        InstanceIds []*string     `json:"instanceIds"`
                } `json:"parameters"`
        }{}
        json.Unmarshal(req.Body, reqParam)

        params := &amp;ec2.DescribeInstancesInput{}
        if len(reqParam.Parameters.Filters) &gt; 0 </span><span class="cov0" title="0">{
                params.Filters = reqParam.Parameters.Filters
        }</span>
        <span class="cov0" title="0">if len(reqParam.Parameters.InstanceIds) &gt; 0 </span><span class="cov0" title="0">{
                params.InstanceIds = reqParam.Parameters.InstanceIds
        }</span>

        <span class="cov0" title="0">var resp ec2.DescribeInstancesOutput
        err = svc.DescribeInstancesPages(params,
                func(page *ec2.DescribeInstancesOutput, lastPage bool) bool </span><span class="cov0" title="0">{
                        reservations, _ := awsutil.ValuesAtPath(page, "Reservations")
                        for _, reservation := range reservations </span><span class="cov0" title="0">{
                                resp.Reservations = append(resp.Reservations, reservation.(*ec2.Reservation))
                        }</span>
                        <span class="cov0" title="0">return !lastPage</span>
                })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                c.JsonApiErr(500, "Unable to call AWS API", err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(200, resp)</span>
}

func HandleRequest(c *middleware.Context, ds *m.DataSource) <span class="cov0" title="0">{
        var req cwRequest
        req.Body, _ = ioutil.ReadAll(c.Req.Request.Body)
        req.DataSource = ds
        json.Unmarshal(req.Body, &amp;req)

        if handler, found := actionHandlers[req.Action]; !found </span><span class="cov0" title="0">{
                c.JsonApiErr(500, "Unexpected AWS Action", errors.New(req.Action))
                return
        }</span><span class="cov0" title="0"> else {
                handler(&amp;req, c)
        }</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package cloudwatch

import (
        "encoding/json"
        "sort"
        "strings"
        "sync"
        "time"

        "github.com/aws/aws-sdk-go/aws"
        "github.com/aws/aws-sdk-go/aws/awsutil"
        "github.com/aws/aws-sdk-go/aws/session"
        "github.com/aws/aws-sdk-go/service/cloudwatch"
        "github.com/grafana/grafana/pkg/metrics"
        "github.com/grafana/grafana/pkg/middleware"
        "github.com/grafana/grafana/pkg/util"
)

var metricsMap map[string][]string
var dimensionsMap map[string][]string

type CustomMetricsCache struct {
        Expire time.Time
        Cache  []string
}

var customMetricsMetricsMap map[string]map[string]map[string]*CustomMetricsCache
var customMetricsDimensionsMap map[string]map[string]map[string]*CustomMetricsCache

func init() <span class="cov8" title="1">{
        metricsMap = map[string][]string{
                "AWS/ApiGateway":     {"4XXError", "5XXError", "CacheHitCount", "CacheMissCount", "Count", "IntegrationLatency", "Latency"},
                "AWS/ApplicationELB": {"ActiveConnectionCount", "ClientTLSNegotiationErrorCount", "HealthyHostCount", "HTTPCode_ELB_4XX_Count", "HTTPCode_ELB_5XX_Count", "HTTPCode_Target_2XX_Count", "HTTPCode_Target_3XX_Count", "HTTPCode_Target_4XX_Count", "HTTPCode_Target_5XX_Count", "NewConnectionCount", "ProcessedBytes", "RejectedConnectionCount", "RequestCount", "TargetConnectionErrorCount", "TargetResponseTime", "TargetTLSNegotiationErrorCount", "UnHealthyHostCount"},
                "AWS/AutoScaling":    {"GroupMinSize", "GroupMaxSize", "GroupDesiredCapacity", "GroupInServiceInstances", "GroupPendingInstances", "GroupStandbyInstances", "GroupTerminatingInstances", "GroupTotalInstances"},
                "AWS/Billing":        {"EstimatedCharges"},
                "AWS/CloudFront":     {"Requests", "BytesDownloaded", "BytesUploaded", "TotalErrorRate", "4xxErrorRate", "5xxErrorRate"},
                "AWS/CloudSearch":    {"SuccessfulRequests", "SearchableDocuments", "IndexUtilization", "Partitions"},
                "AWS/DynamoDB":       {"ConditionalCheckFailedRequests", "ConsumedReadCapacityUnits", "ConsumedWriteCapacityUnits", "OnlineIndexConsumedWriteCapacity", "OnlineIndexPercentageProgress", "OnlineIndexThrottleEvents", "ProvisionedReadCapacityUnits", "ProvisionedWriteCapacityUnits", "ReadThrottleEvents", "ReturnedBytes", "ReturnedItemCount", "ReturnedRecordsCount", "SuccessfulRequestLatency", "SystemErrors", "ThrottledRequests", "UserErrors", "WriteThrottleEvents"},
                "AWS/EBS":            {"VolumeReadBytes", "VolumeWriteBytes", "VolumeReadOps", "VolumeWriteOps", "VolumeTotalReadTime", "VolumeTotalWriteTime", "VolumeIdleTime", "VolumeQueueLength", "VolumeThroughputPercentage", "VolumeConsumedReadWriteOps", "BurstBalance"},
                "AWS/EC2":            {"CPUCreditUsage", "CPUCreditBalance", "CPUUtilization", "DiskReadOps", "DiskWriteOps", "DiskReadBytes", "DiskWriteBytes", "NetworkIn", "NetworkOut", "NetworkPacketsIn", "NetworkPacketsOut", "StatusCheckFailed", "StatusCheckFailed_Instance", "StatusCheckFailed_System"},
                "AWS/EC2Spot":        {"AvailableInstancePoolsCount", "BidsSubmittedForCapacity", "EligibleInstancePoolCount", "FulfilledCapacity", "MaxPercentCapacityAllocation", "PendingCapacity", "PercentCapacityAllocation", "TargetCapacity", "TerminatingCapacity"},
                "AWS/ECS":            {"CPUReservation", "MemoryReservation", "CPUUtilization", "MemoryUtilization"},
                "AWS/EFS":            {"BurstCreditBalance", "ClientConnections", "DataReadIOBytes", "DataWriteIOBytes", "MetadataIOBytes", "TotalIOBytes", "PermittedThroughput", "PercentIOLimit"},
                "AWS/ELB":            {"HealthyHostCount", "UnHealthyHostCount", "RequestCount", "Latency", "HTTPCode_ELB_4XX", "HTTPCode_ELB_5XX", "HTTPCode_Backend_2XX", "HTTPCode_Backend_3XX", "HTTPCode_Backend_4XX", "HTTPCode_Backend_5XX", "BackendConnectionErrors", "SurgeQueueLength", "SpilloverCount"},
                "AWS/ElastiCache": {
                        "CPUUtilization", "FreeableMemory", "NetworkBytesIn", "NetworkBytesOut", "SwapUsage",
                        "BytesUsedForCacheItems", "BytesReadIntoMemcached", "BytesWrittenOutFromMemcached", "CasBadval", "CasHits", "CasMisses", "CmdFlush", "CmdGet", "CmdSet", "CurrConnections", "CurrItems", "DecrHits", "DecrMisses", "DeleteHits", "DeleteMisses", "Evictions", "GetHits", "GetMisses", "IncrHits", "IncrMisses", "Reclaimed",
                        "BytesUsedForHash", "CmdConfigGet", "CmdConfigSet", "CmdTouch", "CurrConfig", "EvictedUnfetched", "ExpiredUnfetched", "SlabsMoved", "TouchHits", "TouchMisses",
                        "NewConnections", "NewItems", "UnusedMemory",
                        "BytesUsedForCache", "CacheHits", "CacheMisses", "CurrConnections", "Evictions", "HyperLogLogBasedCmds", "NewConnections", "Reclaimed", "ReplicationBytes", "ReplicationLag", "SaveInProgress",
                        "CurrItems", "GetTypeCmds", "HashBasedCmds", "KeyBasedCmds", "ListBasedCmds", "SetBasedCmds", "SetTypeCmds", "SortedSetBasedCmds", "StringBasedCmds",
                },
                "AWS/ElasticBeanstalk": {
                        "EnvironmentHealth",
                        "ApplicationLatencyP10", "ApplicationLatencyP50", "ApplicationLatencyP75", "ApplicationLatencyP85", "ApplicationLatencyP90", "ApplicationLatencyP95", "ApplicationLatencyP99", "ApplicationLatencyP99.9",
                        "ApplicationRequests2xx", "ApplicationRequests3xx", "ApplicationRequests4xx", "ApplicationRequests5xx", "ApplicationRequestsTotal",
                        "CPUIdle", "CPUIowait", "CPUIrq", "CPUNice", "CPUSoftirq", "CPUSystem", "CPUUser",
                        "InstanceHealth", "InstancesDegraded", "InstancesInfo", "InstancesNoData", "InstancesOk", "InstancesPending", "InstancesSevere", "InstancesUnknown", "InstancesWarning",
                        "LoadAverage1min", "LoadAverage5min",
                        "RootFilesystemUtil",
                },
                "AWS/ElasticMapReduce": {"IsIdle", "JobsRunning", "JobsFailed",
                        "MapTasksRunning", "MapTasksRemaining", "MapSlotsOpen", "RemainingMapTasksPerSlot", "ReduceTasksRunning", "ReduceTasksRemaining", "ReduceSlotsOpen",
                        "CoreNodesRunning", "CoreNodesPending", "LiveDataNodes", "TaskNodesRunning", "TaskNodesPending", "LiveTaskTrackers",
                        "S3BytesWritten", "S3BytesRead", "HDFSUtilization", "HDFSBytesRead", "HDFSBytesWritten", "MissingBlocks", "TotalLoad",
                        "BackupFailed", "MostRecentBackupDuration", "TimeSinceLastSuccessfulBackup",
                        "IsIdle", "ContainerAllocated", "ContainerReserved", "ContainerPending", "AppsCompleted", "AppsFailed", "AppsKilled", "AppsPending", "AppsRunning", "AppsSubmitted",
                        "CoreNodesRunning", "CoreNodesPending", "LiveDataNodes", "MRTotalNodes", "MRActiveNodes", "MRLostNodes", "MRUnhealthyNodes", "MRDecommissionedNodes", "MRRebootedNodes",
                        "S3BytesWritten", "S3BytesRead", "HDFSUtilization", "HDFSBytesRead", "HDFSBytesWritten", "MissingBlocks", "CorruptBlocks", "TotalLoad", "MemoryTotalMB", "MemoryReservedMB", "MemoryAvailableMB", "MemoryAllocatedMB", "PendingDeletionBlocks", "UnderReplicatedBlocks", "DfsPendingReplicationBlocks", "CapacityRemainingGB",
                        "HbaseBackupFailed", "MostRecentBackupDuration", "TimeSinceLastSuccessfulBackup"},
                "AWS/ES":               {"ClusterStatus.green", "ClusterStatus.yellow", "ClusterStatus.red", "Nodes", "SearchableDocuments", "DeletedDocuments", "CPUUtilization", "FreeStorageSpace", "JVMMemoryPressure", "AutomatedSnapshotFailure", "MasterCPUUtilization", "MasterFreeStorageSpace", "MasterJVMMemoryPressure", "ReadLatency", "WriteLatency", "ReadThroughput", "WriteThroughput", "DiskQueueLength", "ReadIOPS", "WriteIOPS"},
                "AWS/Events":           {"Invocations", "FailedInvocations", "TriggeredRules", "MatchedEvents", "ThrottledRules"},
                "AWS/Firehose":         {"DeliveryToElasticsearch.Bytes", "DeliveryToElasticsearch.Records", "DeliveryToElasticsearch.Success", "DeliveryToRedshift.Bytes", "DeliveryToRedshift.Records", "DeliveryToRedshift.Success", "DeliveryToS3.Bytes", "DeliveryToS3.DataFreshness", "DeliveryToS3.Records", "DeliveryToS3.Success", "IncomingBytes", "IncomingRecords", "DescribeDeliveryStream.Latency", "DescribeDeliveryStream.Requests", "ListDeliveryStreams.Latency", "ListDeliveryStreams.Requests", "PutRecord.Bytes", "PutRecord.Latency", "PutRecord.Requests", "PutRecordBatch.Bytes", "PutRecordBatch.Latency", "PutRecordBatch.Records", "PutRecordBatch.Requests", "UpdateDeliveryStream.Latency", "UpdateDeliveryStream.Requests"},
                "AWS/IoT":              {"PublishIn.Success", "PublishOut.Success", "Subscribe.Success", "Ping.Success", "Connect.Success", "GetThingShadow.Accepted"},
                "AWS/Kinesis":          {"GetRecords.Bytes", "GetRecords.IteratorAge", "GetRecords.IteratorAgeMilliseconds", "GetRecords.Latency", "GetRecords.Records", "GetRecords.Success", "IncomingBytes", "IncomingRecords", "PutRecord.Bytes", "PutRecord.Latency", "PutRecord.Success", "PutRecords.Bytes", "PutRecords.Latency", "PutRecords.Records", "PutRecords.Success", "ReadProvisionedThroughputExceeded", "WriteProvisionedThroughputExceeded", "IteratorAgeMilliseconds", "OutgoingBytes", "OutgoingRecords"},
                "AWS/KinesisAnalytics": {"Bytes", "MillisBehindLatest", "Records", "Success"},
                "AWS/Lambda":           {"Invocations", "Errors", "Duration", "Throttles"},
                "AWS/Logs":             {"IncomingBytes", "IncomingLogEvents", "ForwardedBytes", "ForwardedLogEvents", "DeliveryErrors", "DeliveryThrottling"},
                "AWS/ML":               {"PredictCount", "PredictFailureCount"},
                "AWS/OpsWorks":         {"cpu_idle", "cpu_nice", "cpu_system", "cpu_user", "cpu_waitio", "load_1", "load_5", "load_15", "memory_buffers", "memory_cached", "memory_free", "memory_swap", "memory_total", "memory_used", "procs"},
                "AWS/Redshift":         {"CPUUtilization", "DatabaseConnections", "HealthStatus", "MaintenanceMode", "NetworkReceiveThroughput", "NetworkTransmitThroughput", "PercentageDiskSpaceUsed", "ReadIOPS", "ReadLatency", "ReadThroughput", "WriteIOPS", "WriteLatency", "WriteThroughput"},
                "AWS/RDS":              {"ActiveTransactions", "AuroraBinlogReplicaLag", "AuroraReplicaLag", "AuroraReplicaLagMaximum", "AuroraReplicaLagMinimum", "BinLogDiskUsage", "BlockedTransactions", "BufferCacheHitRatio", "CommitLatency", "CommitThroughput", "CPUCreditBalance", "CPUCreditUsage", "CPUUtilization", "DatabaseConnections", "DDLLatency", "DDLThroughput", "Deadlocks", "DiskQueueDepth", "DMLLatency", "DMLThroughput", "FailedSqlStatements", "FreeableMemory", "FreeStorageSpace", "LoginFailures", "NetworkReceiveThroughput", "NetworkTransmitThroughput", "ReadIOPS", "ReadLatency", "ReadThroughput", "ReplicaLag", "ResultSetCacheHitRatio", "SelectLatency", "SelectThroughput", "SwapUsage", "TotalConnections", "VolumeReadIOPS", "VolumeWriteIOPS", "WriteIOPS", "WriteLatency", "WriteThroughput"},
                "AWS/Route53":          {"HealthCheckStatus", "HealthCheckPercentageHealthy", "ConnectionTime", "SSLHandshakeTime", "TimeToFirstByte"},
                "AWS/S3":               {"BucketSizeBytes", "NumberOfObjects"},
                "AWS/SES":              {"Bounce", "Complaint", "Delivery", "Reject", "Send"},
                "AWS/SNS":              {"NumberOfMessagesPublished", "PublishSize", "NumberOfNotificationsDelivered", "NumberOfNotificationsFailed"},
                "AWS/SQS":              {"NumberOfMessagesSent", "SentMessageSize", "NumberOfMessagesReceived", "NumberOfEmptyReceives", "NumberOfMessagesDeleted", "ApproximateNumberOfMessagesDelayed", "ApproximateNumberOfMessagesVisible", "ApproximateNumberOfMessagesNotVisible"},
                "AWS/StorageGateway": {"CacheHitPercent", "CachePercentUsed", "CachePercentDirty", "CloudBytesDownloaded", "CloudDownloadLatency", "CloudBytesUploaded", "UploadBufferFree", "UploadBufferPercentUsed", "UploadBufferUsed", "QueuedWrites", "ReadBytes", "ReadTime", "TotalCacheSize", "WriteBytes", "WriteTime", "TimeSinceLastRecoveryPoint", "WorkingStorageFree", "WorkingStoragePercentUsed", "WorkingStorageUsed",
                        "CacheHitPercent", "CachePercentUsed", "CachePercentDirty", "ReadBytes", "ReadTime", "WriteBytes", "WriteTime", "QueuedWrites"},
                "AWS/SWF": {"DecisionTaskScheduleToStartTime", "DecisionTaskStartToCloseTime", "DecisionTasksCompleted", "StartedDecisionTasksTimedOutOnClose", "WorkflowStartToCloseTime", "WorkflowsCanceled", "WorkflowsCompleted", "WorkflowsContinuedAsNew", "WorkflowsFailed", "WorkflowsTerminated", "WorkflowsTimedOut",
                        "ActivityTaskScheduleToCloseTime", "ActivityTaskScheduleToStartTime", "ActivityTaskStartToCloseTime", "ActivityTasksCanceled", "ActivityTasksCompleted", "ActivityTasksFailed", "ScheduledActivityTasksTimedOutOnClose", "ScheduledActivityTasksTimedOutOnStart", "StartedActivityTasksTimedOutOnClose", "StartedActivityTasksTimedOutOnHeartbeat"},
                "AWS/WAF":        {"AllowedRequests", "BlockedRequests", "CountedRequests"},
                "AWS/WorkSpaces": {"Available", "Unhealthy", "ConnectionAttempt", "ConnectionSuccess", "ConnectionFailure", "SessionLaunchTime", "InSessionLatency", "SessionDisconnect"},
                "KMS":            {"SecondsUntilKeyMaterialExpiration"},
        }
        dimensionsMap = map[string][]string{
                "AWS/ApiGateway":       {"ApiName", "Method", "Resource", "Stage"},
                "AWS/ApplicationELB":   {"LoadBalancer", "TargetGroup", "AvailabilityZone"},
                "AWS/AutoScaling":      {"AutoScalingGroupName"},
                "AWS/Billing":          {"ServiceName", "LinkedAccount", "Currency"},
                "AWS/CloudFront":       {"DistributionId", "Region"},
                "AWS/CloudSearch":      {},
                "AWS/DynamoDB":         {"TableName", "GlobalSecondaryIndexName", "Operation", "StreamLabel"},
                "AWS/EBS":              {"VolumeId"},
                "AWS/EC2":              {"AutoScalingGroupName", "ImageId", "InstanceId", "InstanceType"},
                "AWS/EC2Spot":          {"AvailabilityZone", "FleetRequestId", "InstanceType"},
                "AWS/ECS":              {"ClusterName", "ServiceName"},
                "AWS/EFS":              {"FileSystemId"},
                "AWS/ELB":              {"LoadBalancerName", "AvailabilityZone"},
                "AWS/ElastiCache":      {"CacheClusterId", "CacheNodeId"},
                "AWS/ElasticBeanstalk": {"EnvironmentName", "InstanceId"},
                "AWS/ElasticMapReduce": {"ClusterId", "JobFlowId", "JobId"},
                "AWS/ES":               {"ClientId", "DomainName"},
                "AWS/Events":           {"RuleName"},
                "AWS/Firehose":         {"DeliveryStreamName"},
                "AWS/IoT":              {"Protocol"},
                "AWS/Kinesis":          {"StreamName", "ShardID"},
                "AWS/KinesisAnalytics": {"Flow", "Id", "Application"},
                "AWS/Lambda":           {"FunctionName", "Resource", "Version", "Alias"},
                "AWS/Logs":             {"LogGroupName", "DestinationType", "FilterName"},
                "AWS/ML":               {"MLModelId", "RequestMode"},
                "AWS/OpsWorks":         {"StackId", "LayerId", "InstanceId"},
                "AWS/Redshift":         {"NodeID", "ClusterIdentifier"},
                "AWS/RDS":              {"DBInstanceIdentifier", "DBClusterIdentifier", "DatabaseClass", "EngineName"},
                "AWS/Route53":          {"HealthCheckId"},
                "AWS/S3":               {"BucketName", "StorageType"},
                "AWS/SES":              {},
                "AWS/SNS":              {"Application", "Platform", "TopicName"},
                "AWS/SQS":              {"QueueName"},
                "AWS/StorageGateway":   {"GatewayId", "GatewayName", "VolumeId"},
                "AWS/SWF":              {"Domain", "WorkflowTypeName", "WorkflowTypeVersion", "ActivityTypeName", "ActivityTypeVersion"},
                "AWS/WAF":              {"Rule", "WebACL"},
                "AWS/WorkSpaces":       {"DirectoryId", "WorkspaceId"},
                "KMS":                  {"KeyId"},
        }

        customMetricsMetricsMap = make(map[string]map[string]map[string]*CustomMetricsCache)
        customMetricsDimensionsMap = make(map[string]map[string]map[string]*CustomMetricsCache)
}</span>

// Whenever this list is updated, frontend list should also be updated.
// Please update the region list in public/app/plugins/datasource/cloudwatch/partials/config.html
func handleGetRegions(req *cwRequest, c *middleware.Context) <span class="cov0" title="0">{
        regions := []string{
                "ap-northeast-1", "ap-northeast-2", "ap-southeast-1", "ap-southeast-2", "ap-south-1", "ca-central-1", "cn-north-1",
                "eu-central-1", "eu-west-1", "eu-west-2", "sa-east-1", "us-east-1", "us-east-2", "us-gov-west-1", "us-west-1", "us-west-2",
        }

        result := []interface{}{}
        for _, region := range regions </span><span class="cov0" title="0">{
                result = append(result, util.DynMap{"text": region, "value": region})
        }</span>

        <span class="cov0" title="0">c.JSON(200, result)</span>
}

func handleGetNamespaces(req *cwRequest, c *middleware.Context) <span class="cov0" title="0">{
        keys := []string{}
        for key := range metricsMap </span><span class="cov0" title="0">{
                keys = append(keys, key)
        }</span>

        <span class="cov0" title="0">customNamespaces := req.DataSource.JsonData.Get("customMetricsNamespaces").MustString()
        if customNamespaces != "" </span><span class="cov0" title="0">{
                for _, key := range strings.Split(customNamespaces, ",") </span><span class="cov0" title="0">{
                        keys = append(keys, key)
                }</span>
        }

        <span class="cov0" title="0">sort.Sort(sort.StringSlice(keys))

        result := []interface{}{}
        for _, key := range keys </span><span class="cov0" title="0">{
                result = append(result, util.DynMap{"text": key, "value": key})
        }</span>

        <span class="cov0" title="0">c.JSON(200, result)</span>
}

func handleGetMetrics(req *cwRequest, c *middleware.Context) <span class="cov0" title="0">{
        reqParam := &amp;struct {
                Parameters struct {
                        Namespace string `json:"namespace"`
                } `json:"parameters"`
        }{}

        json.Unmarshal(req.Body, reqParam)

        var namespaceMetrics []string
        if !isCustomMetrics(reqParam.Parameters.Namespace) </span><span class="cov0" title="0">{
                var exists bool
                if namespaceMetrics, exists = metricsMap[reqParam.Parameters.Namespace]; !exists </span><span class="cov0" title="0">{
                        c.JsonApiErr(404, "Unable to find namespace "+reqParam.Parameters.Namespace, nil)
                        return
                }</span>
        }<span class="cov0" title="0"> else {
                var err error
                cwData := req.GetDatasourceInfo()
                cwData.Namespace = reqParam.Parameters.Namespace

                if namespaceMetrics, err = getMetricsForCustomMetrics(cwData, getAllMetrics); err != nil </span><span class="cov0" title="0">{
                        c.JsonApiErr(500, "Unable to call AWS API", err)
                        return
                }</span>
        }
        <span class="cov0" title="0">sort.Sort(sort.StringSlice(namespaceMetrics))

        result := []interface{}{}
        for _, name := range namespaceMetrics </span><span class="cov0" title="0">{
                result = append(result, util.DynMap{"text": name, "value": name})
        }</span>

        <span class="cov0" title="0">c.JSON(200, result)</span>
}

func handleGetDimensions(req *cwRequest, c *middleware.Context) <span class="cov0" title="0">{
        reqParam := &amp;struct {
                Parameters struct {
                        Namespace string `json:"namespace"`
                } `json:"parameters"`
        }{}

        json.Unmarshal(req.Body, reqParam)

        var dimensionValues []string
        if !isCustomMetrics(reqParam.Parameters.Namespace) </span><span class="cov0" title="0">{
                var exists bool
                if dimensionValues, exists = dimensionsMap[reqParam.Parameters.Namespace]; !exists </span><span class="cov0" title="0">{
                        c.JsonApiErr(404, "Unable to find dimension "+reqParam.Parameters.Namespace, nil)
                        return
                }</span>
        }<span class="cov0" title="0"> else {
                var err error
                dsInfo := req.GetDatasourceInfo()
                dsInfo.Namespace = reqParam.Parameters.Namespace

                if dimensionValues, err = getDimensionsForCustomMetrics(dsInfo, getAllMetrics); err != nil </span><span class="cov0" title="0">{
                        c.JsonApiErr(500, "Unable to call AWS API", err)
                        return
                }</span>
        }
        <span class="cov0" title="0">sort.Sort(sort.StringSlice(dimensionValues))

        result := []interface{}{}
        for _, name := range dimensionValues </span><span class="cov0" title="0">{
                result = append(result, util.DynMap{"text": name, "value": name})
        }</span>

        <span class="cov0" title="0">c.JSON(200, result)</span>
}

func getAllMetrics(cwData *datasourceInfo) (cloudwatch.ListMetricsOutput, error) <span class="cov0" title="0">{
        creds, err := getCredentials(cwData)
        if err != nil </span><span class="cov0" title="0">{
                return cloudwatch.ListMetricsOutput{}, err
        }</span>
        <span class="cov0" title="0">cfg := &amp;aws.Config{
                Region:      aws.String(cwData.Region),
                Credentials: creds,
        }

        svc := cloudwatch.New(session.New(cfg), cfg)

        params := &amp;cloudwatch.ListMetricsInput{
                Namespace: aws.String(cwData.Namespace),
        }

        var resp cloudwatch.ListMetricsOutput
        err = svc.ListMetricsPages(params,
                func(page *cloudwatch.ListMetricsOutput, lastPage bool) bool </span><span class="cov0" title="0">{
                        metrics.M_Aws_CloudWatch_ListMetrics.Inc(1)
                        metrics, _ := awsutil.ValuesAtPath(page, "Metrics")
                        for _, metric := range metrics </span><span class="cov0" title="0">{
                                resp.Metrics = append(resp.Metrics, metric.(*cloudwatch.Metric))
                        }</span>
                        <span class="cov0" title="0">return !lastPage</span>
                })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return resp, err
        }</span>

        <span class="cov0" title="0">return resp, nil</span>
}

var metricsCacheLock sync.Mutex

func getMetricsForCustomMetrics(dsInfo *datasourceInfo, getAllMetrics func(*datasourceInfo) (cloudwatch.ListMetricsOutput, error)) ([]string, error) <span class="cov8" title="1">{
        result, err := getAllMetrics(dsInfo)
        if err != nil </span><span class="cov0" title="0">{
                return []string{}, err
        }</span>

        <span class="cov8" title="1">metricsCacheLock.Lock()
        defer metricsCacheLock.Unlock()

        if _, ok := customMetricsMetricsMap[dsInfo.Profile]; !ok </span><span class="cov8" title="1">{
                customMetricsMetricsMap[dsInfo.Profile] = make(map[string]map[string]*CustomMetricsCache)
        }</span>
        <span class="cov8" title="1">if _, ok := customMetricsMetricsMap[dsInfo.Profile][dsInfo.Region]; !ok </span><span class="cov8" title="1">{
                customMetricsMetricsMap[dsInfo.Profile][dsInfo.Region] = make(map[string]*CustomMetricsCache)
        }</span>
        <span class="cov8" title="1">if _, ok := customMetricsMetricsMap[dsInfo.Profile][dsInfo.Region][dsInfo.Namespace]; !ok </span><span class="cov8" title="1">{
                customMetricsMetricsMap[dsInfo.Profile][dsInfo.Region][dsInfo.Namespace] = &amp;CustomMetricsCache{}
                customMetricsMetricsMap[dsInfo.Profile][dsInfo.Region][dsInfo.Namespace].Cache = make([]string, 0)
        }</span>

        <span class="cov8" title="1">if customMetricsMetricsMap[dsInfo.Profile][dsInfo.Region][dsInfo.Namespace].Expire.After(time.Now()) </span><span class="cov0" title="0">{
                return customMetricsMetricsMap[dsInfo.Profile][dsInfo.Region][dsInfo.Namespace].Cache, nil
        }</span>
        <span class="cov8" title="1">customMetricsMetricsMap[dsInfo.Profile][dsInfo.Region][dsInfo.Namespace].Cache = make([]string, 0)
        customMetricsMetricsMap[dsInfo.Profile][dsInfo.Region][dsInfo.Namespace].Expire = time.Now().Add(5 * time.Minute)

        for _, metric := range result.Metrics </span><span class="cov8" title="1">{
                if isDuplicate(customMetricsMetricsMap[dsInfo.Profile][dsInfo.Region][dsInfo.Namespace].Cache, *metric.MetricName) </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">customMetricsMetricsMap[dsInfo.Profile][dsInfo.Region][dsInfo.Namespace].Cache = append(customMetricsMetricsMap[dsInfo.Profile][dsInfo.Region][dsInfo.Namespace].Cache, *metric.MetricName)</span>
        }

        <span class="cov8" title="1">return customMetricsMetricsMap[dsInfo.Profile][dsInfo.Region][dsInfo.Namespace].Cache, nil</span>
}

var dimensionsCacheLock sync.Mutex

func getDimensionsForCustomMetrics(dsInfo *datasourceInfo, getAllMetrics func(*datasourceInfo) (cloudwatch.ListMetricsOutput, error)) ([]string, error) <span class="cov8" title="1">{
        result, err := getAllMetrics(dsInfo)
        if err != nil </span><span class="cov0" title="0">{
                return []string{}, err
        }</span>

        <span class="cov8" title="1">dimensionsCacheLock.Lock()
        defer dimensionsCacheLock.Unlock()

        if _, ok := customMetricsDimensionsMap[dsInfo.Profile]; !ok </span><span class="cov8" title="1">{
                customMetricsDimensionsMap[dsInfo.Profile] = make(map[string]map[string]*CustomMetricsCache)
        }</span>
        <span class="cov8" title="1">if _, ok := customMetricsDimensionsMap[dsInfo.Profile][dsInfo.Region]; !ok </span><span class="cov8" title="1">{
                customMetricsDimensionsMap[dsInfo.Profile][dsInfo.Region] = make(map[string]*CustomMetricsCache)
        }</span>
        <span class="cov8" title="1">if _, ok := customMetricsDimensionsMap[dsInfo.Profile][dsInfo.Region][dsInfo.Namespace]; !ok </span><span class="cov8" title="1">{
                customMetricsDimensionsMap[dsInfo.Profile][dsInfo.Region][dsInfo.Namespace] = &amp;CustomMetricsCache{}
                customMetricsDimensionsMap[dsInfo.Profile][dsInfo.Region][dsInfo.Namespace].Cache = make([]string, 0)
        }</span>

        <span class="cov8" title="1">if customMetricsDimensionsMap[dsInfo.Profile][dsInfo.Region][dsInfo.Namespace].Expire.After(time.Now()) </span><span class="cov0" title="0">{
                return customMetricsDimensionsMap[dsInfo.Profile][dsInfo.Region][dsInfo.Namespace].Cache, nil
        }</span>
        <span class="cov8" title="1">customMetricsDimensionsMap[dsInfo.Profile][dsInfo.Region][dsInfo.Namespace].Cache = make([]string, 0)
        customMetricsDimensionsMap[dsInfo.Profile][dsInfo.Region][dsInfo.Namespace].Expire = time.Now().Add(5 * time.Minute)

        for _, metric := range result.Metrics </span><span class="cov8" title="1">{
                for _, dimension := range metric.Dimensions </span><span class="cov8" title="1">{
                        if isDuplicate(customMetricsDimensionsMap[dsInfo.Profile][dsInfo.Region][dsInfo.Namespace].Cache, *dimension.Name) </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">customMetricsDimensionsMap[dsInfo.Profile][dsInfo.Region][dsInfo.Namespace].Cache = append(customMetricsDimensionsMap[dsInfo.Profile][dsInfo.Region][dsInfo.Namespace].Cache, *dimension.Name)</span>
                }
        }

        <span class="cov8" title="1">return customMetricsDimensionsMap[dsInfo.Profile][dsInfo.Region][dsInfo.Namespace].Cache, nil</span>
}

func isDuplicate(nameList []string, target string) bool <span class="cov8" title="1">{
        for _, name := range nameList </span><span class="cov0" title="0">{
                if name == target </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func isCustomMetrics(namespace string) bool <span class="cov0" title="0">{
        return strings.Index(namespace, "AWS/") != 0
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package api

import (
        "encoding/json"
        "net/http"

        "github.com/grafana/grafana/pkg/middleware"
        "github.com/grafana/grafana/pkg/setting"
        "gopkg.in/macaron.v1"
)

var (
        NotFound = func() Response <span class="cov0" title="0">{
                return ApiError(404, "Not found", nil)
        }</span>
        ServerError = func(err error) Response <span class="cov0" title="0">{
                return ApiError(500, "Server error", err)
        }</span>
)

type Response interface {
        WriteTo(ctx *middleware.Context)
}

type NormalResponse struct {
        status     int
        body       []byte
        header     http.Header
        errMessage string
        err        error
}

func wrap(action interface{}) macaron.Handler <span class="cov8" title="1">{

        return func(c *middleware.Context) </span><span class="cov8" title="1">{
                var res Response
                val, err := c.Invoke(action)
                if err == nil &amp;&amp; val != nil &amp;&amp; len(val) &gt; 0 </span><span class="cov8" title="1">{
                        res = val[0].Interface().(Response)
                }</span><span class="cov0" title="0"> else {
                        res = ServerError(err)
                }</span>

                <span class="cov8" title="1">res.WriteTo(c)</span>
        }
}

func (r *NormalResponse) WriteTo(ctx *middleware.Context) <span class="cov8" title="1">{
        if r.err != nil </span><span class="cov0" title="0">{
                ctx.Logger.Error(r.errMessage, "error", r.err)
        }</span>

        <span class="cov8" title="1">header := ctx.Resp.Header()
        for k, v := range r.header </span><span class="cov8" title="1">{
                header[k] = v
        }</span>
        <span class="cov8" title="1">ctx.Resp.WriteHeader(r.status)
        ctx.Resp.Write(r.body)</span>
}

func (r *NormalResponse) Cache(ttl string) *NormalResponse <span class="cov0" title="0">{
        return r.Header("Cache-Control", "public,max-age="+ttl)
}</span>

func (r *NormalResponse) Header(key, value string) *NormalResponse <span class="cov8" title="1">{
        r.header.Set(key, value)
        return r
}</span>

// functions to create responses
func Empty(status int) *NormalResponse <span class="cov0" title="0">{
        return Respond(status, nil)
}</span>

func Json(status int, body interface{}) *NormalResponse <span class="cov8" title="1">{
        return Respond(status, body).Header("Content-Type", "application/json")
}</span>

func ApiSuccess(message string) *NormalResponse <span class="cov0" title="0">{
        resp := make(map[string]interface{})
        resp["message"] = message
        return Json(200, resp)
}</span>

func ApiError(status int, message string, err error) *NormalResponse <span class="cov0" title="0">{
        data := make(map[string]interface{})

        switch status </span>{
        case 404:<span class="cov0" title="0">
                data["message"] = "Not Found"</span>
        case 500:<span class="cov0" title="0">
                data["message"] = "Internal Server Error"</span>
        }

        <span class="cov0" title="0">if message != "" </span><span class="cov0" title="0">{
                data["message"] = message
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                if setting.Env != setting.PROD </span><span class="cov0" title="0">{
                        data["error"] = err.Error()
                }</span>
        }

        <span class="cov0" title="0">resp := Json(status, data)

        if err != nil </span><span class="cov0" title="0">{
                resp.errMessage = message
                resp.err = err
        }</span>

        <span class="cov0" title="0">return resp</span>
}

func Respond(status int, body interface{}) *NormalResponse <span class="cov8" title="1">{
        var b []byte
        var err error
        switch t := body.(type) </span>{
        case []byte:<span class="cov0" title="0">
                b = t</span>
        case string:<span class="cov0" title="0">
                b = []byte(t)</span>
        default:<span class="cov8" title="1">
                if b, err = json.Marshal(body); err != nil </span><span class="cov0" title="0">{
                        return ApiError(500, "body json marshal", err)
                }</span>
        }
        <span class="cov8" title="1">return &amp;NormalResponse{
                body:   b,
                status: status,
                header: make(http.Header),
        }</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package api

import (
        "encoding/json"
        "os"
        "path"
        "strings"

        "github.com/grafana/grafana/pkg/api/dtos"
        "github.com/grafana/grafana/pkg/bus"
        "github.com/grafana/grafana/pkg/components/simplejson"
        "github.com/grafana/grafana/pkg/log"
        "github.com/grafana/grafana/pkg/metrics"
        "github.com/grafana/grafana/pkg/middleware"
        m "github.com/grafana/grafana/pkg/models"
        "github.com/grafana/grafana/pkg/plugins"
        "github.com/grafana/grafana/pkg/services/alerting"
        "github.com/grafana/grafana/pkg/services/search"
        "github.com/grafana/grafana/pkg/setting"
        "github.com/grafana/grafana/pkg/util"
)

func isDashboardStarredByUser(c *middleware.Context, dashId int64) (bool, error) <span class="cov0" title="0">{
        if !c.IsSignedIn </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        <span class="cov0" title="0">query := m.IsStarredByUserQuery{UserId: c.UserId, DashboardId: dashId}
        if err := bus.Dispatch(&amp;query); err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">return query.Result, nil</span>
}

func GetDashboard(c *middleware.Context) <span class="cov0" title="0">{
        slug := strings.ToLower(c.Params(":slug"))

        query := m.GetDashboardQuery{Slug: slug, OrgId: c.OrgId}
        err := bus.Dispatch(&amp;query)
        if err != nil </span><span class="cov0" title="0">{
                c.JsonApiErr(404, "Dashboard not found", nil)
                return
        }</span>

        <span class="cov0" title="0">isStarred, err := isDashboardStarredByUser(c, query.Result.Id)
        if err != nil </span><span class="cov0" title="0">{
                c.JsonApiErr(500, "Error while checking if dashboard was starred by user", err)
                return
        }</span>

        <span class="cov0" title="0">dash := query.Result

        // Finding creator and last updater of the dashboard
        updater, creator := "Anonymous", "Anonymous"
        if dash.UpdatedBy &gt; 0 </span><span class="cov0" title="0">{
                updater = getUserLogin(dash.UpdatedBy)
        }</span>
        <span class="cov0" title="0">if dash.CreatedBy &gt; 0 </span><span class="cov0" title="0">{
                creator = getUserLogin(dash.CreatedBy)
        }</span>

        <span class="cov0" title="0">dto := dtos.DashboardFullWithMeta{
                Dashboard: dash.Data,
                Meta: dtos.DashboardMeta{
                        IsStarred: isStarred,
                        Slug:      slug,
                        Type:      m.DashTypeDB,
                        CanStar:   c.IsSignedIn,
                        CanSave:   c.OrgRole == m.ROLE_ADMIN || c.OrgRole == m.ROLE_EDITOR,
                        CanEdit:   canEditDashboard(c.OrgRole),
                        Created:   dash.Created,
                        Updated:   dash.Updated,
                        UpdatedBy: updater,
                        CreatedBy: creator,
                        Version:   dash.Version,
                },
        }

        c.TimeRequest(metrics.M_Api_Dashboard_Get)
        c.JSON(200, dto)</span>
}

func getUserLogin(userId int64) string <span class="cov0" title="0">{
        query := m.GetUserByIdQuery{Id: userId}
        err := bus.Dispatch(&amp;query)
        if err != nil </span><span class="cov0" title="0">{
                return "Anonymous"
        }</span><span class="cov0" title="0"> else {
                user := query.Result
                return user.Login
        }</span>
}

func DeleteDashboard(c *middleware.Context) <span class="cov0" title="0">{
        slug := c.Params(":slug")

        query := m.GetDashboardQuery{Slug: slug, OrgId: c.OrgId}
        if err := bus.Dispatch(&amp;query); err != nil </span><span class="cov0" title="0">{
                c.JsonApiErr(404, "Dashboard not found", nil)
                return
        }</span>

        <span class="cov0" title="0">cmd := m.DeleteDashboardCommand{Slug: slug, OrgId: c.OrgId}
        if err := bus.Dispatch(&amp;cmd); err != nil </span><span class="cov0" title="0">{
                c.JsonApiErr(500, "Failed to delete dashboard", err)
                return
        }</span>

        <span class="cov0" title="0">var resp = map[string]interface{}{"title": query.Result.Title}

        c.JSON(200, resp)</span>
}

func PostDashboard(c *middleware.Context, cmd m.SaveDashboardCommand) Response <span class="cov0" title="0">{
        cmd.OrgId = c.OrgId

        if !c.IsSignedIn </span><span class="cov0" title="0">{
                cmd.UserId = -1
        }</span><span class="cov0" title="0"> else {
                cmd.UserId = c.UserId
        }</span>

        <span class="cov0" title="0">dash := cmd.GetDashboardModel()
        // Check if Title is empty
        if dash.Title == "" </span><span class="cov0" title="0">{
                return ApiError(400, m.ErrDashboardTitleEmpty.Error(), nil)
        }</span>
        <span class="cov0" title="0">if dash.Id == 0 </span><span class="cov0" title="0">{
                limitReached, err := middleware.QuotaReached(c, "dashboard")
                if err != nil </span><span class="cov0" title="0">{
                        return ApiError(500, "failed to get quota", err)
                }</span>
                <span class="cov0" title="0">if limitReached </span><span class="cov0" title="0">{
                        return ApiError(403, "Quota reached", nil)
                }</span>
        }

        <span class="cov0" title="0">validateAlertsCmd := alerting.ValidateDashboardAlertsCommand{
                OrgId:     c.OrgId,
                UserId:    c.UserId,
                Dashboard: dash,
        }

        if err := bus.Dispatch(&amp;validateAlertsCmd); err != nil </span><span class="cov0" title="0">{
                return ApiError(500, "Invalid alert data. Cannot save dashboard", err)
        }</span>

        <span class="cov0" title="0">err := bus.Dispatch(&amp;cmd)
        if err != nil </span><span class="cov0" title="0">{
                if err == m.ErrDashboardWithSameNameExists </span><span class="cov0" title="0">{
                        return Json(412, util.DynMap{"status": "name-exists", "message": err.Error()})
                }</span>
                <span class="cov0" title="0">if err == m.ErrDashboardVersionMismatch </span><span class="cov0" title="0">{
                        return Json(412, util.DynMap{"status": "version-mismatch", "message": err.Error()})
                }</span>
                <span class="cov0" title="0">if pluginErr, ok := err.(m.UpdatePluginDashboardError); ok </span><span class="cov0" title="0">{
                        message := "The dashboard belongs to plugin " + pluginErr.PluginId + "."
                        // look up plugin name
                        if pluginDef, exist := plugins.Plugins[pluginErr.PluginId]; exist </span><span class="cov0" title="0">{
                                message = "The dashboard belongs to plugin " + pluginDef.Name + "."
                        }</span>
                        <span class="cov0" title="0">return Json(412, util.DynMap{"status": "plugin-dashboard", "message": message})</span>
                }
                <span class="cov0" title="0">if err == m.ErrDashboardNotFound </span><span class="cov0" title="0">{
                        return Json(404, util.DynMap{"status": "not-found", "message": err.Error()})
                }</span>
                <span class="cov0" title="0">return ApiError(500, "Failed to save dashboard", err)</span>
        }

        <span class="cov0" title="0">alertCmd := alerting.UpdateDashboardAlertsCommand{
                OrgId:     c.OrgId,
                UserId:    c.UserId,
                Dashboard: cmd.Result,
        }

        if err := bus.Dispatch(&amp;alertCmd); err != nil </span><span class="cov0" title="0">{
                return ApiError(500, "Failed to save alerts", err)
        }</span>

        <span class="cov0" title="0">c.TimeRequest(metrics.M_Api_Dashboard_Save)
        return Json(200, util.DynMap{"status": "success", "slug": cmd.Result.Slug, "version": cmd.Result.Version})</span>
}

func canEditDashboard(role m.RoleType) bool <span class="cov0" title="0">{
        return role == m.ROLE_ADMIN || role == m.ROLE_EDITOR || role == m.ROLE_READ_ONLY_EDITOR
}</span>

func GetHomeDashboard(c *middleware.Context) Response <span class="cov0" title="0">{
        prefsQuery := m.GetPreferencesWithDefaultsQuery{OrgId: c.OrgId, UserId: c.UserId}
        if err := bus.Dispatch(&amp;prefsQuery); err != nil </span><span class="cov0" title="0">{
                return ApiError(500, "Failed to get preferences", err)
        }</span>

        <span class="cov0" title="0">if prefsQuery.Result.HomeDashboardId != 0 </span><span class="cov0" title="0">{
                slugQuery := m.GetDashboardSlugByIdQuery{Id: prefsQuery.Result.HomeDashboardId}
                err := bus.Dispatch(&amp;slugQuery)
                if err == nil </span><span class="cov0" title="0">{
                        dashRedirect := dtos.DashboardRedirect{RedirectUri: "db/" + slugQuery.Result}
                        return Json(200, &amp;dashRedirect)
                }</span><span class="cov0" title="0"> else {
                        log.Warn("Failed to get slug from database, %s", err.Error())
                }</span>
        }

        <span class="cov0" title="0">filePath := path.Join(setting.StaticRootPath, "dashboards/home.json")
        file, err := os.Open(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return ApiError(500, "Failed to load home dashboard", err)
        }</span>

        <span class="cov0" title="0">dash := dtos.DashboardFullWithMeta{}
        dash.Meta.IsHome = true
        dash.Meta.CanEdit = canEditDashboard(c.OrgRole)
        jsonParser := json.NewDecoder(file)
        if err := jsonParser.Decode(&amp;dash.Dashboard); err != nil </span><span class="cov0" title="0">{
                return ApiError(500, "Failed to load home dashboard", err)
        }</span>

        <span class="cov0" title="0">if c.HasUserRole(m.ROLE_ADMIN) &amp;&amp; !c.HasHelpFlag(m.HelpFlagGettingStartedPanelDismissed) </span><span class="cov0" title="0">{
                addGettingStartedPanelToHomeDashboard(dash.Dashboard)
        }</span>

        <span class="cov0" title="0">return Json(200, &amp;dash)</span>
}

func addGettingStartedPanelToHomeDashboard(dash *simplejson.Json) <span class="cov0" title="0">{
        rows := dash.Get("rows").MustArray()
        row := simplejson.NewFromAny(rows[0])

        newpanel := simplejson.NewFromAny(map[string]interface{}{
                "type": "gettingstarted",
                "id":   123123,
                "span": 12,
        })

        panels := row.Get("panels").MustArray()
        panels = append(panels, newpanel)
        row.Set("panels", panels)
}</span>

func GetDashboardFromJsonFile(c *middleware.Context) <span class="cov0" title="0">{
        file := c.Params(":file")

        dashboard := search.GetDashboardFromJsonIndex(file)
        if dashboard == nil </span><span class="cov0" title="0">{
                c.JsonApiErr(404, "Dashboard not found", nil)
                return
        }</span>

        <span class="cov0" title="0">dash := dtos.DashboardFullWithMeta{Dashboard: dashboard.Data}
        dash.Meta.Type = m.DashTypeJson
        dash.Meta.CanEdit = canEditDashboard(c.OrgRole)

        c.JSON(200, &amp;dash)</span>
}

func GetDashboardTags(c *middleware.Context) <span class="cov0" title="0">{
        query := m.GetDashboardTagsQuery{OrgId: c.OrgId}
        err := bus.Dispatch(&amp;query)
        if err != nil </span><span class="cov0" title="0">{
                c.JsonApiErr(500, "Failed to get tags from database", err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(200, query.Result)</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package api

import (
        "time"

        "github.com/grafana/grafana/pkg/api/dtos"
        "github.com/grafana/grafana/pkg/bus"
        "github.com/grafana/grafana/pkg/metrics"
        "github.com/grafana/grafana/pkg/middleware"
        m "github.com/grafana/grafana/pkg/models"
        "github.com/grafana/grafana/pkg/setting"
        "github.com/grafana/grafana/pkg/util"
)

func GetSharingOptions(c *middleware.Context) <span class="cov0" title="0">{
        c.JSON(200, util.DynMap{
                "externalSnapshotURL":  setting.ExternalSnapshotUrl,
                "externalSnapshotName": setting.ExternalSnapshotName,
                "externalEnabled":      setting.ExternalEnabled,
        })
}</span>

func CreateDashboardSnapshot(c *middleware.Context, cmd m.CreateDashboardSnapshotCommand) <span class="cov0" title="0">{
        if cmd.Name == "" </span><span class="cov0" title="0">{
                cmd.Name = "Unnamed snapshot"
        }</span>

        <span class="cov0" title="0">if cmd.External </span><span class="cov0" title="0">{
                // external snapshot ref requires key and delete key
                if cmd.Key == "" || cmd.DeleteKey == "" </span><span class="cov0" title="0">{
                        c.JsonApiErr(400, "Missing key and delete key for external snapshot", nil)
                        return
                }</span>

                <span class="cov0" title="0">cmd.OrgId = -1
                cmd.UserId = -1
                metrics.M_Api_Dashboard_Snapshot_External.Inc(1)</span>
        }<span class="cov0" title="0"> else {
                cmd.Key = util.GetRandomString(32)
                cmd.DeleteKey = util.GetRandomString(32)
                cmd.OrgId = c.OrgId
                cmd.UserId = c.UserId
                metrics.M_Api_Dashboard_Snapshot_Create.Inc(1)
        }</span>

        <span class="cov0" title="0">if err := bus.Dispatch(&amp;cmd); err != nil </span><span class="cov0" title="0">{
                c.JsonApiErr(500, "Failed to create snaphost", err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(200, util.DynMap{
                "key":       cmd.Key,
                "deleteKey": cmd.DeleteKey,
                "url":       setting.ToAbsUrl("dashboard/snapshot/" + cmd.Key),
                "deleteUrl": setting.ToAbsUrl("api/snapshots-delete/" + cmd.DeleteKey),
        })</span>
}

func GetDashboardSnapshot(c *middleware.Context) <span class="cov0" title="0">{
        key := c.Params(":key")
        query := &amp;m.GetDashboardSnapshotQuery{Key: key}

        err := bus.Dispatch(query)
        if err != nil </span><span class="cov0" title="0">{
                c.JsonApiErr(500, "Failed to get dashboard snapshot", err)
                return
        }</span>

        <span class="cov0" title="0">snapshot := query.Result

        // expired snapshots should also be removed from db
        if snapshot.Expires.Before(time.Now()) </span><span class="cov0" title="0">{
                c.JsonApiErr(404, "Dashboard snapshot not found", err)
                return
        }</span>

        <span class="cov0" title="0">dto := dtos.DashboardFullWithMeta{
                Dashboard: snapshot.Dashboard,
                Meta: dtos.DashboardMeta{
                        Type:       m.DashTypeSnapshot,
                        IsSnapshot: true,
                        Created:    snapshot.Created,
                        Expires:    snapshot.Expires,
                },
        }

        metrics.M_Api_Dashboard_Snapshot_Get.Inc(1)

        c.Resp.Header().Set("Cache-Control", "public, max-age=3600")
        c.JSON(200, dto)</span>
}

func DeleteDashboardSnapshot(c *middleware.Context) <span class="cov0" title="0">{
        key := c.Params(":key")
        cmd := &amp;m.DeleteDashboardSnapshotCommand{DeleteKey: key}

        if err := bus.Dispatch(cmd); err != nil </span><span class="cov0" title="0">{
                c.JsonApiErr(500, "Failed to delete dashboard snapshot", err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(200, util.DynMap{"message": "Snapshot deleted. It might take an hour before it's cleared from a CDN cache."})</span>
}

func SearchDashboardSnapshots(c *middleware.Context) Response <span class="cov0" title="0">{
        query := c.Query("query")
        limit := c.QueryInt("limit")

        if limit == 0 </span><span class="cov0" title="0">{
                limit = 1000
        }</span>

        <span class="cov0" title="0">searchQuery := m.GetDashboardSnapshotsQuery{
                Name:  query,
                Limit: limit,
                OrgId: c.OrgId,
        }

        err := bus.Dispatch(&amp;searchQuery)
        if err != nil </span><span class="cov0" title="0">{
                return ApiError(500, "Search failed", err)
        }</span>

        <span class="cov0" title="0">dtos := make([]*m.DashboardSnapshotDTO, len(searchQuery.Result))
        for i, snapshot := range searchQuery.Result </span><span class="cov0" title="0">{
                dtos[i] = &amp;m.DashboardSnapshotDTO{
                        Id:          snapshot.Id,
                        Name:        snapshot.Name,
                        Key:         snapshot.Key,
                        DeleteKey:   snapshot.DeleteKey,
                        OrgId:       snapshot.OrgId,
                        UserId:      snapshot.UserId,
                        External:    snapshot.External,
                        ExternalUrl: snapshot.ExternalUrl,
                        Expires:     snapshot.Expires,
                        Created:     snapshot.Created,
                        Updated:     snapshot.Updated,
                }
        }</span>

        <span class="cov0" title="0">return Json(200, dtos)</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package api

import (
        "bytes"
        "io/ioutil"
        "net/http"
        "net/http/httputil"
        "net/url"
        "strings"
        "time"

        "github.com/grafana/grafana/pkg/api/cloudwatch"
        "github.com/grafana/grafana/pkg/bus"
        "github.com/grafana/grafana/pkg/log"
        "github.com/grafana/grafana/pkg/metrics"
        "github.com/grafana/grafana/pkg/middleware"
        m "github.com/grafana/grafana/pkg/models"
        "github.com/grafana/grafana/pkg/setting"
        "github.com/grafana/grafana/pkg/util"
)

var (
        dataproxyLogger log.Logger = log.New("data-proxy-log")
)

func NewReverseProxy(ds *m.DataSource, proxyPath string, targetUrl *url.URL) *httputil.ReverseProxy <span class="cov8" title="1">{
        director := func(req *http.Request) </span><span class="cov8" title="1">{
                req.URL.Scheme = targetUrl.Scheme
                req.URL.Host = targetUrl.Host
                req.Host = targetUrl.Host

                reqQueryVals := req.URL.Query()

                if ds.Type == m.DS_INFLUXDB_08 </span><span class="cov8" title="1">{
                        req.URL.Path = util.JoinUrlFragments(targetUrl.Path, "db/"+ds.Database+"/"+proxyPath)
                        reqQueryVals.Add("u", ds.User)
                        reqQueryVals.Add("p", ds.Password)
                        req.URL.RawQuery = reqQueryVals.Encode()
                }</span><span class="cov8" title="1"> else if ds.Type == m.DS_INFLUXDB </span><span class="cov0" title="0">{
                        req.URL.Path = util.JoinUrlFragments(targetUrl.Path, proxyPath)
                        req.URL.RawQuery = reqQueryVals.Encode()
                        if !ds.BasicAuth </span><span class="cov0" title="0">{
                                req.Header.Del("Authorization")
                                req.Header.Add("Authorization", util.GetBasicAuthHeader(ds.User, ds.Password))
                        }</span>
                }<span class="cov8" title="1"> else {
                        req.URL.Path = util.JoinUrlFragments(targetUrl.Path, proxyPath)
                }</span>

                <span class="cov8" title="1">if ds.BasicAuth </span><span class="cov0" title="0">{
                        req.Header.Del("Authorization")
                        req.Header.Add("Authorization", util.GetBasicAuthHeader(ds.BasicAuthUser, ds.BasicAuthPassword))
                }</span>

                <span class="cov8" title="1">dsAuth := req.Header.Get("X-DS-Authorization")
                if len(dsAuth) &gt; 0 </span><span class="cov0" title="0">{
                        req.Header.Del("X-DS-Authorization")
                        req.Header.Del("Authorization")
                        req.Header.Add("Authorization", dsAuth)
                }</span>

                // clear cookie headers
                <span class="cov8" title="1">req.Header.Del("Cookie")
                req.Header.Del("Set-Cookie")</span>
        }

        <span class="cov8" title="1">return &amp;httputil.ReverseProxy{Director: director, FlushInterval: time.Millisecond * 200}</span>
}

func getDatasource(id int64, orgId int64) (*m.DataSource, error) <span class="cov0" title="0">{
        query := m.GetDataSourceByIdQuery{Id: id, OrgId: orgId}
        if err := bus.Dispatch(&amp;query); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return query.Result, nil</span>
}

func ProxyDataSourceRequest(c *middleware.Context) <span class="cov0" title="0">{
        c.TimeRequest(metrics.M_DataSource_ProxyReq_Timer)

        ds, err := getDatasource(c.ParamsInt64(":id"), c.OrgId)

        if err != nil </span><span class="cov0" title="0">{
                c.JsonApiErr(500, "Unable to load datasource meta data", err)
                return
        }</span>

        <span class="cov0" title="0">if ds.Type == m.DS_CLOUDWATCH </span><span class="cov0" title="0">{
                cloudwatch.HandleRequest(c, ds)
                return
        }</span>

        <span class="cov0" title="0">if ds.Type == m.DS_INFLUXDB </span><span class="cov0" title="0">{
                if c.Query("db") != ds.Database </span><span class="cov0" title="0">{
                        c.JsonApiErr(403, "Datasource is not configured to allow this database", nil)
                        return
                }</span>
        }

        <span class="cov0" title="0">targetUrl, _ := url.Parse(ds.Url)
        if len(setting.DataProxyWhiteList) &gt; 0 </span><span class="cov0" title="0">{
                if _, exists := setting.DataProxyWhiteList[targetUrl.Host]; !exists </span><span class="cov0" title="0">{
                        c.JsonApiErr(403, "Data proxy hostname and ip are not included in whitelist", nil)
                        return
                }</span>
        }

        <span class="cov0" title="0">proxyPath := c.Params("*")

        if ds.Type == m.DS_PROMETHEUS </span><span class="cov0" title="0">{
                if c.Req.Request.Method != http.MethodGet || !strings.HasPrefix(proxyPath, "api/") </span><span class="cov0" title="0">{
                        c.JsonApiErr(403, "GET is only allowed on proxied Prometheus datasource", nil)
                        return
                }</span>
        }

        <span class="cov0" title="0">if ds.Type == m.DS_ES </span><span class="cov0" title="0">{
                if c.Req.Request.Method == "DELETE" </span><span class="cov0" title="0">{
                        c.JsonApiErr(403, "Deletes not allowed on proxied Elasticsearch datasource", nil)
                        return
                }</span>
                <span class="cov0" title="0">if c.Req.Request.Method == "PUT" </span><span class="cov0" title="0">{
                        c.JsonApiErr(403, "Puts not allowed on proxied Elasticsearch datasource", nil)
                        return
                }</span>
                <span class="cov0" title="0">if c.Req.Request.Method == "POST" &amp;&amp; proxyPath != "_msearch" </span><span class="cov0" title="0">{
                        c.JsonApiErr(403, "Posts not allowed on proxied Elasticsearch datasource except on /_msearch", nil)
                        return
                }</span>
        }

        <span class="cov0" title="0">proxy := NewReverseProxy(ds, proxyPath, targetUrl)
        proxy.Transport, err = ds.GetHttpTransport()
        if err != nil </span><span class="cov0" title="0">{
                c.JsonApiErr(400, "Unable to load TLS certificate", err)
                return
        }</span>

        <span class="cov0" title="0">logProxyRequest(ds.Type, c)
        proxy.ServeHTTP(c.Resp, c.Req.Request)
        c.Resp.Header().Del("Set-Cookie")</span>
}

func logProxyRequest(dataSourceType string, c *middleware.Context) <span class="cov0" title="0">{
        if !setting.DataProxyLogging </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">var body string
        if c.Req.Request.Body != nil </span><span class="cov0" title="0">{
                buffer, err := ioutil.ReadAll(c.Req.Request.Body)
                if err == nil </span><span class="cov0" title="0">{
                        c.Req.Request.Body = ioutil.NopCloser(bytes.NewBuffer(buffer))
                        body = string(buffer)
                }</span>
        }

        <span class="cov0" title="0">dataproxyLogger.Info("Proxying incoming request",
                "userid", c.UserId,
                "orgid", c.OrgId,
                "username", c.Login,
                "datasource", dataSourceType,
                "uri", c.Req.RequestURI,
                "method", c.Req.Request.Method,
                "body", body)</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package api

import (
        "sort"

        "github.com/grafana/grafana/pkg/api/dtos"
        "github.com/grafana/grafana/pkg/bus"
        "github.com/grafana/grafana/pkg/middleware"
        m "github.com/grafana/grafana/pkg/models"
        "github.com/grafana/grafana/pkg/plugins"
        "github.com/grafana/grafana/pkg/util"
)

func GetDataSources(c *middleware.Context) Response <span class="cov8" title="1">{
        query := m.GetDataSourcesQuery{OrgId: c.OrgId}

        if err := bus.Dispatch(&amp;query); err != nil </span><span class="cov0" title="0">{
                return ApiError(500, "Failed to query datasources", err)
        }</span>

        <span class="cov8" title="1">result := make(dtos.DataSourceList, 0)
        for _, ds := range query.Result </span><span class="cov8" title="1">{
                dsItem := dtos.DataSource{
                        Id:        ds.Id,
                        OrgId:     ds.OrgId,
                        Name:      ds.Name,
                        Url:       ds.Url,
                        Type:      ds.Type,
                        Access:    ds.Access,
                        Password:  ds.Password,
                        Database:  ds.Database,
                        User:      ds.User,
                        BasicAuth: ds.BasicAuth,
                        IsDefault: ds.IsDefault,
                        JsonData:  ds.JsonData,
                }

                if plugin, exists := plugins.DataSources[ds.Type]; exists </span><span class="cov0" title="0">{
                        dsItem.TypeLogoUrl = plugin.Info.Logos.Small
                }</span><span class="cov8" title="1"> else {
                        dsItem.TypeLogoUrl = "public/img/icn-datasource.svg"
                }</span>

                <span class="cov8" title="1">result = append(result, dsItem)</span>
        }

        <span class="cov8" title="1">sort.Sort(result)

        return Json(200, &amp;result)</span>
}

func GetDataSourceById(c *middleware.Context) Response <span class="cov0" title="0">{
        query := m.GetDataSourceByIdQuery{
                Id:    c.ParamsInt64(":id"),
                OrgId: c.OrgId,
        }

        if err := bus.Dispatch(&amp;query); err != nil </span><span class="cov0" title="0">{
                if err == m.ErrDataSourceNotFound </span><span class="cov0" title="0">{
                        return ApiError(404, "Data source not found", nil)
                }</span>
                <span class="cov0" title="0">return ApiError(500, "Failed to query datasources", err)</span>
        }

        <span class="cov0" title="0">ds := query.Result
        dtos := convertModelToDtos(ds)

        return Json(200, &amp;dtos)</span>
}

func DeleteDataSourceById(c *middleware.Context) <span class="cov0" title="0">{
        id := c.ParamsInt64(":id")

        if id &lt;= 0 </span><span class="cov0" title="0">{
                c.JsonApiErr(400, "Missing valid datasource id", nil)
                return
        }</span>

        <span class="cov0" title="0">cmd := &amp;m.DeleteDataSourceByIdCommand{Id: id, OrgId: c.OrgId}

        err := bus.Dispatch(cmd)
        if err != nil </span><span class="cov0" title="0">{
                c.JsonApiErr(500, "Failed to delete datasource", err)
                return
        }</span>

        <span class="cov0" title="0">c.JsonOK("Data source deleted")</span>
}

func DeleteDataSourceByName(c *middleware.Context) <span class="cov0" title="0">{
        name := c.Params(":name")

        if name == "" </span><span class="cov0" title="0">{
                c.JsonApiErr(400, "Missing valid datasource name", nil)
                return
        }</span>

        <span class="cov0" title="0">cmd := &amp;m.DeleteDataSourceByNameCommand{Name: name, OrgId: c.OrgId}

        err := bus.Dispatch(cmd)
        if err != nil </span><span class="cov0" title="0">{
                c.JsonApiErr(500, "Failed to delete datasource", err)
                return
        }</span>

        <span class="cov0" title="0">c.JsonOK("Data source deleted")</span>
}

func AddDataSource(c *middleware.Context, cmd m.AddDataSourceCommand) <span class="cov0" title="0">{
        cmd.OrgId = c.OrgId

        if err := bus.Dispatch(&amp;cmd); err != nil </span><span class="cov0" title="0">{
                if err == m.ErrDataSourceNameExists </span><span class="cov0" title="0">{
                        c.JsonApiErr(409, err.Error(), err)
                        return
                }</span>

                <span class="cov0" title="0">c.JsonApiErr(500, "Failed to add datasource", err)
                return</span>
        }

        <span class="cov0" title="0">c.JSON(200, util.DynMap{"message": "Datasource added", "id": cmd.Result.Id, "name": cmd.Result.Name})</span>
}

func UpdateDataSource(c *middleware.Context, cmd m.UpdateDataSourceCommand) Response <span class="cov0" title="0">{
        cmd.OrgId = c.OrgId
        cmd.Id = c.ParamsInt64(":id")

        err := fillWithSecureJsonData(&amp;cmd)
        if err != nil </span><span class="cov0" title="0">{
                return ApiError(500, "Failed to update datasource", err)
        }</span>

        <span class="cov0" title="0">err = bus.Dispatch(&amp;cmd)
        if err != nil </span><span class="cov0" title="0">{
                return ApiError(500, "Failed to update datasource", err)
        }</span>

        <span class="cov0" title="0">return Json(200, util.DynMap{"message": "Datasource updated", "id": cmd.Id, "name": cmd.Name})</span>
}

func fillWithSecureJsonData(cmd *m.UpdateDataSourceCommand) error <span class="cov0" title="0">{
        if len(cmd.SecureJsonData) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">ds, err := getRawDataSourceById(cmd.Id, cmd.OrgId)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">secureJsonData := ds.SecureJsonData.Decrypt()

        for k, v := range secureJsonData </span><span class="cov0" title="0">{

                if _, ok := cmd.SecureJsonData[k]; !ok </span><span class="cov0" title="0">{
                        cmd.SecureJsonData[k] = v
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func getRawDataSourceById(id int64, orgId int64) (*m.DataSource, error) <span class="cov0" title="0">{
        query := m.GetDataSourceByIdQuery{
                Id:    id,
                OrgId: orgId,
        }

        if err := bus.Dispatch(&amp;query); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return query.Result, nil</span>
}

// Get /api/datasources/name/:name
func GetDataSourceByName(c *middleware.Context) Response <span class="cov0" title="0">{
        query := m.GetDataSourceByNameQuery{Name: c.Params(":name"), OrgId: c.OrgId}

        if err := bus.Dispatch(&amp;query); err != nil </span><span class="cov0" title="0">{
                if err == m.ErrDataSourceNotFound </span><span class="cov0" title="0">{
                        return ApiError(404, "Data source not found", nil)
                }</span>
                <span class="cov0" title="0">return ApiError(500, "Failed to query datasources", err)</span>
        }

        <span class="cov0" title="0">dtos := convertModelToDtos(query.Result)
        return Json(200, &amp;dtos)</span>
}

// Get /api/datasources/id/:name
func GetDataSourceIdByName(c *middleware.Context) Response <span class="cov0" title="0">{
        query := m.GetDataSourceByNameQuery{Name: c.Params(":name"), OrgId: c.OrgId}

        if err := bus.Dispatch(&amp;query); err != nil </span><span class="cov0" title="0">{
                if err == m.ErrDataSourceNotFound </span><span class="cov0" title="0">{
                        return ApiError(404, "Data source not found", nil)
                }</span>
                <span class="cov0" title="0">return ApiError(500, "Failed to query datasources", err)</span>
        }

        <span class="cov0" title="0">ds := query.Result
        dtos := dtos.AnyId{
                Id: ds.Id,
        }

        return Json(200, &amp;dtos)</span>
}

func convertModelToDtos(ds *m.DataSource) dtos.DataSource <span class="cov0" title="0">{
        dto := dtos.DataSource{
                Id:                ds.Id,
                OrgId:             ds.OrgId,
                Name:              ds.Name,
                Url:               ds.Url,
                Type:              ds.Type,
                Access:            ds.Access,
                Password:          ds.Password,
                Database:          ds.Database,
                User:              ds.User,
                BasicAuth:         ds.BasicAuth,
                BasicAuthUser:     ds.BasicAuthUser,
                BasicAuthPassword: ds.BasicAuthPassword,
                WithCredentials:   ds.WithCredentials,
                IsDefault:         ds.IsDefault,
                JsonData:          ds.JsonData,
                SecureJsonFields:  map[string]bool{},
        }

        for k, v := range ds.SecureJsonData </span><span class="cov0" title="0">{
                if len(v) &gt; 0 </span><span class="cov0" title="0">{
                        dto.SecureJsonFields[k] = true
                }</span>
        }

        <span class="cov0" title="0">return dto</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package api

import (
        "strconv"

        "github.com/grafana/grafana/pkg/bus"
        "github.com/grafana/grafana/pkg/log"
        "github.com/grafana/grafana/pkg/middleware"
        m "github.com/grafana/grafana/pkg/models"
        "github.com/grafana/grafana/pkg/plugins"
        "github.com/grafana/grafana/pkg/setting"
        "github.com/grafana/grafana/pkg/util"
)

func getFrontendSettingsMap(c *middleware.Context) (map[string]interface{}, error) <span class="cov0" title="0">{
        orgDataSources := make([]*m.DataSource, 0)

        if c.OrgId != 0 </span><span class="cov0" title="0">{
                query := m.GetDataSourcesQuery{OrgId: c.OrgId}
                err := bus.Dispatch(&amp;query)

                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">orgDataSources = query.Result</span>
        }

        <span class="cov0" title="0">datasources := make(map[string]interface{})
        var defaultDatasource string

        enabledPlugins, err := plugins.GetEnabledPlugins(c.OrgId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">for _, ds := range orgDataSources </span><span class="cov0" title="0">{
                url := ds.Url

                if ds.Access == m.DS_ACCESS_PROXY </span><span class="cov0" title="0">{
                        url = "/api/datasources/proxy/" + strconv.FormatInt(ds.Id, 10)
                }</span>

                <span class="cov0" title="0">var dsMap = map[string]interface{}{
                        "type": ds.Type,
                        "name": ds.Name,
                        "url":  url,
                }

                meta, exists := enabledPlugins.DataSources[ds.Type]
                if !exists </span><span class="cov0" title="0">{
                        log.Error(3, "Could not find plugin definition for data source: %v", ds.Type)
                        continue</span>
                }

                <span class="cov0" title="0">dsMap["meta"] = meta

                if ds.IsDefault </span><span class="cov0" title="0">{
                        defaultDatasource = ds.Name
                }</span>

                <span class="cov0" title="0">if ds.JsonData != nil </span><span class="cov0" title="0">{
                        dsMap["jsonData"] = ds.JsonData
                }</span>

                <span class="cov0" title="0">if ds.Access == m.DS_ACCESS_DIRECT </span><span class="cov0" title="0">{
                        if ds.BasicAuth </span><span class="cov0" title="0">{
                                dsMap["basicAuth"] = util.GetBasicAuthHeader(ds.BasicAuthUser, ds.BasicAuthPassword)
                        }</span>
                        <span class="cov0" title="0">if ds.WithCredentials </span><span class="cov0" title="0">{
                                dsMap["withCredentials"] = ds.WithCredentials
                        }</span>

                        <span class="cov0" title="0">if ds.Type == m.DS_INFLUXDB_08 </span><span class="cov0" title="0">{
                                dsMap["username"] = ds.User
                                dsMap["password"] = ds.Password
                                dsMap["url"] = url + "/db/" + ds.Database
                        }</span>

                        <span class="cov0" title="0">if ds.Type == m.DS_INFLUXDB </span><span class="cov0" title="0">{
                                dsMap["username"] = ds.User
                                dsMap["password"] = ds.Password
                                dsMap["database"] = ds.Database
                                dsMap["url"] = url
                        }</span>
                }

                <span class="cov0" title="0">if ds.Type == m.DS_ES </span><span class="cov0" title="0">{
                        dsMap["index"] = ds.Database
                }</span>

                <span class="cov0" title="0">if ds.Type == m.DS_INFLUXDB </span><span class="cov0" title="0">{
                        dsMap["database"] = ds.Database
                }</span>

                <span class="cov0" title="0">if ds.Type == m.DS_PROMETHEUS </span><span class="cov0" title="0">{
                        // add unproxied server URL for link to Prometheus web UI
                        dsMap["directUrl"] = ds.Url
                }</span>

                <span class="cov0" title="0">datasources[ds.Name] = dsMap</span>
        }

        // add grafana backend data source
        <span class="cov0" title="0">grafanaDatasourceMeta, _ := plugins.DataSources["grafana"]
        datasources["-- Grafana --"] = map[string]interface{}{
                "type": "grafana",
                "name": "-- Grafana --",
                "meta": grafanaDatasourceMeta,
        }

        // add mixed backend data source
        datasources["-- Mixed --"] = map[string]interface{}{
                "type": "mixed",
                "meta": plugins.DataSources["mixed"],
        }

        if defaultDatasource == "" </span><span class="cov0" title="0">{
                defaultDatasource = "-- Grafana --"
        }</span>

        <span class="cov0" title="0">panels := map[string]interface{}{}
        for _, panel := range enabledPlugins.Panels </span><span class="cov0" title="0">{
                panels[panel.Id] = map[string]interface{}{
                        "module":       panel.Module,
                        "baseUrl":      panel.BaseUrl,
                        "name":         panel.Name,
                        "id":           panel.Id,
                        "info":         panel.Info,
                        "hideFromList": panel.HideFromList,
                        "sort":         getPanelSort(panel.Id),
                }
        }</span>

        <span class="cov0" title="0">jsonObj := map[string]interface{}{
                "defaultDatasource": defaultDatasource,
                "datasources":       datasources,
                "panels":            panels,
                "appSubUrl":         setting.AppSubUrl,
                "allowOrgCreate":    (setting.AllowUserOrgCreate &amp;&amp; c.IsSignedIn) || c.IsGrafanaAdmin,
                "authProxyEnabled":  setting.AuthProxyEnabled,
                "ldapEnabled":       setting.LdapEnabled,
                "alertingEnabled":   setting.AlertingEnabled,
                "googleAnalyticsId": setting.GoogleAnalyticsId,
                "buildInfo": map[string]interface{}{
                        "version":       setting.BuildVersion,
                        "commit":        setting.BuildCommit,
                        "buildstamp":    setting.BuildStamp,
                        "latestVersion": plugins.GrafanaLatestVersion,
                        "hasUpdate":     plugins.GrafanaHasUpdate,
                        "env":           setting.Env,
                },
        }

        return jsonObj, nil</span>
}

func getPanelSort(id string) int <span class="cov0" title="0">{
        sort := 100
        switch id </span>{
        case "graph":<span class="cov0" title="0">
                sort = 1</span>
        case "singlestat":<span class="cov0" title="0">
                sort = 2</span>
        case "table":<span class="cov0" title="0">
                sort = 3</span>
        case "text":<span class="cov0" title="0">
                sort = 4</span>
        case "alertlist":<span class="cov0" title="0">
                sort = 5</span>
        case "dashlist":<span class="cov0" title="0">
                sort = 6</span>
        }
        <span class="cov0" title="0">return sort</span>
}

func GetFrontendSettings(c *middleware.Context) <span class="cov0" title="0">{
        settings, err := getFrontendSettingsMap(c)
        if err != nil </span><span class="cov0" title="0">{
                c.JsonApiErr(400, "Failed to get frontend settings", err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(200, settings)</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package api

import (
        "crypto/tls"
        "net"
        "net/http"
        "net/http/httputil"
        "net/url"
        "time"

        "github.com/grafana/grafana/pkg/middleware"
        "github.com/grafana/grafana/pkg/setting"
        "github.com/grafana/grafana/pkg/util"
)

var gNetProxyTransport = &amp;http.Transport{
        TLSClientConfig: &amp;tls.Config{InsecureSkipVerify: false},
        Proxy:           http.ProxyFromEnvironment,
        Dial: (&amp;net.Dialer{
                Timeout:   30 * time.Second,
                KeepAlive: 30 * time.Second,
        }).Dial,
        TLSHandshakeTimeout: 10 * time.Second,
}

func ReverseProxyGnetReq(proxyPath string) *httputil.ReverseProxy <span class="cov0" title="0">{
        url, _ := url.Parse(setting.GrafanaNetUrl)

        director := func(req *http.Request) </span><span class="cov0" title="0">{
                req.URL.Scheme = url.Scheme
                req.URL.Host = url.Host
                req.Host = url.Host

                req.URL.Path = util.JoinUrlFragments(url.Path+"/api", proxyPath)

                // clear cookie headers
                req.Header.Del("Cookie")
                req.Header.Del("Set-Cookie")
                req.Header.Del("Authorization")
        }</span>

        <span class="cov0" title="0">return &amp;httputil.ReverseProxy{Director: director}</span>
}

func ProxyGnetRequest(c *middleware.Context) <span class="cov0" title="0">{
        proxyPath := c.Params("*")
        proxy := ReverseProxyGnetReq(proxyPath)
        proxy.Transport = gNetProxyTransport
        proxy.ServeHTTP(c.Resp, c.Req.Request)
        c.Resp.Header().Del("Set-Cookie")
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package api

import (
        "context"
        "crypto/tls"
        "errors"
        "fmt"
        "net/http"
        "os"
        "path"

        macaron "gopkg.in/macaron.v1"

        "github.com/grafana/grafana/pkg/api/live"
        httpstatic "github.com/grafana/grafana/pkg/api/static"
        "github.com/grafana/grafana/pkg/cmd/grafana-cli/logger"
        "github.com/grafana/grafana/pkg/log"
        "github.com/grafana/grafana/pkg/middleware"
        "github.com/grafana/grafana/pkg/plugins"
        "github.com/grafana/grafana/pkg/setting"
)

type HttpServer struct {
        log           log.Logger
        macaron       *macaron.Macaron
        context       context.Context
        streamManager *live.StreamManager

        httpSrv *http.Server
}

func NewHttpServer() *HttpServer <span class="cov0" title="0">{
        return &amp;HttpServer{
                log: log.New("http.server"),
        }
}</span>

func (hs *HttpServer) Start(ctx context.Context) error <span class="cov0" title="0">{
        var err error

        hs.context = ctx
        hs.streamManager = live.NewStreamManager()
        hs.macaron = hs.newMacaron()
        hs.registerRoutes()

        hs.streamManager.Run(ctx)

        listenAddr := fmt.Sprintf("%s:%s", setting.HttpAddr, setting.HttpPort)
        hs.log.Info("Initializing HTTP Server", "address", listenAddr, "protocol", setting.Protocol, "subUrl", setting.AppSubUrl)

        hs.httpSrv = &amp;http.Server{Addr: listenAddr, Handler: hs.macaron}
        switch setting.Protocol </span>{
        case setting.HTTP:<span class="cov0" title="0">
                err = hs.httpSrv.ListenAndServe()
                if err == http.ErrServerClosed </span><span class="cov0" title="0">{
                        hs.log.Debug("server was shutdown gracefully")
                        return nil
                }</span>
        case setting.HTTPS:<span class="cov0" title="0">
                err = hs.httpSrv.ListenAndServeTLS(setting.CertFile, setting.KeyFile)
                if err == http.ErrServerClosed </span><span class="cov0" title="0">{
                        hs.log.Debug("server was shutdown gracefully")
                        return nil
                }</span>
        default:<span class="cov0" title="0">
                hs.log.Error("Invalid protocol", "protocol", setting.Protocol)
                err = errors.New("Invalid Protocol")</span>
        }

        <span class="cov0" title="0">return err</span>
}

func (hs *HttpServer) Shutdown(ctx context.Context) error <span class="cov0" title="0">{
        err := hs.httpSrv.Shutdown(ctx)
        hs.log.Info("stopped http server")
        return err
}</span>

func (hs *HttpServer) listenAndServeTLS(listenAddr, certfile, keyfile string) error <span class="cov0" title="0">{
        if certfile == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("cert_file cannot be empty when using HTTPS")
        }</span>

        <span class="cov0" title="0">if keyfile == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("cert_key cannot be empty when using HTTPS")
        }</span>

        <span class="cov0" title="0">if _, err := os.Stat(setting.CertFile); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return fmt.Errorf(`Cannot find SSL cert_file at %v`, setting.CertFile)
        }</span>

        <span class="cov0" title="0">if _, err := os.Stat(setting.KeyFile); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return fmt.Errorf(`Cannot find SSL key_file at %v`, setting.KeyFile)
        }</span>

        <span class="cov0" title="0">tlsCfg := &amp;tls.Config{
                MinVersion:               tls.VersionTLS12,
                PreferServerCipherSuites: true,
                CipherSuites: []uint16{
                        tls.TLS_RSA_WITH_AES_128_CBC_SHA,
                        tls.TLS_RSA_WITH_AES_256_CBC_SHA,
                        tls.TLS_RSA_WITH_AES_128_GCM_SHA256,
                        tls.TLS_RSA_WITH_AES_256_GCM_SHA384,
                        tls.TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA,
                        tls.TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA,
                        tls.TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,
                        tls.TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,
                        tls.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
                        tls.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
                        tls.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,
                        tls.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,
                },
        }
        srv := &amp;http.Server{
                Addr:         listenAddr,
                Handler:      hs.macaron,
                TLSConfig:    tlsCfg,
                TLSNextProto: make(map[string]func(*http.Server, *tls.Conn, http.Handler), 0),
        }

        return srv.ListenAndServeTLS(setting.CertFile, setting.KeyFile)</span>
}

func (hs *HttpServer) newMacaron() *macaron.Macaron <span class="cov0" title="0">{
        macaron.Env = setting.Env
        m := macaron.New()

        m.Use(middleware.Logger())
        m.Use(middleware.Recovery())

        if setting.EnableGzip </span><span class="cov0" title="0">{
                m.Use(middleware.Gziper())
        }</span>

        <span class="cov0" title="0">for _, route := range plugins.StaticRoutes </span><span class="cov0" title="0">{
                pluginRoute := path.Join("/public/plugins/", route.PluginId)
                logger.Debug("Plugins: Adding route", "route", pluginRoute, "dir", route.Directory)
                hs.mapStatic(m, route.Directory, "", pluginRoute)
        }</span>

        <span class="cov0" title="0">hs.mapStatic(m, setting.StaticRootPath, "", "public")
        hs.mapStatic(m, setting.StaticRootPath, "robots.txt", "robots.txt")

        m.Use(macaron.Renderer(macaron.RenderOptions{
                Directory:  path.Join(setting.StaticRootPath, "views"),
                IndentJSON: macaron.Env != macaron.PROD,
                Delims:     macaron.Delims{Left: "[[", Right: "]]"},
        }))

        m.Use(middleware.GetContextHandler())
        m.Use(middleware.Sessioner(&amp;setting.SessionOptions))
        m.Use(middleware.RequestMetrics())
        m.Use(middleware.OrgRedirect())

        // needs to be after context handler
        if setting.EnforceDomain </span><span class="cov0" title="0">{
                m.Use(middleware.ValidateHostHeader(setting.Domain))
        }</span>

        <span class="cov0" title="0">return m</span>
}

func (hs *HttpServer) mapStatic(m *macaron.Macaron, rootDir string, dir string, prefix string) <span class="cov0" title="0">{
        headers := func(c *macaron.Context) </span><span class="cov0" title="0">{
                c.Resp.Header().Set("Cache-Control", "public, max-age=3600")
        }</span>

        <span class="cov0" title="0">if setting.Env == setting.DEV </span><span class="cov0" title="0">{
                headers = func(c *macaron.Context) </span><span class="cov0" title="0">{
                        c.Resp.Header().Set("Cache-Control", "max-age=0, must-revalidate, no-cache")
                }</span>
        }

        <span class="cov0" title="0">m.Use(httpstatic.Static(
                path.Join(rootDir, dir),
                httpstatic.StaticOptions{
                        SkipLogging: true,
                        Prefix:      prefix,
                        AddHeaders:  headers,
                },
        ))</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package api

import (
        "fmt"
        "strings"

        "github.com/grafana/grafana/pkg/api/dtos"
        "github.com/grafana/grafana/pkg/bus"
        "github.com/grafana/grafana/pkg/middleware"
        m "github.com/grafana/grafana/pkg/models"
        "github.com/grafana/grafana/pkg/plugins"
        "github.com/grafana/grafana/pkg/setting"
)

func setIndexViewData(c *middleware.Context) (*dtos.IndexViewData, error) <span class="cov0" title="0">{
        settings, err := getFrontendSettingsMap(c)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">prefsQuery := m.GetPreferencesWithDefaultsQuery{OrgId: c.OrgId, UserId: c.UserId}
        if err := bus.Dispatch(&amp;prefsQuery); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">prefs := prefsQuery.Result

        // Read locale from acccept-language
        acceptLang := c.Req.Header.Get("Accept-Language")
        locale := "en-US"

        if len(acceptLang) &gt; 0 </span><span class="cov0" title="0">{
                parts := strings.Split(acceptLang, ",")
                locale = parts[0]
        }</span>

        <span class="cov0" title="0">appUrl := setting.AppUrl
        appSubUrl := setting.AppSubUrl

        // special case when doing localhost call from phantomjs
        if c.IsRenderCall </span><span class="cov0" title="0">{
                appUrl = fmt.Sprintf("%s://localhost:%s", setting.Protocol, setting.HttpPort)
                appSubUrl = ""
                settings["appSubUrl"] = ""
        }</span>

        <span class="cov0" title="0">var data = dtos.IndexViewData{
                User: &amp;dtos.CurrentUser{
                        Id:             c.UserId,
                        IsSignedIn:     c.IsSignedIn,
                        Login:          c.Login,
                        Email:          c.Email,
                        Name:           c.Name,
                        OrgId:          c.OrgId,
                        OrgName:        c.OrgName,
                        OrgRole:        c.OrgRole,
                        GravatarUrl:    dtos.GetGravatarUrl(c.Email),
                        IsGrafanaAdmin: c.IsGrafanaAdmin,
                        LightTheme:     prefs.Theme == "light",
                        Timezone:       prefs.Timezone,
                        Locale:         locale,
                        HelpFlags1:     c.HelpFlags1,
                },
                Settings:                settings,
                AppUrl:                  appUrl,
                AppSubUrl:               appSubUrl,
                GoogleAnalyticsId:       setting.GoogleAnalyticsId,
                GoogleTagManagerId:      setting.GoogleTagManagerId,
                BuildVersion:            setting.BuildVersion,
                BuildCommit:             setting.BuildCommit,
                NewGrafanaVersion:       plugins.GrafanaLatestVersion,
                NewGrafanaVersionExists: plugins.GrafanaHasUpdate,
        }

        if setting.DisableGravatar </span><span class="cov0" title="0">{
                data.User.GravatarUrl = setting.AppSubUrl + "/public/img/transparent.png"
        }</span>

        <span class="cov0" title="0">if len(data.User.Name) == 0 </span><span class="cov0" title="0">{
                data.User.Name = data.User.Login
        }</span>

        <span class="cov0" title="0">themeUrlParam := c.Query("theme")
        if themeUrlParam == "light" </span><span class="cov0" title="0">{
                data.User.LightTheme = true
        }</span>

        <span class="cov0" title="0">dashboardChildNavs := []*dtos.NavLink{
                {Text: "Home", Url: setting.AppSubUrl + "/"},
                {Text: "Playlists", Url: setting.AppSubUrl + "/playlists"},
                {Text: "Snapshots", Url: setting.AppSubUrl + "/dashboard/snapshots"},
        }

        if c.OrgRole == m.ROLE_ADMIN || c.OrgRole == m.ROLE_EDITOR </span><span class="cov0" title="0">{
                dashboardChildNavs = append(dashboardChildNavs, &amp;dtos.NavLink{Divider: true})
                dashboardChildNavs = append(dashboardChildNavs, &amp;dtos.NavLink{Text: "New", Icon: "fa fa-plus", Url: setting.AppSubUrl + "/dashboard/new"})
                dashboardChildNavs = append(dashboardChildNavs, &amp;dtos.NavLink{Text: "Import", Icon: "fa fa-download", Url: setting.AppSubUrl + "/dashboard/new/?editview=import"})
        }</span>

        <span class="cov0" title="0">data.MainNavLinks = append(data.MainNavLinks, &amp;dtos.NavLink{
                Text:     "Dashboards",
                Icon:     "icon-gf icon-gf-dashboard",
                Url:      setting.AppSubUrl + "/",
                Children: dashboardChildNavs,
        })

        if setting.AlertingEnabled &amp;&amp; (c.OrgRole == m.ROLE_ADMIN || c.OrgRole == m.ROLE_EDITOR) </span><span class="cov0" title="0">{
                alertChildNavs := []*dtos.NavLink{
                        {Text: "Alert List", Url: setting.AppSubUrl + "/alerting/list"},
                        {Text: "Notification channels", Url: setting.AppSubUrl + "/alerting/notifications"},
                }

                data.MainNavLinks = append(data.MainNavLinks, &amp;dtos.NavLink{
                        Text:     "Alerting",
                        Icon:     "icon-gf icon-gf-alert",
                        Url:      setting.AppSubUrl + "/alerting/list",
                        Children: alertChildNavs,
                })
        }</span>

        <span class="cov0" title="0">if c.OrgRole == m.ROLE_ADMIN </span><span class="cov0" title="0">{
                data.MainNavLinks = append(data.MainNavLinks, &amp;dtos.NavLink{
                        Text: "Data Sources",
                        Icon: "icon-gf icon-gf-datasources",
                        Url:  setting.AppSubUrl + "/datasources",
                })

                data.MainNavLinks = append(data.MainNavLinks, &amp;dtos.NavLink{
                        Text: "Plugins",
                        Icon: "icon-gf icon-gf-apps",
                        Url:  setting.AppSubUrl + "/plugins",
                })
        }</span>

        <span class="cov0" title="0">enabledPlugins, err := plugins.GetEnabledPlugins(c.OrgId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">for _, plugin := range enabledPlugins.Apps </span><span class="cov0" title="0">{
                if plugin.Pinned </span><span class="cov0" title="0">{
                        appLink := &amp;dtos.NavLink{
                                Text: plugin.Name,
                                Url:  plugin.DefaultNavUrl,
                                Img:  plugin.Info.Logos.Small,
                        }

                        for _, include := range plugin.Includes </span><span class="cov0" title="0">{
                                if !c.HasUserRole(include.Role) </span><span class="cov0" title="0">{
                                        continue</span>
                                }

                                <span class="cov0" title="0">if include.Type == "page" &amp;&amp; include.AddToNav </span><span class="cov0" title="0">{
                                        link := &amp;dtos.NavLink{
                                                Url:  setting.AppSubUrl + "/plugins/" + plugin.Id + "/page/" + include.Slug,
                                                Text: include.Name,
                                        }
                                        appLink.Children = append(appLink.Children, link)
                                }</span>

                                <span class="cov0" title="0">if include.Type == "dashboard" &amp;&amp; include.AddToNav </span><span class="cov0" title="0">{
                                        link := &amp;dtos.NavLink{
                                                Url:  setting.AppSubUrl + "/dashboard/db/" + include.Slug,
                                                Text: include.Name,
                                        }
                                        appLink.Children = append(appLink.Children, link)
                                }</span>
                        }

                        <span class="cov0" title="0">if len(appLink.Children) &gt; 0 &amp;&amp; c.OrgRole == m.ROLE_ADMIN </span><span class="cov0" title="0">{
                                appLink.Children = append(appLink.Children, &amp;dtos.NavLink{Divider: true})
                                appLink.Children = append(appLink.Children, &amp;dtos.NavLink{Text: "Plugin Config", Icon: "fa fa-cog", Url: setting.AppSubUrl + "/plugins/" + plugin.Id + "/edit"})
                        }</span>

                        <span class="cov0" title="0">if len(appLink.Children) &gt; 0 </span><span class="cov0" title="0">{
                                data.MainNavLinks = append(data.MainNavLinks, appLink)
                        }</span>
                }
        }

        <span class="cov0" title="0">if c.IsGrafanaAdmin </span><span class="cov0" title="0">{
                data.MainNavLinks = append(data.MainNavLinks, &amp;dtos.NavLink{
                        Text: "Admin",
                        Icon: "fa fa-fw fa-cogs",
                        Url:  setting.AppSubUrl + "/admin",
                        Children: []*dtos.NavLink{
                                {Text: "Global Users", Url: setting.AppSubUrl + "/admin/users"},
                                {Text: "Global Orgs", Url: setting.AppSubUrl + "/admin/orgs"},
                                {Text: "Server Settings", Url: setting.AppSubUrl + "/admin/settings"},
                                {Text: "Server Stats", Url: setting.AppSubUrl + "/admin/stats"},
                        },
                })
        }</span>

        <span class="cov0" title="0">return &amp;data, nil</span>
}

func Index(c *middleware.Context) <span class="cov0" title="0">{
        if data, err := setIndexViewData(c); err != nil </span><span class="cov0" title="0">{
                c.Handle(500, "Failed to get settings", err)
                return
        }</span><span class="cov0" title="0"> else {
                c.HTML(200, "index", data)
        }</span>
}

func NotFoundHandler(c *middleware.Context) <span class="cov0" title="0">{
        if c.IsApiRequest() </span><span class="cov0" title="0">{
                c.JsonApiErr(404, "Not found", nil)
                return
        }</span>

        <span class="cov0" title="0">if data, err := setIndexViewData(c); err != nil </span><span class="cov0" title="0">{
                c.Handle(500, "Failed to get settings", err)
                return
        }</span><span class="cov0" title="0"> else {
                c.HTML(404, "index", data)
        }</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package api

import (
        "net/url"

        "github.com/grafana/grafana/pkg/api/dtos"
        "github.com/grafana/grafana/pkg/bus"
        "github.com/grafana/grafana/pkg/log"
        "github.com/grafana/grafana/pkg/login"
        "github.com/grafana/grafana/pkg/metrics"
        "github.com/grafana/grafana/pkg/middleware"
        m "github.com/grafana/grafana/pkg/models"
        "github.com/grafana/grafana/pkg/setting"
        "github.com/grafana/grafana/pkg/util"
)

const (
        VIEW_INDEX = "index"
)

func LoginView(c *middleware.Context) <span class="cov0" title="0">{
        viewData, err := setIndexViewData(c)
        if err != nil </span><span class="cov0" title="0">{
                c.Handle(500, "Failed to get settings", err)
                return
        }</span>

        <span class="cov0" title="0">enabledOAuths := make(map[string]interface{})
        for key, oauth := range setting.OAuthService.OAuthInfos </span><span class="cov0" title="0">{
                enabledOAuths[key] = map[string]string{"name": oauth.Name}
        }</span>

        <span class="cov0" title="0">viewData.Settings["oauth"] = enabledOAuths
        viewData.Settings["disableUserSignUp"] = !setting.AllowUserSignUp
        viewData.Settings["loginHint"] = setting.LoginHint
        viewData.Settings["disableLoginForm"] = setting.DisableLoginForm

        if !tryLoginUsingRememberCookie(c) </span><span class="cov0" title="0">{
                c.HTML(200, VIEW_INDEX, viewData)
                return
        }</span>

        <span class="cov0" title="0">if redirectTo, _ := url.QueryUnescape(c.GetCookie("redirect_to")); len(redirectTo) &gt; 0 </span><span class="cov0" title="0">{
                c.SetCookie("redirect_to", "", -1, setting.AppSubUrl+"/")
                c.Redirect(redirectTo)
                return
        }</span>

        <span class="cov0" title="0">c.Redirect(setting.AppSubUrl + "/")</span>
}

func tryLoginUsingRememberCookie(c *middleware.Context) bool <span class="cov0" title="0">{
        // Check auto-login.
        uname := c.GetCookie(setting.CookieUserName)
        if len(uname) == 0 </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">isSucceed := false
        defer func() </span><span class="cov0" title="0">{
                if !isSucceed </span><span class="cov0" title="0">{
                        log.Trace("auto-login cookie cleared: %s", uname)
                        c.SetCookie(setting.CookieUserName, "", -1, setting.AppSubUrl+"/")
                        c.SetCookie(setting.CookieRememberName, "", -1, setting.AppSubUrl+"/")
                        return
                }</span>
        }()

        <span class="cov0" title="0">userQuery := m.GetUserByLoginQuery{LoginOrEmail: uname}
        if err := bus.Dispatch(&amp;userQuery); err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">user := userQuery.Result

        // validate remember me cookie
        if val, _ := c.GetSuperSecureCookie(
                util.EncodeMd5(user.Rands+user.Password), setting.CookieRememberName); val != user.Login </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">isSucceed = true
        loginUserWithUser(user, c)
        return true</span>
}

func LoginApiPing(c *middleware.Context) <span class="cov0" title="0">{
        if !tryLoginUsingRememberCookie(c) </span><span class="cov0" title="0">{
                c.JsonApiErr(401, "Unauthorized", nil)
                return
        }</span>

        <span class="cov0" title="0">c.JsonOK("Logged in")</span>
}

func LoginPost(c *middleware.Context, cmd dtos.LoginCommand) Response <span class="cov0" title="0">{
        authQuery := login.LoginUserQuery{
                Username: cmd.User,
                Password: cmd.Password,
        }

        if err := bus.Dispatch(&amp;authQuery); err != nil </span><span class="cov0" title="0">{
                if err == login.ErrInvalidCredentials </span><span class="cov0" title="0">{
                        return ApiError(401, "Invalid username or password", err)
                }</span>

                <span class="cov0" title="0">return ApiError(500, "Error while trying to authenticate user", err)</span>
        }

        <span class="cov0" title="0">user := authQuery.User

        loginUserWithUser(user, c)

        result := map[string]interface{}{
                "message": "Logged in",
        }

        if redirectTo, _ := url.QueryUnescape(c.GetCookie("redirect_to")); len(redirectTo) &gt; 0 </span><span class="cov0" title="0">{
                result["redirectUrl"] = redirectTo
                c.SetCookie("redirect_to", "", -1, setting.AppSubUrl+"/")
        }</span>

        <span class="cov0" title="0">metrics.M_Api_Login_Post.Inc(1)

        return Json(200, result)</span>
}

func loginUserWithUser(user *m.User, c *middleware.Context) <span class="cov0" title="0">{
        if user == nil </span><span class="cov0" title="0">{
                log.Error(3, "User login with nil user")
        }</span>

        <span class="cov0" title="0">days := 86400 * setting.LogInRememberDays
        if days &gt; 0 </span><span class="cov0" title="0">{
                c.SetCookie(setting.CookieUserName, user.Login, days, setting.AppSubUrl+"/")
                c.SetSuperSecureCookie(util.EncodeMd5(user.Rands+user.Password), setting.CookieRememberName, user.Login, days, setting.AppSubUrl+"/")
        }</span>

        <span class="cov0" title="0">c.Session.Set(middleware.SESS_KEY_USERID, user.Id)</span>
}

func Logout(c *middleware.Context) <span class="cov0" title="0">{
        c.SetCookie(setting.CookieUserName, "", -1, setting.AppSubUrl+"/")
        c.SetCookie(setting.CookieRememberName, "", -1, setting.AppSubUrl+"/")
        c.Session.Destory(c)
        c.Redirect(setting.AppSubUrl + "/login")
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package api

import (
        "crypto/rand"
        "crypto/tls"
        "crypto/x509"
        "encoding/base64"
        "errors"
        "fmt"
        "io/ioutil"
        "log"
        "net/http"
        "net/url"

        "golang.org/x/net/context"
        "golang.org/x/oauth2"

        "github.com/grafana/grafana/pkg/bus"
        "github.com/grafana/grafana/pkg/metrics"
        "github.com/grafana/grafana/pkg/middleware"
        m "github.com/grafana/grafana/pkg/models"
        "github.com/grafana/grafana/pkg/setting"
        "github.com/grafana/grafana/pkg/social"
)

func GenStateString() string <span class="cov0" title="0">{
        rnd := make([]byte, 32)
        rand.Read(rnd)
        return base64.StdEncoding.EncodeToString(rnd)
}</span>

func OAuthLogin(ctx *middleware.Context) <span class="cov0" title="0">{
        if setting.OAuthService == nil </span><span class="cov0" title="0">{
                ctx.Handle(404, "login.OAuthLogin(oauth service not enabled)", nil)
                return
        }</span>

        <span class="cov0" title="0">name := ctx.Params(":name")
        connect, ok := social.SocialMap[name]
        if !ok </span><span class="cov0" title="0">{
                ctx.Handle(404, "login.OAuthLogin(social login not enabled)", errors.New(name))
                return
        }</span>

        <span class="cov0" title="0">error := ctx.Query("error")
        if error != "" </span><span class="cov0" title="0">{
                errorDesc := ctx.Query("error_description")
                ctx.Logger.Info("OAuthLogin Failed", "error", error, "errorDesc", errorDesc)
                ctx.Redirect(setting.AppSubUrl + "/login?failCode=1003")
                return
        }</span>

        <span class="cov0" title="0">code := ctx.Query("code")
        if code == "" </span><span class="cov0" title="0">{
                state := GenStateString()
                ctx.Session.Set(middleware.SESS_KEY_OAUTH_STATE, state)
                if setting.OAuthService.OAuthInfos[name].HostedDomain == "" </span><span class="cov0" title="0">{
                        ctx.Redirect(connect.AuthCodeURL(state, oauth2.AccessTypeOnline))
                }</span><span class="cov0" title="0"> else {
                        ctx.Redirect(connect.AuthCodeURL(state, oauth2.SetParam("hd", setting.OAuthService.OAuthInfos[name].HostedDomain), oauth2.AccessTypeOnline))
                }</span>
                <span class="cov0" title="0">return</span>
        }

        // verify state string
        <span class="cov0" title="0">savedState := ctx.Session.Get(middleware.SESS_KEY_OAUTH_STATE).(string)
        queryState := ctx.Query("state")
        if savedState != queryState </span><span class="cov0" title="0">{
                ctx.Handle(500, "login.OAuthLogin(state mismatch)", nil)
                return
        }</span>

        // handle call back

        // initialize oauth2 context
        <span class="cov0" title="0">oauthCtx := oauth2.NoContext
        if setting.OAuthService.OAuthInfos[name].TlsClientCert != "" </span><span class="cov0" title="0">{
                cert, err := tls.LoadX509KeyPair(setting.OAuthService.OAuthInfos[name].TlsClientCert, setting.OAuthService.OAuthInfos[name].TlsClientKey)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal(err)
                }</span>

                // Load CA cert
                <span class="cov0" title="0">caCert, err := ioutil.ReadFile(setting.OAuthService.OAuthInfos[name].TlsClientCa)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal(err)
                }</span>
                <span class="cov0" title="0">caCertPool := x509.NewCertPool()
                caCertPool.AppendCertsFromPEM(caCert)

                tr := &amp;http.Transport{
                        TLSClientConfig: &amp;tls.Config{
                                InsecureSkipVerify: true,
                                Certificates:       []tls.Certificate{cert},
                                RootCAs:            caCertPool,
                        },
                }
                sslcli := &amp;http.Client{Transport: tr}

                oauthCtx = context.Background()
                oauthCtx = context.WithValue(oauthCtx, oauth2.HTTPClient, sslcli)</span>
        }

        // get token from provider
        <span class="cov0" title="0">token, err := connect.Exchange(oauthCtx, code)
        if err != nil </span><span class="cov0" title="0">{
                ctx.Handle(500, "login.OAuthLogin(NewTransportWithCode)", err)
                return
        }</span>
        // token.TokenType was defaulting to "bearer", which is out of spec, so we explicitly set to "Bearer"
        <span class="cov0" title="0">token.TokenType = "Bearer"

        ctx.Logger.Debug("OAuthLogin Got token")

        // set up oauth2 client
        client := connect.Client(oauthCtx, token)

        // get user info
        userInfo, err := connect.UserInfo(client)
        if err != nil </span><span class="cov0" title="0">{
                if err == social.ErrMissingTeamMembership </span><span class="cov0" title="0">{
                        ctx.Redirect(setting.AppSubUrl + "/login?failCode=1000")
                }</span><span class="cov0" title="0"> else if err == social.ErrMissingOrganizationMembership </span><span class="cov0" title="0">{
                        ctx.Redirect(setting.AppSubUrl + "/login?failCode=1001")
                }</span><span class="cov0" title="0"> else {
                        ctx.Handle(500, fmt.Sprintf("login.OAuthLogin(get info from %s)", name), err)
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">ctx.Logger.Debug("OAuthLogin got user info", "userInfo", userInfo)

        // validate that the email is allowed to login to grafana
        if !connect.IsEmailAllowed(userInfo.Email) </span><span class="cov0" title="0">{
                ctx.Logger.Info("OAuth login attempt with unallowed email", "email", userInfo.Email)
                ctx.Redirect(setting.AppSubUrl + "/login?failCode=1002")
                return
        }</span>

        <span class="cov0" title="0">userQuery := m.GetUserByEmailQuery{Email: userInfo.Email}
        err = bus.Dispatch(&amp;userQuery)

        // create account if missing
        if err == m.ErrUserNotFound </span><span class="cov0" title="0">{
                if !connect.IsSignupAllowed() </span><span class="cov0" title="0">{
                        ctx.Redirect(setting.AppSubUrl + "/login")
                        return
                }</span>
                <span class="cov0" title="0">limitReached, err := middleware.QuotaReached(ctx, "user")
                if err != nil </span><span class="cov0" title="0">{
                        ctx.Handle(500, "Failed to get user quota", err)
                        return
                }</span>
                <span class="cov0" title="0">if limitReached </span><span class="cov0" title="0">{
                        ctx.Redirect(setting.AppSubUrl + "/login")
                        return
                }</span>
                <span class="cov0" title="0">cmd := m.CreateUserCommand{
                        Login:          userInfo.Login,
                        Email:          userInfo.Email,
                        Name:           userInfo.Name,
                        Company:        userInfo.Company,
                        DefaultOrgRole: userInfo.Role,
                }

                if err = bus.Dispatch(&amp;cmd); err != nil </span><span class="cov0" title="0">{
                        ctx.Handle(500, "Failed to create account", err)
                        return
                }</span>

                <span class="cov0" title="0">userQuery.Result = &amp;cmd.Result</span>
        }<span class="cov0" title="0"> else if err != nil </span><span class="cov0" title="0">{
                ctx.Handle(500, "Unexpected error", err)
        }</span>

        // login
        <span class="cov0" title="0">loginUserWithUser(userQuery.Result, ctx)

        metrics.M_Api_Login_OAuth.Inc(1)

        if redirectTo, _ := url.QueryUnescape(ctx.GetCookie("redirect_to")); len(redirectTo) &gt; 0 </span><span class="cov0" title="0">{
                ctx.SetCookie("redirect_to", "", -1, setting.AppSubUrl+"/")
                ctx.Redirect(redirectTo)
                return
        }</span>

        <span class="cov0" title="0">ctx.Redirect(setting.AppSubUrl + "/")</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package api

import (
        "context"
        "encoding/json"
        "net/http"

        "github.com/grafana/grafana/pkg/api/dtos"
        "github.com/grafana/grafana/pkg/metrics"
        "github.com/grafana/grafana/pkg/middleware"
        "github.com/grafana/grafana/pkg/models"
        "github.com/grafana/grafana/pkg/tsdb"
        "github.com/grafana/grafana/pkg/tsdb/testdata"
        "github.com/grafana/grafana/pkg/util"
)

// POST /api/tsdb/query
func QueryMetrics(c *middleware.Context, reqDto dtos.MetricRequest) Response <span class="cov0" title="0">{
        timeRange := tsdb.NewTimeRange(reqDto.From, reqDto.To)

        request := &amp;tsdb.Request{TimeRange: timeRange}

        for _, query := range reqDto.Queries </span><span class="cov0" title="0">{
                request.Queries = append(request.Queries, &amp;tsdb.Query{
                        RefId:         query.Get("refId").MustString("A"),
                        MaxDataPoints: query.Get("maxDataPoints").MustInt64(100),
                        IntervalMs:    query.Get("intervalMs").MustInt64(1000),
                        Model:         query,
                        DataSource: &amp;models.DataSource{
                                Name: "Grafana TestDataDB",
                                Type: "grafana-testdata-datasource",
                        },
                })
        }</span>

        <span class="cov0" title="0">resp, err := tsdb.HandleRequest(context.TODO(), request)
        if err != nil </span><span class="cov0" title="0">{
                return ApiError(500, "Metric request error", err)
        }</span>

        <span class="cov0" title="0">return Json(200, &amp;resp)</span>
}

// GET /api/tsdb/testdata/scenarios
func GetTestDataScenarios(c *middleware.Context) Response <span class="cov0" title="0">{
        result := make([]interface{}, 0)

        for _, scenario := range testdata.ScenarioRegistry </span><span class="cov0" title="0">{
                result = append(result, map[string]interface{}{
                        "id":          scenario.Id,
                        "name":        scenario.Name,
                        "description": scenario.Description,
                        "stringInput": scenario.StringInput,
                })
        }</span>

        <span class="cov0" title="0">return Json(200, &amp;result)</span>
}

func GetInternalMetrics(c *middleware.Context) Response <span class="cov0" title="0">{
        if metrics.UseNilMetrics </span><span class="cov0" title="0">{
                return Json(200, util.DynMap{"message": "Metrics disabled"})
        }</span>

        <span class="cov0" title="0">snapshots := metrics.MetricStats.GetSnapshots()

        resp := make(map[string]interface{})

        for _, m := range snapshots </span><span class="cov0" title="0">{
                metricName := m.Name() + m.StringifyTags()

                switch metric := m.(type) </span>{
                case metrics.Gauge:<span class="cov0" title="0">
                        resp[metricName] = map[string]interface{}{
                                "value": metric.Value(),
                        }</span>
                case metrics.Counter:<span class="cov0" title="0">
                        resp[metricName] = map[string]interface{}{
                                "count": metric.Count(),
                        }</span>
                case metrics.Timer:<span class="cov0" title="0">
                        percentiles := metric.Percentiles([]float64{0.25, 0.75, 0.90, 0.99})
                        resp[metricName] = map[string]interface{}{
                                "count": metric.Count(),
                                "min":   metric.Min(),
                                "max":   metric.Max(),
                                "mean":  metric.Mean(),
                                "std":   metric.StdDev(),
                                "p25":   percentiles[0],
                                "p75":   percentiles[1],
                                "p90":   percentiles[2],
                                "p99":   percentiles[3],
                        }</span>
                }
        }

        <span class="cov0" title="0">var b []byte
        var err error
        if b, err = json.MarshalIndent(resp, "", " "); err != nil </span><span class="cov0" title="0">{
                return ApiError(500, "body json marshal", err)
        }</span>

        <span class="cov0" title="0">return &amp;NormalResponse{
                body:   b,
                status: 200,
                header: http.Header{
                        "Content-Type": []string{"application/json"},
                },
        }</span>
}

// Genereates a index out of range error
func GenerateError(c *middleware.Context) Response <span class="cov0" title="0">{
        var array []string
        return Json(200, array[20])
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package api

import (
        "github.com/grafana/grafana/pkg/api/dtos"
        "github.com/grafana/grafana/pkg/bus"
        "github.com/grafana/grafana/pkg/metrics"
        "github.com/grafana/grafana/pkg/middleware"
        m "github.com/grafana/grafana/pkg/models"
        "github.com/grafana/grafana/pkg/setting"
        "github.com/grafana/grafana/pkg/util"
)

// GET /api/org
func GetOrgCurrent(c *middleware.Context) Response <span class="cov0" title="0">{
        return getOrgHelper(c.OrgId)
}</span>

// GET /api/orgs/:orgId
func GetOrgById(c *middleware.Context) Response <span class="cov0" title="0">{
        return getOrgHelper(c.ParamsInt64(":orgId"))
}</span>

// Get /api/orgs/name/:name
func GetOrgByName(c *middleware.Context) Response <span class="cov0" title="0">{
        query := m.GetOrgByNameQuery{Name: c.Params(":name")}
        if err := bus.Dispatch(&amp;query); err != nil </span><span class="cov0" title="0">{
                if err == m.ErrOrgNotFound </span><span class="cov0" title="0">{
                        return ApiError(404, "Organization not found", err)
                }</span>

                <span class="cov0" title="0">return ApiError(500, "Failed to get organization", err)</span>
        }
        <span class="cov0" title="0">org := query.Result
        result := m.OrgDetailsDTO{
                Id:   org.Id,
                Name: org.Name,
                Address: m.Address{
                        Address1: org.Address1,
                        Address2: org.Address2,
                        City:     org.City,
                        ZipCode:  org.ZipCode,
                        State:    org.State,
                        Country:  org.Country,
                },
        }

        return Json(200, &amp;result)</span>
}

func getOrgHelper(orgId int64) Response <span class="cov0" title="0">{
        query := m.GetOrgByIdQuery{Id: orgId}

        if err := bus.Dispatch(&amp;query); err != nil </span><span class="cov0" title="0">{
                if err == m.ErrOrgNotFound </span><span class="cov0" title="0">{
                        return ApiError(404, "Organization not found", err)
                }</span>

                <span class="cov0" title="0">return ApiError(500, "Failed to get organization", err)</span>
        }

        <span class="cov0" title="0">org := query.Result
        result := m.OrgDetailsDTO{
                Id:   org.Id,
                Name: org.Name,
                Address: m.Address{
                        Address1: org.Address1,
                        Address2: org.Address2,
                        City:     org.City,
                        ZipCode:  org.ZipCode,
                        State:    org.State,
                        Country:  org.Country,
                },
        }

        return Json(200, &amp;result)</span>
}

// POST /api/orgs
func CreateOrg(c *middleware.Context, cmd m.CreateOrgCommand) Response <span class="cov0" title="0">{
        if !c.IsSignedIn || (!setting.AllowUserOrgCreate &amp;&amp; !c.IsGrafanaAdmin) </span><span class="cov0" title="0">{
                return ApiError(403, "Access denied", nil)
        }</span>

        <span class="cov0" title="0">cmd.UserId = c.UserId
        if err := bus.Dispatch(&amp;cmd); err != nil </span><span class="cov0" title="0">{
                if err == m.ErrOrgNameTaken </span><span class="cov0" title="0">{
                        return ApiError(409, "Organization name taken", err)
                }</span>
                <span class="cov0" title="0">return ApiError(500, "Failed to create organization", err)</span>
        }

        <span class="cov0" title="0">metrics.M_Api_Org_Create.Inc(1)

        return Json(200, &amp;util.DynMap{
                "orgId":   cmd.Result.Id,
                "message": "Organization created",
        })</span>
}

// PUT /api/org
func UpdateOrgCurrent(c *middleware.Context, form dtos.UpdateOrgForm) Response <span class="cov0" title="0">{
        return updateOrgHelper(form, c.OrgId)
}</span>

// PUT /api/orgs/:orgId
func UpdateOrg(c *middleware.Context, form dtos.UpdateOrgForm) Response <span class="cov0" title="0">{
        return updateOrgHelper(form, c.ParamsInt64(":orgId"))
}</span>

func updateOrgHelper(form dtos.UpdateOrgForm, orgId int64) Response <span class="cov0" title="0">{
        cmd := m.UpdateOrgCommand{Name: form.Name, OrgId: orgId}
        if err := bus.Dispatch(&amp;cmd); err != nil </span><span class="cov0" title="0">{
                if err == m.ErrOrgNameTaken </span><span class="cov0" title="0">{
                        return ApiError(400, "Organization name taken", err)
                }</span>
                <span class="cov0" title="0">return ApiError(500, "Failed to update organization", err)</span>
        }

        <span class="cov0" title="0">return ApiSuccess("Organization updated")</span>
}

// PUT /api/org/address
func UpdateOrgAddressCurrent(c *middleware.Context, form dtos.UpdateOrgAddressForm) Response <span class="cov0" title="0">{
        return updateOrgAddressHelper(form, c.OrgId)
}</span>

// PUT /api/orgs/:orgId/address
func UpdateOrgAddress(c *middleware.Context, form dtos.UpdateOrgAddressForm) Response <span class="cov0" title="0">{
        return updateOrgAddressHelper(form, c.ParamsInt64(":orgId"))
}</span>

func updateOrgAddressHelper(form dtos.UpdateOrgAddressForm, orgId int64) Response <span class="cov0" title="0">{
        cmd := m.UpdateOrgAddressCommand{
                OrgId: orgId,
                Address: m.Address{
                        Address1: form.Address1,
                        Address2: form.Address2,
                        City:     form.City,
                        State:    form.State,
                        ZipCode:  form.ZipCode,
                        Country:  form.Country,
                },
        }

        if err := bus.Dispatch(&amp;cmd); err != nil </span><span class="cov0" title="0">{
                return ApiError(500, "Failed to update org address", err)
        }</span>

        <span class="cov0" title="0">return ApiSuccess("Address updated")</span>
}

// GET /api/orgs/:orgId
func DeleteOrgById(c *middleware.Context) Response <span class="cov0" title="0">{
        if err := bus.Dispatch(&amp;m.DeleteOrgCommand{Id: c.ParamsInt64(":orgId")}); err != nil </span><span class="cov0" title="0">{
                if err == m.ErrOrgNotFound </span><span class="cov0" title="0">{
                        return ApiError(404, "Failed to delete organization. ID not found", nil)
                }</span>
                <span class="cov0" title="0">return ApiError(500, "Failed to update organization", err)</span>
        }
        <span class="cov0" title="0">return ApiSuccess("Organization deleted")</span>
}

func SearchOrgs(c *middleware.Context) Response <span class="cov0" title="0">{
        query := m.SearchOrgsQuery{
                Query: c.Query("query"),
                Name:  c.Query("name"),
                Page:  0,
                Limit: 1000,
        }

        if err := bus.Dispatch(&amp;query); err != nil </span><span class="cov0" title="0">{
                return ApiError(500, "Failed to search orgs", err)
        }</span>

        <span class="cov0" title="0">return Json(200, query.Result)</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package api

import (
        "fmt"

        "github.com/grafana/grafana/pkg/api/dtos"
        "github.com/grafana/grafana/pkg/bus"
        "github.com/grafana/grafana/pkg/events"
        "github.com/grafana/grafana/pkg/metrics"
        "github.com/grafana/grafana/pkg/middleware"
        m "github.com/grafana/grafana/pkg/models"
        "github.com/grafana/grafana/pkg/setting"
        "github.com/grafana/grafana/pkg/util"
)

func GetPendingOrgInvites(c *middleware.Context) Response <span class="cov0" title="0">{
        query := m.GetTempUsersQuery{OrgId: c.OrgId, Status: m.TmpUserInvitePending}

        if err := bus.Dispatch(&amp;query); err != nil </span><span class="cov0" title="0">{
                return ApiError(500, "Failed to get invites from db", err)
        }</span>

        <span class="cov0" title="0">for _, invite := range query.Result </span><span class="cov0" title="0">{
                invite.Url = setting.ToAbsUrl("invite/" + invite.Code)
        }</span>

        <span class="cov0" title="0">return Json(200, query.Result)</span>
}

func AddOrgInvite(c *middleware.Context, inviteDto dtos.AddInviteForm) Response <span class="cov0" title="0">{
        if !inviteDto.Role.IsValid() </span><span class="cov0" title="0">{
                return ApiError(400, "Invalid role specified", nil)
        }</span>

        // first try get existing user
        <span class="cov0" title="0">userQuery := m.GetUserByLoginQuery{LoginOrEmail: inviteDto.LoginOrEmail}
        if err := bus.Dispatch(&amp;userQuery); err != nil </span><span class="cov0" title="0">{
                if err != m.ErrUserNotFound </span><span class="cov0" title="0">{
                        return ApiError(500, "Failed to query db for existing user check", err)
                }</span>
        }<span class="cov0" title="0"> else {
                return inviteExistingUserToOrg(c, userQuery.Result, &amp;inviteDto)
        }</span>

        <span class="cov0" title="0">cmd := m.CreateTempUserCommand{}
        cmd.OrgId = c.OrgId
        cmd.Email = inviteDto.LoginOrEmail
        cmd.Name = inviteDto.Name
        cmd.Status = m.TmpUserInvitePending
        cmd.InvitedByUserId = c.UserId
        cmd.Code = util.GetRandomString(30)
        cmd.Role = inviteDto.Role
        cmd.RemoteAddr = c.Req.RemoteAddr

        if err := bus.Dispatch(&amp;cmd); err != nil </span><span class="cov0" title="0">{
                return ApiError(500, "Failed to save invite to database", err)
        }</span>

        // send invite email
        <span class="cov0" title="0">if !inviteDto.SkipEmails &amp;&amp; util.IsEmail(inviteDto.LoginOrEmail) </span><span class="cov0" title="0">{
                emailCmd := m.SendEmailCommand{
                        To:       []string{inviteDto.LoginOrEmail},
                        Template: "new_user_invite.html",
                        Data: map[string]interface{}{
                                "Name":      util.StringsFallback2(cmd.Name, cmd.Email),
                                "OrgName":   c.OrgName,
                                "Email":     c.Email,
                                "LinkUrl":   setting.ToAbsUrl("invite/" + cmd.Code),
                                "InvitedBy": util.StringsFallback3(c.Name, c.Email, c.Login),
                        },
                }

                if err := bus.Dispatch(&amp;emailCmd); err != nil </span><span class="cov0" title="0">{
                        return ApiError(500, "Failed to send email invite", err)
                }</span>

                <span class="cov0" title="0">return ApiSuccess(fmt.Sprintf("Sent invite to %s", inviteDto.LoginOrEmail))</span>
        }

        <span class="cov0" title="0">return ApiSuccess(fmt.Sprintf("Created invite for %s", inviteDto.LoginOrEmail))</span>
}

func inviteExistingUserToOrg(c *middleware.Context, user *m.User, inviteDto *dtos.AddInviteForm) Response <span class="cov0" title="0">{
        // user exists, add org role
        createOrgUserCmd := m.AddOrgUserCommand{OrgId: c.OrgId, UserId: user.Id, Role: inviteDto.Role}
        if err := bus.Dispatch(&amp;createOrgUserCmd); err != nil </span><span class="cov0" title="0">{
                if err == m.ErrOrgUserAlreadyAdded </span><span class="cov0" title="0">{
                        return ApiError(412, fmt.Sprintf("User %s is already added to organization", inviteDto.LoginOrEmail), err)
                }</span>
                <span class="cov0" title="0">return ApiError(500, "Error while trying to create org user", err)</span>
        }<span class="cov0" title="0"> else {

                if !inviteDto.SkipEmails &amp;&amp; util.IsEmail(user.Email) </span><span class="cov0" title="0">{
                        emailCmd := m.SendEmailCommand{
                                To:       []string{user.Email},
                                Template: "invited_to_org.html",
                                Data: map[string]interface{}{
                                        "Name":      user.NameOrFallback(),
                                        "OrgName":   c.OrgName,
                                        "InvitedBy": util.StringsFallback3(c.Name, c.Email, c.Login),
                                },
                        }

                        if err := bus.Dispatch(&amp;emailCmd); err != nil </span><span class="cov0" title="0">{
                                return ApiError(500, "Failed to send email invited_to_org", err)
                        }</span>
                }

                <span class="cov0" title="0">return ApiSuccess(fmt.Sprintf("Existing Grafana user %s added to org %s", user.NameOrFallback(), c.OrgName))</span>
        }
}

func RevokeInvite(c *middleware.Context) Response <span class="cov0" title="0">{
        if ok, rsp := updateTempUserStatus(c.Params(":code"), m.TmpUserRevoked); !ok </span><span class="cov0" title="0">{
                return rsp
        }</span>

        <span class="cov0" title="0">return ApiSuccess("Invite revoked")</span>
}

func GetInviteInfoByCode(c *middleware.Context) Response <span class="cov0" title="0">{
        query := m.GetTempUserByCodeQuery{Code: c.Params(":code")}

        if err := bus.Dispatch(&amp;query); err != nil </span><span class="cov0" title="0">{
                if err == m.ErrTempUserNotFound </span><span class="cov0" title="0">{
                        return ApiError(404, "Invite not found", nil)
                }</span>
                <span class="cov0" title="0">return ApiError(500, "Failed to get invite", err)</span>
        }

        <span class="cov0" title="0">invite := query.Result

        return Json(200, dtos.InviteInfo{
                Email:     invite.Email,
                Name:      invite.Name,
                Username:  invite.Email,
                InvitedBy: util.StringsFallback3(invite.InvitedByName, invite.InvitedByLogin, invite.InvitedByEmail),
        })</span>
}

func CompleteInvite(c *middleware.Context, completeInvite dtos.CompleteInviteForm) Response <span class="cov0" title="0">{
        query := m.GetTempUserByCodeQuery{Code: completeInvite.InviteCode}

        if err := bus.Dispatch(&amp;query); err != nil </span><span class="cov0" title="0">{
                if err == m.ErrTempUserNotFound </span><span class="cov0" title="0">{
                        return ApiError(404, "Invite not found", nil)
                }</span>
                <span class="cov0" title="0">return ApiError(500, "Failed to get invite", err)</span>
        }

        <span class="cov0" title="0">invite := query.Result
        if invite.Status != m.TmpUserInvitePending </span><span class="cov0" title="0">{
                return ApiError(412, fmt.Sprintf("Invite cannot be used in status %s", invite.Status), nil)
        }</span>

        <span class="cov0" title="0">cmd := m.CreateUserCommand{
                Email:        completeInvite.Email,
                Name:         completeInvite.Name,
                Login:        completeInvite.Username,
                Password:     completeInvite.Password,
                SkipOrgSetup: true,
        }

        if err := bus.Dispatch(&amp;cmd); err != nil </span><span class="cov0" title="0">{
                return ApiError(500, "failed to create user", err)
        }</span>

        <span class="cov0" title="0">user := &amp;cmd.Result

        bus.Publish(&amp;events.SignUpCompleted{
                Name:  user.NameOrFallback(),
                Email: user.Email,
        })

        if ok, rsp := applyUserInvite(user, invite, true); !ok </span><span class="cov0" title="0">{
                return rsp
        }</span>

        <span class="cov0" title="0">loginUserWithUser(user, c)

        metrics.M_Api_User_SignUpCompleted.Inc(1)
        metrics.M_Api_User_SignUpInvite.Inc(1)

        return ApiSuccess("User created and logged in")</span>
}

func updateTempUserStatus(code string, status m.TempUserStatus) (bool, Response) <span class="cov0" title="0">{
        // update temp user status
        updateTmpUserCmd := m.UpdateTempUserStatusCommand{Code: code, Status: status}
        if err := bus.Dispatch(&amp;updateTmpUserCmd); err != nil </span><span class="cov0" title="0">{
                return false, ApiError(500, "Failed to update invite status", err)
        }</span>

        <span class="cov0" title="0">return true, nil</span>
}

func applyUserInvite(user *m.User, invite *m.TempUserDTO, setActive bool) (bool, Response) <span class="cov0" title="0">{
        // add to org
        addOrgUserCmd := m.AddOrgUserCommand{OrgId: invite.OrgId, UserId: user.Id, Role: invite.Role}
        if err := bus.Dispatch(&amp;addOrgUserCmd); err != nil </span><span class="cov0" title="0">{
                if err != m.ErrOrgUserAlreadyAdded </span><span class="cov0" title="0">{
                        return false, ApiError(500, "Error while trying to create org user", err)
                }</span>
        }

        // update temp user status
        <span class="cov0" title="0">if ok, rsp := updateTempUserStatus(invite.Code, m.TmpUserCompleted); !ok </span><span class="cov0" title="0">{
                return false, rsp
        }</span>

        <span class="cov0" title="0">if setActive </span><span class="cov0" title="0">{
                // set org to active
                if err := bus.Dispatch(&amp;m.SetUsingOrgCommand{OrgId: invite.OrgId, UserId: user.Id}); err != nil </span><span class="cov0" title="0">{
                        return false, ApiError(500, "Failed to set org as active", err)
                }</span>
        }

        <span class="cov0" title="0">return true, nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package api

import (
        "github.com/grafana/grafana/pkg/bus"
        "github.com/grafana/grafana/pkg/middleware"
        m "github.com/grafana/grafana/pkg/models"
)

// POST /api/org/users
func AddOrgUserToCurrentOrg(c *middleware.Context, cmd m.AddOrgUserCommand) Response <span class="cov0" title="0">{
        cmd.OrgId = c.OrgId
        return addOrgUserHelper(cmd)
}</span>

// POST /api/orgs/:orgId/users
func AddOrgUser(c *middleware.Context, cmd m.AddOrgUserCommand) Response <span class="cov0" title="0">{
        cmd.OrgId = c.ParamsInt64(":orgId")
        return addOrgUserHelper(cmd)
}</span>

func addOrgUserHelper(cmd m.AddOrgUserCommand) Response <span class="cov0" title="0">{
        if !cmd.Role.IsValid() </span><span class="cov0" title="0">{
                return ApiError(400, "Invalid role specified", nil)
        }</span>

        <span class="cov0" title="0">userQuery := m.GetUserByLoginQuery{LoginOrEmail: cmd.LoginOrEmail}
        err := bus.Dispatch(&amp;userQuery)
        if err != nil </span><span class="cov0" title="0">{
                return ApiError(404, "User not found", nil)
        }</span>

        <span class="cov0" title="0">userToAdd := userQuery.Result

        // if userToAdd.Id == c.UserId {
        //         return ApiError(400, "Cannot add yourself as user", nil)
        // }

        cmd.UserId = userToAdd.Id

        if err := bus.Dispatch(&amp;cmd); err != nil </span><span class="cov0" title="0">{
                if err == m.ErrOrgUserAlreadyAdded </span><span class="cov0" title="0">{
                        return ApiError(409, "User is already member of this organization", nil)
                }</span>
                <span class="cov0" title="0">return ApiError(500, "Could not add user to organization", err)</span>
        }

        <span class="cov0" title="0">return ApiSuccess("User added to organization")</span>
}

// GET /api/org/users
func GetOrgUsersForCurrentOrg(c *middleware.Context) Response <span class="cov0" title="0">{
        return getOrgUsersHelper(c.OrgId)
}</span>

// GET /api/orgs/:orgId/users
func GetOrgUsers(c *middleware.Context) Response <span class="cov0" title="0">{
        return getOrgUsersHelper(c.ParamsInt64(":orgId"))
}</span>

func getOrgUsersHelper(orgId int64) Response <span class="cov0" title="0">{
        query := m.GetOrgUsersQuery{OrgId: orgId}

        if err := bus.Dispatch(&amp;query); err != nil </span><span class="cov0" title="0">{
                return ApiError(500, "Failed to get account user", err)
        }</span>

        <span class="cov0" title="0">return Json(200, query.Result)</span>
}

// PATCH /api/org/users/:userId
func UpdateOrgUserForCurrentOrg(c *middleware.Context, cmd m.UpdateOrgUserCommand) Response <span class="cov0" title="0">{
        cmd.OrgId = c.OrgId
        cmd.UserId = c.ParamsInt64(":userId")
        return updateOrgUserHelper(cmd)
}</span>

// PATCH /api/orgs/:orgId/users/:userId
func UpdateOrgUser(c *middleware.Context, cmd m.UpdateOrgUserCommand) Response <span class="cov0" title="0">{
        cmd.OrgId = c.ParamsInt64(":orgId")
        cmd.UserId = c.ParamsInt64(":userId")
        return updateOrgUserHelper(cmd)
}</span>

func updateOrgUserHelper(cmd m.UpdateOrgUserCommand) Response <span class="cov0" title="0">{
        if !cmd.Role.IsValid() </span><span class="cov0" title="0">{
                return ApiError(400, "Invalid role specified", nil)
        }</span>

        <span class="cov0" title="0">if err := bus.Dispatch(&amp;cmd); err != nil </span><span class="cov0" title="0">{
                if err == m.ErrLastOrgAdmin </span><span class="cov0" title="0">{
                        return ApiError(400, "Cannot change role so that there is no organization admin left", nil)
                }</span>
                <span class="cov0" title="0">return ApiError(500, "Failed update org user", err)</span>
        }

        <span class="cov0" title="0">return ApiSuccess("Organization user updated")</span>
}

// DELETE /api/org/users/:userId
func RemoveOrgUserForCurrentOrg(c *middleware.Context) Response <span class="cov0" title="0">{
        userId := c.ParamsInt64(":userId")
        return removeOrgUserHelper(c.OrgId, userId)
}</span>

// DELETE /api/orgs/:orgId/users/:userId
func RemoveOrgUser(c *middleware.Context) Response <span class="cov0" title="0">{
        userId := c.ParamsInt64(":userId")
        orgId := c.ParamsInt64(":orgId")
        return removeOrgUserHelper(orgId, userId)
}</span>

func removeOrgUserHelper(orgId int64, userId int64) Response <span class="cov0" title="0">{
        cmd := m.RemoveOrgUserCommand{OrgId: orgId, UserId: userId}

        if err := bus.Dispatch(&amp;cmd); err != nil </span><span class="cov0" title="0">{
                if err == m.ErrLastOrgAdmin </span><span class="cov0" title="0">{
                        return ApiError(400, "Cannot remove last organization admin", nil)
                }</span>
                <span class="cov0" title="0">return ApiError(500, "Failed to remove user from organization", err)</span>
        }

        <span class="cov0" title="0">return ApiSuccess("User removed from organization")</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package api

import (
        "github.com/grafana/grafana/pkg/api/dtos"
        "github.com/grafana/grafana/pkg/bus"
        "github.com/grafana/grafana/pkg/middleware"
        m "github.com/grafana/grafana/pkg/models"
        "github.com/grafana/grafana/pkg/util"
)

func SendResetPasswordEmail(c *middleware.Context, form dtos.SendResetPasswordEmailForm) Response <span class="cov0" title="0">{
        userQuery := m.GetUserByLoginQuery{LoginOrEmail: form.UserOrEmail}

        if err := bus.Dispatch(&amp;userQuery); err != nil </span><span class="cov0" title="0">{
                return ApiError(404, "User does not exist", err)
        }</span>

        <span class="cov0" title="0">emailCmd := m.SendResetPasswordEmailCommand{User: userQuery.Result}
        if err := bus.Dispatch(&amp;emailCmd); err != nil </span><span class="cov0" title="0">{
                return ApiError(500, "Failed to send email", err)
        }</span>

        <span class="cov0" title="0">return ApiSuccess("Email sent")</span>
}

func ResetPassword(c *middleware.Context, form dtos.ResetUserPasswordForm) Response <span class="cov0" title="0">{
        query := m.ValidateResetPasswordCodeQuery{Code: form.Code}

        if err := bus.Dispatch(&amp;query); err != nil </span><span class="cov0" title="0">{
                if err == m.ErrInvalidEmailCode </span><span class="cov0" title="0">{
                        return ApiError(400, "Invalid or expired reset password code", nil)
                }</span>
                <span class="cov0" title="0">return ApiError(500, "Unknown error validating email code", err)</span>
        }

        <span class="cov0" title="0">if form.NewPassword != form.ConfirmPassword </span><span class="cov0" title="0">{
                return ApiError(400, "Passwords do not match", nil)
        }</span>

        <span class="cov0" title="0">cmd := m.ChangeUserPasswordCommand{}
        cmd.UserId = query.Result.Id
        cmd.NewPassword = util.EncodePassword(form.NewPassword, query.Result.Salt)

        if err := bus.Dispatch(&amp;cmd); err != nil </span><span class="cov0" title="0">{
                return ApiError(500, "Failed to change user password", err)
        }</span>

        <span class="cov0" title="0">return ApiSuccess("User password changed")</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package api

import (
        "github.com/grafana/grafana/pkg/bus"
        _ "github.com/grafana/grafana/pkg/log"
        "github.com/grafana/grafana/pkg/middleware"
        m "github.com/grafana/grafana/pkg/models"
)

func ValidateOrgPlaylist(c *middleware.Context) <span class="cov0" title="0">{
        id := c.ParamsInt64(":id")
        query := m.GetPlaylistByIdQuery{Id: id}
        err := bus.Dispatch(&amp;query)

        if err != nil </span><span class="cov0" title="0">{
                c.JsonApiErr(404, "Playlist not found", err)
                return
        }</span>

        <span class="cov0" title="0">if query.Result.OrgId == 0 </span><span class="cov0" title="0">{
                c.JsonApiErr(404, "Playlist not found", err)
                return
        }</span>

        <span class="cov0" title="0">if query.Result.OrgId != c.OrgId </span><span class="cov0" title="0">{
                c.JsonApiErr(403, "You are not allowed to edit/view playlist", nil)
                return
        }</span>

        <span class="cov0" title="0">items, itemsErr := LoadPlaylistItemDTOs(id)

        if itemsErr != nil </span><span class="cov0" title="0">{
                c.JsonApiErr(404, "Playlist items not found", err)
                return
        }</span>

        <span class="cov0" title="0">if len(items) == 0 </span><span class="cov0" title="0">{
                c.JsonApiErr(404, "Playlist is empty", itemsErr)
                return
        }</span>
}

func SearchPlaylists(c *middleware.Context) Response <span class="cov0" title="0">{
        query := c.Query("query")
        limit := c.QueryInt("limit")

        if limit == 0 </span><span class="cov0" title="0">{
                limit = 1000
        }</span>

        <span class="cov0" title="0">searchQuery := m.GetPlaylistsQuery{
                Name:  query,
                Limit: limit,
                OrgId: c.OrgId,
        }

        err := bus.Dispatch(&amp;searchQuery)
        if err != nil </span><span class="cov0" title="0">{
                return ApiError(500, "Search failed", err)
        }</span>

        <span class="cov0" title="0">return Json(200, searchQuery.Result)</span>
}

func GetPlaylist(c *middleware.Context) Response <span class="cov0" title="0">{
        id := c.ParamsInt64(":id")
        cmd := m.GetPlaylistByIdQuery{Id: id}

        if err := bus.Dispatch(&amp;cmd); err != nil </span><span class="cov0" title="0">{
                return ApiError(500, "Playlist not found", err)
        }</span>

        <span class="cov0" title="0">playlistDTOs, _ := LoadPlaylistItemDTOs(id)

        dto := &amp;m.PlaylistDTO{
                Id:       cmd.Result.Id,
                Name:     cmd.Result.Name,
                Interval: cmd.Result.Interval,
                OrgId:    cmd.Result.OrgId,
                Items:    playlistDTOs,
        }

        return Json(200, dto)</span>
}

func LoadPlaylistItemDTOs(id int64) ([]m.PlaylistItemDTO, error) <span class="cov0" title="0">{
        playlistitems, err := LoadPlaylistItems(id)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">playlistDTOs := make([]m.PlaylistItemDTO, 0)

        for _, item := range playlistitems </span><span class="cov0" title="0">{
                playlistDTOs = append(playlistDTOs, m.PlaylistItemDTO{
                        Id:         item.Id,
                        PlaylistId: item.PlaylistId,
                        Type:       item.Type,
                        Value:      item.Value,
                        Order:      item.Order,
                        Title:      item.Title,
                })
        }</span>

        <span class="cov0" title="0">return playlistDTOs, nil</span>
}

func LoadPlaylistItems(id int64) ([]m.PlaylistItem, error) <span class="cov0" title="0">{
        itemQuery := m.GetPlaylistItemsByIdQuery{PlaylistId: id}
        if err := bus.Dispatch(&amp;itemQuery); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return *itemQuery.Result, nil</span>
}

func GetPlaylistItems(c *middleware.Context) Response <span class="cov0" title="0">{
        id := c.ParamsInt64(":id")

        playlistDTOs, err := LoadPlaylistItemDTOs(id)

        if err != nil </span><span class="cov0" title="0">{
                return ApiError(500, "Could not load playlist items", err)
        }</span>

        <span class="cov0" title="0">return Json(200, playlistDTOs)</span>
}

func GetPlaylistDashboards(c *middleware.Context) Response <span class="cov0" title="0">{
        playlistId := c.ParamsInt64(":id")

        playlists, err := LoadPlaylistDashboards(c.OrgId, c.UserId, playlistId)
        if err != nil </span><span class="cov0" title="0">{
                return ApiError(500, "Could not load dashboards", err)
        }</span>

        <span class="cov0" title="0">return Json(200, playlists)</span>
}

func DeletePlaylist(c *middleware.Context) Response <span class="cov0" title="0">{
        id := c.ParamsInt64(":id")

        cmd := m.DeletePlaylistCommand{Id: id, OrgId: c.OrgId}
        if err := bus.Dispatch(&amp;cmd); err != nil </span><span class="cov0" title="0">{
                return ApiError(500, "Failed to delete playlist", err)
        }</span>

        <span class="cov0" title="0">return Json(200, "")</span>
}

func CreatePlaylist(c *middleware.Context, cmd m.CreatePlaylistCommand) Response <span class="cov0" title="0">{
        cmd.OrgId = c.OrgId

        if err := bus.Dispatch(&amp;cmd); err != nil </span><span class="cov0" title="0">{
                return ApiError(500, "Failed to create playlist", err)
        }</span>

        <span class="cov0" title="0">return Json(200, cmd.Result)</span>
}

func UpdatePlaylist(c *middleware.Context, cmd m.UpdatePlaylistCommand) Response <span class="cov0" title="0">{
        cmd.OrgId = c.OrgId

        if err := bus.Dispatch(&amp;cmd); err != nil </span><span class="cov0" title="0">{
                return ApiError(500, "Failed to save playlist", err)
        }</span>

        <span class="cov0" title="0">playlistDTOs, err := LoadPlaylistItemDTOs(cmd.Id)
        if err != nil </span><span class="cov0" title="0">{
                return ApiError(500, "Failed to save playlist", err)
        }</span>

        <span class="cov0" title="0">cmd.Result.Items = playlistDTOs
        return Json(200, cmd.Result)</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package api

import (
        "sort"
        "strconv"

        "github.com/grafana/grafana/pkg/api/dtos"
        "github.com/grafana/grafana/pkg/bus"
        _ "github.com/grafana/grafana/pkg/log"
        m "github.com/grafana/grafana/pkg/models"
        "github.com/grafana/grafana/pkg/services/search"
)

func populateDashboardsById(dashboardByIds []int64, dashboardIdOrder map[int64]int) (dtos.PlaylistDashboardsSlice, error) <span class="cov0" title="0">{
        result := make(dtos.PlaylistDashboardsSlice, 0)

        if len(dashboardByIds) &gt; 0 </span><span class="cov0" title="0">{
                dashboardQuery := m.GetDashboardsQuery{DashboardIds: dashboardByIds}
                if err := bus.Dispatch(&amp;dashboardQuery); err != nil </span><span class="cov0" title="0">{
                        return result, err
                }</span>

                <span class="cov0" title="0">for _, item := range dashboardQuery.Result </span><span class="cov0" title="0">{
                        result = append(result, dtos.PlaylistDashboard{
                                Id:    item.Id,
                                Slug:  item.Slug,
                                Title: item.Title,
                                Uri:   "db/" + item.Slug,
                                Order: dashboardIdOrder[item.Id],
                        })
                }</span>
        }

        <span class="cov0" title="0">return result, nil</span>
}

func populateDashboardsByTag(orgId, userId int64, dashboardByTag []string, dashboardTagOrder map[string]int) dtos.PlaylistDashboardsSlice <span class="cov0" title="0">{
        result := make(dtos.PlaylistDashboardsSlice, 0)

        if len(dashboardByTag) &gt; 0 </span><span class="cov0" title="0">{
                for _, tag := range dashboardByTag </span><span class="cov0" title="0">{
                        searchQuery := search.Query{
                                Title:     "",
                                Tags:      []string{tag},
                                UserId:    userId,
                                Limit:     100,
                                IsStarred: false,
                                OrgId:     orgId,
                        }

                        if err := bus.Dispatch(&amp;searchQuery); err == nil </span><span class="cov0" title="0">{
                                for _, item := range searchQuery.Result </span><span class="cov0" title="0">{
                                        result = append(result, dtos.PlaylistDashboard{
                                                Id:    item.Id,
                                                Title: item.Title,
                                                Uri:   item.Uri,
                                                Order: dashboardTagOrder[tag],
                                        })
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return result</span>
}

func LoadPlaylistDashboards(orgId, userId, playlistId int64) (dtos.PlaylistDashboardsSlice, error) <span class="cov0" title="0">{
        playlistItems, _ := LoadPlaylistItems(playlistId)

        dashboardByIds := make([]int64, 0)
        dashboardByTag := make([]string, 0)
        dashboardIdOrder := make(map[int64]int)
        dashboardTagOrder := make(map[string]int)

        for _, i := range playlistItems </span><span class="cov0" title="0">{
                if i.Type == "dashboard_by_id" </span><span class="cov0" title="0">{
                        dashboardId, _ := strconv.ParseInt(i.Value, 10, 64)
                        dashboardByIds = append(dashboardByIds, dashboardId)
                        dashboardIdOrder[dashboardId] = i.Order
                }</span>

                <span class="cov0" title="0">if i.Type == "dashboard_by_tag" </span><span class="cov0" title="0">{
                        dashboardByTag = append(dashboardByTag, i.Value)
                        dashboardTagOrder[i.Value] = i.Order
                }</span>
        }

        <span class="cov0" title="0">result := make(dtos.PlaylistDashboardsSlice, 0)

        var k, _ = populateDashboardsById(dashboardByIds, dashboardIdOrder)
        result = append(result, k...)
        result = append(result, populateDashboardsByTag(orgId, userId, dashboardByTag, dashboardTagOrder)...)

        sort.Sort(sort.Reverse(result))
        return result, nil</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package pluginproxy

import (
        "bytes"
        "encoding/json"
        "errors"
        "fmt"
        "net/http"
        "net/http/httputil"
        "net/url"
        "text/template"

        "github.com/grafana/grafana/pkg/bus"
        "github.com/grafana/grafana/pkg/log"
        "github.com/grafana/grafana/pkg/middleware"
        m "github.com/grafana/grafana/pkg/models"
        "github.com/grafana/grafana/pkg/plugins"
        "github.com/grafana/grafana/pkg/util"
)

type templateData struct {
        JsonData       map[string]interface{}
        SecureJsonData map[string]string
}

func getHeaders(route *plugins.AppPluginRoute, orgId int64, appId string) (http.Header, error) <span class="cov8" title="1">{
        result := http.Header{}

        query := m.GetPluginSettingByIdQuery{OrgId: orgId, PluginId: appId}

        if err := bus.Dispatch(&amp;query); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">data := templateData{
                JsonData:       query.Result.JsonData,
                SecureJsonData: query.Result.SecureJsonData.Decrypt(),
        }

        for _, header := range route.Headers </span><span class="cov8" title="1">{
                var contentBuf bytes.Buffer
                t, err := template.New("content").Parse(header.Content)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.New(fmt.Sprintf("could not parse header content template for header %s.", header.Name))
                }</span>

                <span class="cov8" title="1">err = t.Execute(&amp;contentBuf, data)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.New(fmt.Sprintf("failed to execute header content template for header %s.", header.Name))
                }</span>

                <span class="cov8" title="1">log.Trace("Adding header to proxy request. %s: %s", header.Name, contentBuf.String())
                result.Add(header.Name, contentBuf.String())</span>
        }

        <span class="cov8" title="1">return result, nil</span>
}

func NewApiPluginProxy(ctx *middleware.Context, proxyPath string, route *plugins.AppPluginRoute, appId string) *httputil.ReverseProxy <span class="cov0" title="0">{
        targetUrl, _ := url.Parse(route.Url)

        director := func(req *http.Request) </span><span class="cov0" title="0">{

                req.URL.Scheme = targetUrl.Scheme
                req.URL.Host = targetUrl.Host
                req.Host = targetUrl.Host

                req.URL.Path = util.JoinUrlFragments(targetUrl.Path, proxyPath)

                // clear cookie headers
                req.Header.Del("Cookie")
                req.Header.Del("Set-Cookie")

                //Create a HTTP header with the context in it.
                ctxJson, err := json.Marshal(ctx.SignedInUser)
                if err != nil </span><span class="cov0" title="0">{
                        ctx.JsonApiErr(500, "failed to marshal context to json.", err)
                        return
                }</span>

                <span class="cov0" title="0">req.Header.Add("X-Grafana-Context", string(ctxJson))

                if len(route.Headers) &gt; 0 </span><span class="cov0" title="0">{
                        headers, err := getHeaders(route, ctx.OrgId, appId)
                        if err != nil </span><span class="cov0" title="0">{
                                ctx.JsonApiErr(500, "Could not generate plugin route header", err)
                                return
                        }</span>

                        <span class="cov0" title="0">for key, value := range headers </span><span class="cov0" title="0">{
                                log.Trace("setting key %v value %v", key, value[0])
                                req.Header.Set(key, value[0])
                        }</span>
                }

        }

        <span class="cov0" title="0">return &amp;httputil.ReverseProxy{Director: director}</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package api

import (
        "sort"

        "github.com/grafana/grafana/pkg/api/dtos"
        "github.com/grafana/grafana/pkg/bus"
        "github.com/grafana/grafana/pkg/middleware"
        m "github.com/grafana/grafana/pkg/models"
        "github.com/grafana/grafana/pkg/plugins"
        "github.com/grafana/grafana/pkg/setting"
)

func GetPluginList(c *middleware.Context) Response <span class="cov0" title="0">{
        typeFilter := c.Query("type")
        enabledFilter := c.Query("enabled")
        embeddedFilter := c.Query("embedded")
        coreFilter := c.Query("core")

        pluginSettingsMap, err := plugins.GetPluginSettings(c.OrgId)

        if err != nil </span><span class="cov0" title="0">{
                return ApiError(500, "Failed to get list of plugins", err)
        }</span>

        <span class="cov0" title="0">result := make(dtos.PluginList, 0)
        for _, pluginDef := range plugins.Plugins </span><span class="cov0" title="0">{
                // filter out app sub plugins
                if embeddedFilter == "0" &amp;&amp; pluginDef.IncludedInAppId != "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                // filter out core plugins
                <span class="cov0" title="0">if coreFilter == "0" &amp;&amp; pluginDef.IsCorePlugin </span><span class="cov0" title="0">{
                        continue</span>
                }

                // filter on type
                <span class="cov0" title="0">if typeFilter != "" &amp;&amp; typeFilter != pluginDef.Type </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">listItem := dtos.PluginListItem{
                        Id:            pluginDef.Id,
                        Name:          pluginDef.Name,
                        Type:          pluginDef.Type,
                        Info:          &amp;pluginDef.Info,
                        LatestVersion: pluginDef.GrafanaNetVersion,
                        HasUpdate:     pluginDef.GrafanaNetHasUpdate,
                        DefaultNavUrl: pluginDef.DefaultNavUrl,
                }

                if pluginSetting, exists := pluginSettingsMap[pluginDef.Id]; exists </span><span class="cov0" title="0">{
                        listItem.Enabled = pluginSetting.Enabled
                        listItem.Pinned = pluginSetting.Pinned
                }</span>

                <span class="cov0" title="0">if listItem.DefaultNavUrl == "" || !listItem.Enabled </span><span class="cov0" title="0">{
                        listItem.DefaultNavUrl = setting.AppSubUrl + "/plugins/" + listItem.Id + "/edit"
                }</span>

                // filter out disabled
                <span class="cov0" title="0">if enabledFilter == "1" &amp;&amp; !listItem.Enabled </span><span class="cov0" title="0">{
                        continue</span>
                }

                // filter out built in data sources
                <span class="cov0" title="0">if ds, exists := plugins.DataSources[pluginDef.Id]; exists </span><span class="cov0" title="0">{
                        if ds.BuiltIn </span><span class="cov0" title="0">{
                                continue</span>
                        }
                }

                <span class="cov0" title="0">result = append(result, listItem)</span>
        }

        <span class="cov0" title="0">sort.Sort(result)
        return Json(200, result)</span>
}

func GetPluginSettingById(c *middleware.Context) Response <span class="cov0" title="0">{
        pluginId := c.Params(":pluginId")

        if def, exists := plugins.Plugins[pluginId]; !exists </span><span class="cov0" title="0">{
                return ApiError(404, "Plugin not found, no installed plugin with that id", nil)
        }</span><span class="cov0" title="0"> else {

                dto := &amp;dtos.PluginSetting{
                        Type:          def.Type,
                        Id:            def.Id,
                        Name:          def.Name,
                        Info:          &amp;def.Info,
                        Dependencies:  &amp;def.Dependencies,
                        Includes:      def.Includes,
                        BaseUrl:       def.BaseUrl,
                        Module:        def.Module,
                        DefaultNavUrl: def.DefaultNavUrl,
                        LatestVersion: def.GrafanaNetVersion,
                        HasUpdate:     def.GrafanaNetHasUpdate,
                }

                query := m.GetPluginSettingByIdQuery{PluginId: pluginId, OrgId: c.OrgId}
                if err := bus.Dispatch(&amp;query); err != nil </span><span class="cov0" title="0">{
                        if err != m.ErrPluginSettingNotFound </span><span class="cov0" title="0">{
                                return ApiError(500, "Failed to get login settings", nil)
                        }</span>
                }<span class="cov0" title="0"> else {
                        dto.Enabled = query.Result.Enabled
                        dto.Pinned = query.Result.Pinned
                        dto.JsonData = query.Result.JsonData
                }</span>

                <span class="cov0" title="0">return Json(200, dto)</span>
        }
}

func UpdatePluginSetting(c *middleware.Context, cmd m.UpdatePluginSettingCmd) Response <span class="cov0" title="0">{
        pluginId := c.Params(":pluginId")

        cmd.OrgId = c.OrgId
        cmd.PluginId = pluginId

        if _, ok := plugins.Apps[cmd.PluginId]; !ok </span><span class="cov0" title="0">{
                return ApiError(404, "Plugin not installed.", nil)
        }</span>

        <span class="cov0" title="0">if err := bus.Dispatch(&amp;cmd); err != nil </span><span class="cov0" title="0">{
                return ApiError(500, "Failed to update plugin setting", err)
        }</span>

        <span class="cov0" title="0">return ApiSuccess("Plugin settings updated")</span>
}

func GetPluginDashboards(c *middleware.Context) Response <span class="cov0" title="0">{
        pluginId := c.Params(":pluginId")

        if list, err := plugins.GetPluginDashboards(c.OrgId, pluginId); err != nil </span><span class="cov0" title="0">{
                if notfound, ok := err.(plugins.PluginNotFoundError); ok </span><span class="cov0" title="0">{
                        return ApiError(404, notfound.Error(), nil)
                }</span>

                <span class="cov0" title="0">return ApiError(500, "Failed to get plugin dashboards", err)</span>
        }<span class="cov0" title="0"> else {
                return Json(200, list)
        }</span>
}

func GetPluginReadme(c *middleware.Context) Response <span class="cov0" title="0">{
        pluginId := c.Params(":pluginId")

        if content, err := plugins.GetPluginReadme(pluginId); err != nil </span><span class="cov0" title="0">{
                if notfound, ok := err.(plugins.PluginNotFoundError); ok </span><span class="cov0" title="0">{
                        return ApiError(404, notfound.Error(), nil)
                }</span>

                <span class="cov0" title="0">return ApiError(500, "Could not get readme", err)</span>
        }<span class="cov0" title="0"> else {
                return Respond(200, content)
        }</span>
}

func ImportDashboard(c *middleware.Context, apiCmd dtos.ImportDashboardCommand) Response <span class="cov0" title="0">{

        cmd := plugins.ImportDashboardCommand{
                OrgId:     c.OrgId,
                UserId:    c.UserId,
                PluginId:  apiCmd.PluginId,
                Path:      apiCmd.Path,
                Inputs:    apiCmd.Inputs,
                Overwrite: apiCmd.Overwrite,
                Dashboard: apiCmd.Dashboard,
        }

        if err := bus.Dispatch(&amp;cmd); err != nil </span><span class="cov0" title="0">{
                return ApiError(500, "Failed to import dashboard", err)
        }</span>

        <span class="cov0" title="0">return Json(200, cmd.Result)</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package api

import (
        "github.com/grafana/grafana/pkg/api/dtos"
        "github.com/grafana/grafana/pkg/bus"
        "github.com/grafana/grafana/pkg/middleware"
        m "github.com/grafana/grafana/pkg/models"
)

// POST /api/preferences/set-home-dash
func SetHomeDashboard(c *middleware.Context, cmd m.SavePreferencesCommand) Response <span class="cov0" title="0">{

        cmd.UserId = c.UserId
        cmd.OrgId = c.OrgId

        if err := bus.Dispatch(&amp;cmd); err != nil </span><span class="cov0" title="0">{
                return ApiError(500, "Failed to set home dashboard", err)
        }</span>

        <span class="cov0" title="0">return ApiSuccess("Home dashboard set")</span>
}

// GET /api/user/preferences
func GetUserPreferences(c *middleware.Context) Response <span class="cov0" title="0">{
        return getPreferencesFor(c.OrgId, c.UserId)
}</span>

func getPreferencesFor(orgId int64, userId int64) Response <span class="cov0" title="0">{
        prefsQuery := m.GetPreferencesQuery{UserId: userId, OrgId: orgId}

        if err := bus.Dispatch(&amp;prefsQuery); err != nil </span><span class="cov0" title="0">{
                return ApiError(500, "Failed to get preferences", err)
        }</span>

        <span class="cov0" title="0">dto := dtos.Prefs{
                Theme:           prefsQuery.Result.Theme,
                HomeDashboardId: prefsQuery.Result.HomeDashboardId,
                Timezone:        prefsQuery.Result.Timezone,
        }

        return Json(200, &amp;dto)</span>
}

// PUT /api/user/preferences
func UpdateUserPreferences(c *middleware.Context, dtoCmd dtos.UpdatePrefsCmd) Response <span class="cov0" title="0">{
        return updatePreferencesFor(c.OrgId, c.UserId, &amp;dtoCmd)
}</span>

func updatePreferencesFor(orgId int64, userId int64, dtoCmd *dtos.UpdatePrefsCmd) Response <span class="cov0" title="0">{
        saveCmd := m.SavePreferencesCommand{
                UserId:          userId,
                OrgId:           orgId,
                Theme:           dtoCmd.Theme,
                Timezone:        dtoCmd.Timezone,
                HomeDashboardId: dtoCmd.HomeDashboardId,
        }

        if err := bus.Dispatch(&amp;saveCmd); err != nil </span><span class="cov0" title="0">{
                return ApiError(500, "Failed to save preferences", err)
        }</span>

        <span class="cov0" title="0">return ApiSuccess("Preferences updated")</span>
}

// GET /api/org/preferences
func GetOrgPreferences(c *middleware.Context) Response <span class="cov0" title="0">{
        return getPreferencesFor(c.OrgId, 0)
}</span>

// PUT /api/org/preferences
func UpdateOrgPreferences(c *middleware.Context, dtoCmd dtos.UpdatePrefsCmd) Response <span class="cov0" title="0">{
        return updatePreferencesFor(c.OrgId, 0, &amp;dtoCmd)
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">package api

import (
        "github.com/grafana/grafana/pkg/bus"
        "github.com/grafana/grafana/pkg/middleware"
        m "github.com/grafana/grafana/pkg/models"
        "github.com/grafana/grafana/pkg/setting"
)

func GetOrgQuotas(c *middleware.Context) Response <span class="cov0" title="0">{
        if !setting.Quota.Enabled </span><span class="cov0" title="0">{
                return ApiError(404, "Quotas not enabled", nil)
        }</span>
        <span class="cov0" title="0">query := m.GetOrgQuotasQuery{OrgId: c.ParamsInt64(":orgId")}

        if err := bus.Dispatch(&amp;query); err != nil </span><span class="cov0" title="0">{
                return ApiError(500, "Failed to get org quotas", err)
        }</span>

        <span class="cov0" title="0">return Json(200, query.Result)</span>
}

func UpdateOrgQuota(c *middleware.Context, cmd m.UpdateOrgQuotaCmd) Response <span class="cov0" title="0">{
        if !setting.Quota.Enabled </span><span class="cov0" title="0">{
                return ApiError(404, "Quotas not enabled", nil)
        }</span>
        <span class="cov0" title="0">cmd.OrgId = c.ParamsInt64(":orgId")
        cmd.Target = c.Params(":target")

        if _, ok := setting.Quota.Org.ToMap()[cmd.Target]; !ok </span><span class="cov0" title="0">{
                return ApiError(404, "Invalid quota target", nil)
        }</span>

        <span class="cov0" title="0">if err := bus.Dispatch(&amp;cmd); err != nil </span><span class="cov0" title="0">{
                return ApiError(500, "Failed to update org quotas", err)
        }</span>
        <span class="cov0" title="0">return ApiSuccess("Organization quota updated")</span>
}

func GetUserQuotas(c *middleware.Context) Response <span class="cov0" title="0">{
        if !setting.Quota.Enabled </span><span class="cov0" title="0">{
                return ApiError(404, "Quotas not enabled", nil)
        }</span>
        <span class="cov0" title="0">query := m.GetUserQuotasQuery{UserId: c.ParamsInt64(":id")}

        if err := bus.Dispatch(&amp;query); err != nil </span><span class="cov0" title="0">{
                return ApiError(500, "Failed to get org quotas", err)
        }</span>

        <span class="cov0" title="0">return Json(200, query.Result)</span>
}

func UpdateUserQuota(c *middleware.Context, cmd m.UpdateUserQuotaCmd) Response <span class="cov0" title="0">{
        if !setting.Quota.Enabled </span><span class="cov0" title="0">{
                return ApiError(404, "Quotas not enabled", nil)
        }</span>
        <span class="cov0" title="0">cmd.UserId = c.ParamsInt64(":id")
        cmd.Target = c.Params(":target")

        if _, ok := setting.Quota.User.ToMap()[cmd.Target]; !ok </span><span class="cov0" title="0">{
                return ApiError(404, "Invalid quota target", nil)
        }</span>

        <span class="cov0" title="0">if err := bus.Dispatch(&amp;cmd); err != nil </span><span class="cov0" title="0">{
                return ApiError(500, "Failed to update org quotas", err)
        }</span>
        <span class="cov0" title="0">return ApiSuccess("Organization quota updated")</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package api

import (
        "fmt"
        "net/http"

        "github.com/grafana/grafana/pkg/components/renderer"
        "github.com/grafana/grafana/pkg/middleware"
        "github.com/grafana/grafana/pkg/util"
)

func RenderToPng(c *middleware.Context) <span class="cov0" title="0">{
        queryReader := util.NewUrlQueryReader(c.Req.URL)
        queryParams := fmt.Sprintf("?%s", c.Req.URL.RawQuery)

        renderOpts := &amp;renderer.RenderOpts{
                Path:     c.Params("*") + queryParams,
                Width:    queryReader.Get("width", "800"),
                Height:   queryReader.Get("height", "400"),
                OrgId:    c.OrgId,
                Timeout:  queryReader.Get("timeout", "30"),
                Timezone: queryReader.Get("tz", ""),
        }

        pngPath, err := renderer.RenderToPng(renderOpts)

        if err != nil </span><span class="cov0" title="0">{
                c.Handle(500, "Failed to render to png", err)
                return
        }</span>

        <span class="cov0" title="0">c.Resp.Header().Set("Content-Type", "image/png")
        http.ServeFile(c.Resp, c.Req.Request, pngPath)</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package api

import (
        "strconv"

        "github.com/grafana/grafana/pkg/bus"
        "github.com/grafana/grafana/pkg/metrics"
        "github.com/grafana/grafana/pkg/middleware"
        "github.com/grafana/grafana/pkg/services/search"
)

func Search(c *middleware.Context) <span class="cov0" title="0">{
        query := c.Query("query")
        tags := c.QueryStrings("tag")
        starred := c.Query("starred")
        limit := c.QueryInt("limit")

        if limit == 0 </span><span class="cov0" title="0">{
                limit = 1000
        }</span>

        <span class="cov0" title="0">dbids := make([]int, 0)
        for _, id := range c.QueryStrings("dashboardIds") </span><span class="cov0" title="0">{
                dashboardId, err := strconv.Atoi(id)
                if err == nil </span><span class="cov0" title="0">{
                        dbids = append(dbids, dashboardId)
                }</span>
        }

        <span class="cov0" title="0">searchQuery := search.Query{
                Title:        query,
                Tags:         tags,
                UserId:       c.UserId,
                Limit:        limit,
                IsStarred:    starred == "true",
                OrgId:        c.OrgId,
                DashboardIds: dbids,
        }

        err := bus.Dispatch(&amp;searchQuery)
        if err != nil </span><span class="cov0" title="0">{
                c.JsonApiErr(500, "Search failed", err)
                return
        }</span>

        <span class="cov0" title="0">c.TimeRequest(metrics.M_Api_Dashboard_Search)
        c.JSON(200, searchQuery.Result)</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package api

import (
        "github.com/grafana/grafana/pkg/api/dtos"
        "github.com/grafana/grafana/pkg/bus"
        "github.com/grafana/grafana/pkg/events"
        "github.com/grafana/grafana/pkg/metrics"
        "github.com/grafana/grafana/pkg/middleware"
        m "github.com/grafana/grafana/pkg/models"
        "github.com/grafana/grafana/pkg/setting"
        "github.com/grafana/grafana/pkg/util"
)

// GET /api/user/signup/options
func GetSignUpOptions(c *middleware.Context) Response <span class="cov0" title="0">{
        return Json(200, util.DynMap{
                "verifyEmailEnabled": setting.VerifyEmailEnabled,
                "autoAssignOrg":      setting.AutoAssignOrg,
        })
}</span>

// POST /api/user/signup
func SignUp(c *middleware.Context, form dtos.SignUpForm) Response <span class="cov0" title="0">{
        if !setting.AllowUserSignUp </span><span class="cov0" title="0">{
                return ApiError(401, "User signup is disabled", nil)
        }</span>

        <span class="cov0" title="0">existing := m.GetUserByLoginQuery{LoginOrEmail: form.Email}
        if err := bus.Dispatch(&amp;existing); err == nil </span><span class="cov0" title="0">{
                return ApiError(422, "User with same email address already exists", nil)
        }</span>

        <span class="cov0" title="0">cmd := m.CreateTempUserCommand{}
        cmd.OrgId = -1
        cmd.Email = form.Email
        cmd.Status = m.TmpUserSignUpStarted
        cmd.InvitedByUserId = c.UserId
        cmd.Code = util.GetRandomString(20)
        cmd.RemoteAddr = c.Req.RemoteAddr

        if err := bus.Dispatch(&amp;cmd); err != nil </span><span class="cov0" title="0">{
                return ApiError(500, "Failed to create signup", err)
        }</span>

        <span class="cov0" title="0">bus.Publish(&amp;events.SignUpStarted{
                Email: form.Email,
                Code:  cmd.Code,
        })

        metrics.M_Api_User_SignUpStarted.Inc(1)

        return Json(200, util.DynMap{"status": "SignUpCreated"})</span>
}

func SignUpStep2(c *middleware.Context, form dtos.SignUpStep2Form) Response <span class="cov0" title="0">{
        if !setting.AllowUserSignUp </span><span class="cov0" title="0">{
                return ApiError(401, "User signup is disabled", nil)
        }</span>

        <span class="cov0" title="0">createUserCmd := m.CreateUserCommand{
                Email:    form.Email,
                Login:    form.Username,
                Name:     form.Name,
                Password: form.Password,
                OrgName:  form.OrgName,
        }

        // verify email
        if setting.VerifyEmailEnabled </span><span class="cov0" title="0">{
                if ok, rsp := verifyUserSignUpEmail(form.Email, form.Code); !ok </span><span class="cov0" title="0">{
                        return rsp
                }</span>
                <span class="cov0" title="0">createUserCmd.EmailVerified = true</span>
        }

        // check if user exists
        <span class="cov0" title="0">existing := m.GetUserByLoginQuery{LoginOrEmail: form.Email}
        if err := bus.Dispatch(&amp;existing); err == nil </span><span class="cov0" title="0">{
                return ApiError(401, "User with same email address already exists", nil)
        }</span>

        // dispatch create command
        <span class="cov0" title="0">if err := bus.Dispatch(&amp;createUserCmd); err != nil </span><span class="cov0" title="0">{
                return ApiError(500, "Failed to create user", err)
        }</span>

        // publish signup event
        <span class="cov0" title="0">user := &amp;createUserCmd.Result
        bus.Publish(&amp;events.SignUpCompleted{
                Email: user.Email,
                Name:  user.NameOrFallback(),
        })

        // mark temp user as completed
        if ok, rsp := updateTempUserStatus(form.Code, m.TmpUserCompleted); !ok </span><span class="cov0" title="0">{
                return rsp
        }</span>

        // check for pending invites
        <span class="cov0" title="0">invitesQuery := m.GetTempUsersQuery{Email: form.Email, Status: m.TmpUserInvitePending}
        if err := bus.Dispatch(&amp;invitesQuery); err != nil </span><span class="cov0" title="0">{
                return ApiError(500, "Failed to query database for invites", err)
        }</span>

        <span class="cov0" title="0">apiResponse := util.DynMap{"message": "User sign up completed successfully", "code": "redirect-to-landing-page"}
        for _, invite := range invitesQuery.Result </span><span class="cov0" title="0">{
                if ok, rsp := applyUserInvite(user, invite, false); !ok </span><span class="cov0" title="0">{
                        return rsp
                }</span>
                <span class="cov0" title="0">apiResponse["code"] = "redirect-to-select-org"</span>
        }

        <span class="cov0" title="0">loginUserWithUser(user, c)
        metrics.M_Api_User_SignUpCompleted.Inc(1)

        return Json(200, apiResponse)</span>
}

func verifyUserSignUpEmail(email string, code string) (bool, Response) <span class="cov0" title="0">{
        query := m.GetTempUserByCodeQuery{Code: code}

        if err := bus.Dispatch(&amp;query); err != nil </span><span class="cov0" title="0">{
                if err == m.ErrTempUserNotFound </span><span class="cov0" title="0">{
                        return false, ApiError(404, "Invalid email verification code", nil)
                }</span>
                <span class="cov0" title="0">return false, ApiError(500, "Failed to read temp user", err)</span>
        }

        <span class="cov0" title="0">tempUser := query.Result
        if tempUser.Email != email </span><span class="cov0" title="0">{
                return false, ApiError(404, "Email verification code does not match email", nil)
        }</span>

        <span class="cov0" title="0">return true, nil</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package api

import (
        "github.com/grafana/grafana/pkg/bus"
        "github.com/grafana/grafana/pkg/middleware"
        m "github.com/grafana/grafana/pkg/models"
)

func StarDashboard(c *middleware.Context) Response <span class="cov0" title="0">{
        if !c.IsSignedIn </span><span class="cov0" title="0">{
                return ApiError(412, "You need to sign in to star dashboards", nil)
        }</span>

        <span class="cov0" title="0">cmd := m.StarDashboardCommand{UserId: c.UserId, DashboardId: c.ParamsInt64(":id")}

        if cmd.DashboardId &lt;= 0 </span><span class="cov0" title="0">{
                return ApiError(400, "Missing dashboard id", nil)
        }</span>

        <span class="cov0" title="0">if err := bus.Dispatch(&amp;cmd); err != nil </span><span class="cov0" title="0">{
                return ApiError(500, "Failed to star dashboard", err)
        }</span>

        <span class="cov0" title="0">return ApiSuccess("Dashboard starred!")</span>
}

func UnstarDashboard(c *middleware.Context) Response <span class="cov0" title="0">{

        cmd := m.UnstarDashboardCommand{UserId: c.UserId, DashboardId: c.ParamsInt64(":id")}

        if cmd.DashboardId &lt;= 0 </span><span class="cov0" title="0">{
                return ApiError(400, "Missing dashboard id", nil)
        }</span>

        <span class="cov0" title="0">if err := bus.Dispatch(&amp;cmd); err != nil </span><span class="cov0" title="0">{
                return ApiError(500, "Failed to unstar dashboard", err)
        }</span>

        <span class="cov0" title="0">return ApiSuccess("Dashboard unstarred")</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package api

import (
        "github.com/grafana/grafana/pkg/bus"
        "github.com/grafana/grafana/pkg/middleware"
        m "github.com/grafana/grafana/pkg/models"
        "github.com/grafana/grafana/pkg/setting"
        "github.com/grafana/grafana/pkg/util"
)

// GET /api/user  (current authenticated user)
func GetSignedInUser(c *middleware.Context) Response <span class="cov0" title="0">{
        return getUserUserProfile(c.UserId)
}</span>

// GET /api/users/:id
func GetUserById(c *middleware.Context) Response <span class="cov0" title="0">{
        return getUserUserProfile(c.ParamsInt64(":id"))
}</span>

func getUserUserProfile(userId int64) Response <span class="cov0" title="0">{
        query := m.GetUserProfileQuery{UserId: userId}

        if err := bus.Dispatch(&amp;query); err != nil </span><span class="cov0" title="0">{
                if err == m.ErrUserNotFound </span><span class="cov0" title="0">{
                        return ApiError(404, m.ErrUserNotFound.Error(), nil)
                }</span>
                <span class="cov0" title="0">return ApiError(500, "Failed to get user", err)</span>
        }

        <span class="cov0" title="0">return Json(200, query.Result)</span>
}

// GET /api/users/lookup
func GetUserByLoginOrEmail(c *middleware.Context) Response <span class="cov0" title="0">{
        query := m.GetUserByLoginQuery{LoginOrEmail: c.Query("loginOrEmail")}
        if err := bus.Dispatch(&amp;query); err != nil </span><span class="cov0" title="0">{
                if err == m.ErrUserNotFound </span><span class="cov0" title="0">{
                        return ApiError(404, m.ErrUserNotFound.Error(), nil)
                }</span>
                <span class="cov0" title="0">return ApiError(500, "Failed to get user", err)</span>
        }
        <span class="cov0" title="0">user := query.Result
        result := m.UserProfileDTO{
                Name:           user.Name,
                Email:          user.Email,
                Login:          user.Login,
                Theme:          user.Theme,
                IsGrafanaAdmin: user.IsAdmin,
                OrgId:          user.OrgId,
        }
        return Json(200, &amp;result)</span>
}

// POST /api/user
func UpdateSignedInUser(c *middleware.Context, cmd m.UpdateUserCommand) Response <span class="cov0" title="0">{
        if setting.AuthProxyEnabled </span><span class="cov0" title="0">{
                if setting.AuthProxyHeaderProperty == "email" &amp;&amp; cmd.Email != c.Email </span><span class="cov0" title="0">{
                        return ApiError(400, "Not allowed to change email when auth proxy is using email property", nil)
                }</span>
                <span class="cov0" title="0">if setting.AuthProxyHeaderProperty == "username" &amp;&amp; cmd.Login != c.Login </span><span class="cov0" title="0">{
                        return ApiError(400, "Not allowed to change username when auth proxy is using username property", nil)
                }</span>
        }
        <span class="cov0" title="0">cmd.UserId = c.UserId
        return handleUpdateUser(cmd)</span>
}

// POST /api/users/:id
func UpdateUser(c *middleware.Context, cmd m.UpdateUserCommand) Response <span class="cov0" title="0">{
        cmd.UserId = c.ParamsInt64(":id")
        return handleUpdateUser(cmd)
}</span>

//POST /api/users/:id/using/:orgId
func UpdateUserActiveOrg(c *middleware.Context) Response <span class="cov0" title="0">{
        userId := c.ParamsInt64(":id")
        orgId := c.ParamsInt64(":orgId")

        if !validateUsingOrg(userId, orgId) </span><span class="cov0" title="0">{
                return ApiError(401, "Not a valid organization", nil)
        }</span>

        <span class="cov0" title="0">cmd := m.SetUsingOrgCommand{UserId: userId, OrgId: orgId}

        if err := bus.Dispatch(&amp;cmd); err != nil </span><span class="cov0" title="0">{
                return ApiError(500, "Failed to change active organization", err)
        }</span>

        <span class="cov0" title="0">return ApiSuccess("Active organization changed")</span>
}

func handleUpdateUser(cmd m.UpdateUserCommand) Response <span class="cov0" title="0">{
        if len(cmd.Login) == 0 </span><span class="cov0" title="0">{
                cmd.Login = cmd.Email
                if len(cmd.Login) == 0 </span><span class="cov0" title="0">{
                        return ApiError(400, "Validation error, need to specify either username or email", nil)
                }</span>
        }

        <span class="cov0" title="0">if err := bus.Dispatch(&amp;cmd); err != nil </span><span class="cov0" title="0">{
                return ApiError(500, "Failed to update user", err)
        }</span>

        <span class="cov0" title="0">return ApiSuccess("User updated")</span>
}

// GET /api/user/orgs
func GetSignedInUserOrgList(c *middleware.Context) Response <span class="cov0" title="0">{
        return getUserOrgList(c.UserId)
}</span>

// GET /api/user/:id/orgs
func GetUserOrgList(c *middleware.Context) Response <span class="cov0" title="0">{
        return getUserOrgList(c.ParamsInt64(":id"))
}</span>

func getUserOrgList(userId int64) Response <span class="cov0" title="0">{
        query := m.GetUserOrgListQuery{UserId: userId}

        if err := bus.Dispatch(&amp;query); err != nil </span><span class="cov0" title="0">{
                return ApiError(500, "Failed to get user organizations", err)
        }</span>

        <span class="cov0" title="0">return Json(200, query.Result)</span>
}

func validateUsingOrg(userId int64, orgId int64) bool <span class="cov0" title="0">{
        query := m.GetUserOrgListQuery{UserId: userId}

        if err := bus.Dispatch(&amp;query); err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // validate that the org id in the list
        <span class="cov0" title="0">valid := false
        for _, other := range query.Result </span><span class="cov0" title="0">{
                if other.OrgId == orgId </span><span class="cov0" title="0">{
                        valid = true
                }</span>
        }

        <span class="cov0" title="0">return valid</span>
}

// POST /api/user/using/:id
func UserSetUsingOrg(c *middleware.Context) Response <span class="cov0" title="0">{
        orgId := c.ParamsInt64(":id")

        if !validateUsingOrg(c.UserId, orgId) </span><span class="cov0" title="0">{
                return ApiError(401, "Not a valid organization", nil)
        }</span>

        <span class="cov0" title="0">cmd := m.SetUsingOrgCommand{UserId: c.UserId, OrgId: orgId}

        if err := bus.Dispatch(&amp;cmd); err != nil </span><span class="cov0" title="0">{
                return ApiError(500, "Failed to change active organization", err)
        }</span>

        <span class="cov0" title="0">return ApiSuccess("Active organization changed")</span>
}

// GET /profile/switch-org/:id
func ChangeActiveOrgAndRedirectToHome(c *middleware.Context) <span class="cov0" title="0">{
        orgId := c.ParamsInt64(":id")

        if !validateUsingOrg(c.UserId, orgId) </span><span class="cov0" title="0">{
                NotFoundHandler(c)
        }</span>

        <span class="cov0" title="0">cmd := m.SetUsingOrgCommand{UserId: c.UserId, OrgId: orgId}

        if err := bus.Dispatch(&amp;cmd); err != nil </span><span class="cov0" title="0">{
                NotFoundHandler(c)
        }</span>

        <span class="cov0" title="0">c.Redirect(setting.AppSubUrl + "/")</span>
}

func ChangeUserPassword(c *middleware.Context, cmd m.ChangeUserPasswordCommand) Response <span class="cov0" title="0">{
        if setting.LdapEnabled || setting.AuthProxyEnabled </span><span class="cov0" title="0">{
                return ApiError(400, "Not allowed to change password when LDAP or Auth Proxy is enabled", nil)
        }</span>

        <span class="cov0" title="0">userQuery := m.GetUserByIdQuery{Id: c.UserId}

        if err := bus.Dispatch(&amp;userQuery); err != nil </span><span class="cov0" title="0">{
                return ApiError(500, "Could not read user from database", err)
        }</span>

        <span class="cov0" title="0">passwordHashed := util.EncodePassword(cmd.OldPassword, userQuery.Result.Salt)
        if passwordHashed != userQuery.Result.Password </span><span class="cov0" title="0">{
                return ApiError(401, "Invalid old password", nil)
        }</span>

        <span class="cov0" title="0">password := m.Password(cmd.NewPassword)
        if password.IsWeak() </span><span class="cov0" title="0">{
                return ApiError(400, "New password is too short", nil)
        }</span>

        <span class="cov0" title="0">cmd.UserId = c.UserId
        cmd.NewPassword = util.EncodePassword(cmd.NewPassword, userQuery.Result.Salt)

        if err := bus.Dispatch(&amp;cmd); err != nil </span><span class="cov0" title="0">{
                return ApiError(500, "Failed to change user password", err)
        }</span>

        <span class="cov0" title="0">return ApiSuccess("User password changed")</span>
}

// GET /api/users
func SearchUsers(c *middleware.Context) Response <span class="cov8" title="1">{
        query, err := searchUser(c)
        if err != nil </span><span class="cov0" title="0">{
                return ApiError(500, "Failed to fetch users", err)
        }</span>

        <span class="cov8" title="1">return Json(200, query.Result.Users)</span>
}

// GET /api/search
func SearchUsersWithPaging(c *middleware.Context) Response <span class="cov8" title="1">{
        query, err := searchUser(c)
        if err != nil </span><span class="cov0" title="0">{
                return ApiError(500, "Failed to fetch users", err)
        }</span>

        <span class="cov8" title="1">return Json(200, query.Result)</span>
}

func searchUser(c *middleware.Context) (*m.SearchUsersQuery, error) <span class="cov8" title="1">{
        perPage := c.QueryInt("perpage")
        if perPage &lt;= 0 </span><span class="cov8" title="1">{
                perPage = 1000
        }</span>
        <span class="cov8" title="1">page := c.QueryInt("page")

        if page &lt; 1 </span><span class="cov8" title="1">{
                page = 1
        }</span>

        <span class="cov8" title="1">query := &amp;m.SearchUsersQuery{Query: "", Page: page, Limit: perPage}
        if err := bus.Dispatch(query); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">query.Result.Page = page
        query.Result.PerPage = perPage

        return query, nil</span>
}

func SetHelpFlag(c *middleware.Context) Response <span class="cov0" title="0">{
        flag := c.ParamsInt64(":id")

        bitmask := &amp;c.HelpFlags1
        bitmask.AddFlag(m.HelpFlags1(flag))

        cmd := m.SetUserHelpFlagCommand{
                UserId:     c.UserId,
                HelpFlags1: *bitmask,
        }

        if err := bus.Dispatch(&amp;cmd); err != nil </span><span class="cov0" title="0">{
                return ApiError(500, "Failed to update help flag", err)
        }</span>

        <span class="cov0" title="0">return Json(200, &amp;util.DynMap{"message": "Help flag set", "helpFlags1": cmd.HelpFlags1})</span>
}

func ClearHelpFlags(c *middleware.Context) Response <span class="cov0" title="0">{
        cmd := m.SetUserHelpFlagCommand{
                UserId:     c.UserId,
                HelpFlags1: m.HelpFlags1(0),
        }

        if err := bus.Dispatch(&amp;cmd); err != nil </span><span class="cov0" title="0">{
                return ApiError(500, "Failed to update help flag", err)
        }</span>

        <span class="cov0" title="0">return Json(200, &amp;util.DynMap{"message": "Help flag set", "helpFlags1": cmd.HelpFlags1})</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package bus

import (
        "context"
        "fmt"
        "reflect"
)

type HandlerFunc interface{}
type CtxHandlerFunc func()
type Msg interface{}

type Bus interface {
        Dispatch(msg Msg) error
        DispatchCtx(ctx context.Context, msg Msg) error
        Publish(msg Msg) error

        AddHandler(handler HandlerFunc)
        AddCtxHandler(handler HandlerFunc)
        AddEventListener(handler HandlerFunc)
        AddWildcardListener(handler HandlerFunc)
}

type InProcBus struct {
        handlers          map[string]HandlerFunc
        listeners         map[string][]HandlerFunc
        wildcardListeners []HandlerFunc
}

// temp stuff, not sure how to handle bus instance, and init yet
var globalBus = New()

func New() Bus <span class="cov8" title="1">{
        bus := &amp;InProcBus{}
        bus.handlers = make(map[string]HandlerFunc)
        bus.listeners = make(map[string][]HandlerFunc)
        bus.wildcardListeners = make([]HandlerFunc, 0)
        return bus
}</span>

func (b *InProcBus) DispatchCtx(ctx context.Context, msg Msg) error <span class="cov0" title="0">{
        var msgName = reflect.TypeOf(msg).Elem().Name()

        var handler = b.handlers[msgName]
        if handler == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("handler not found for %s", msgName)
        }</span>

        <span class="cov0" title="0">var params = make([]reflect.Value, 2)
        params[0] = reflect.ValueOf(ctx)
        params[1] = reflect.ValueOf(msg)

        ret := reflect.ValueOf(handler).Call(params)
        err := ret[0].Interface()
        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span><span class="cov0" title="0"> else {
                return err.(error)
        }</span>
}

func (b *InProcBus) Dispatch(msg Msg) error <span class="cov8" title="1">{
        var msgName = reflect.TypeOf(msg).Elem().Name()

        var handler = b.handlers[msgName]
        if handler == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("handler not found for %s", msgName)
        }</span>

        <span class="cov8" title="1">var params = make([]reflect.Value, 1)
        params[0] = reflect.ValueOf(msg)

        ret := reflect.ValueOf(handler).Call(params)
        err := ret[0].Interface()
        if err == nil </span><span class="cov8" title="1">{
                return nil
        }</span><span class="cov8" title="1"> else {
                return err.(error)
        }</span>
}

func (b *InProcBus) Publish(msg Msg) error <span class="cov8" title="1">{
        var msgName = reflect.TypeOf(msg).Elem().Name()
        var listeners = b.listeners[msgName]

        var params = make([]reflect.Value, 1)
        params[0] = reflect.ValueOf(msg)

        for _, listenerHandler := range listeners </span><span class="cov8" title="1">{
                ret := reflect.ValueOf(listenerHandler).Call(params)
                err := ret[0].Interface()
                if err != nil </span><span class="cov0" title="0">{
                        return err.(error)
                }</span>
        }

        <span class="cov8" title="1">for _, listenerHandler := range b.wildcardListeners </span><span class="cov0" title="0">{
                ret := reflect.ValueOf(listenerHandler).Call(params)
                err := ret[0].Interface()
                if err != nil </span><span class="cov0" title="0">{
                        return err.(error)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (b *InProcBus) AddWildcardListener(handler HandlerFunc) <span class="cov0" title="0">{
        b.wildcardListeners = append(b.wildcardListeners, handler)
}</span>

func (b *InProcBus) AddHandler(handler HandlerFunc) <span class="cov8" title="1">{
        handlerType := reflect.TypeOf(handler)
        queryTypeName := handlerType.In(0).Elem().Name()
        b.handlers[queryTypeName] = handler
}</span>

func (b *InProcBus) AddCtxHandler(handler HandlerFunc) <span class="cov0" title="0">{
        handlerType := reflect.TypeOf(handler)
        queryTypeName := handlerType.In(1).Elem().Name()
        b.handlers[queryTypeName] = handler
}</span>

func (b *InProcBus) AddEventListener(handler HandlerFunc) <span class="cov8" title="1">{
        handlerType := reflect.TypeOf(handler)
        eventName := handlerType.In(0).Elem().Name()
        _, exists := b.listeners[eventName]
        if !exists </span><span class="cov8" title="1">{
                b.listeners[eventName] = make([]HandlerFunc, 0)
        }</span>
        <span class="cov8" title="1">b.listeners[eventName] = append(b.listeners[eventName], handler)</span>
}

// Package level functions
func AddHandler(implName string, handler HandlerFunc) <span class="cov0" title="0">{
        globalBus.AddHandler(handler)
}</span>

// Package level functions
func AddCtxHandler(implName string, handler HandlerFunc) <span class="cov0" title="0">{
        globalBus.AddCtxHandler(handler)
}</span>

// Package level functions
func AddEventListener(handler HandlerFunc) <span class="cov0" title="0">{
        globalBus.AddEventListener(handler)
}</span>

func AddWildcardListener(handler HandlerFunc) <span class="cov0" title="0">{
        globalBus.AddWildcardListener(handler)
}</span>

func Dispatch(msg Msg) error <span class="cov0" title="0">{
        return globalBus.Dispatch(msg)
}</span>

func DispatchCtx(ctx context.Context, msg Msg) error <span class="cov0" title="0">{
        return globalBus.DispatchCtx(ctx, msg)
}</span>

func Publish(msg Msg) error <span class="cov0" title="0">{
        return globalBus.Publish(msg)
}</span>

func ClearBusHandlers() <span class="cov0" title="0">{
        globalBus = New()
}</span>
</pre>
		
		<pre class="file" id="file37" style="display: none">package commands

import (
        "github.com/codegangsta/cli"
)

type CommandLine interface {
        ShowHelp()
        ShowVersion()
        Application() *cli.App
        Args() cli.Args
        Bool(name string) bool
        Int(name string) int
        String(name string) string
        StringSlice(name string) []string
        GlobalString(name string) string
        FlagNames() (names []string)
        Generic(name string) interface{}

        PluginDirectory() string
        RepoDirectory() string
}

type contextCommandLine struct {
        *cli.Context
}

func (c *contextCommandLine) ShowHelp() <span class="cov0" title="0">{
        cli.ShowCommandHelp(c.Context, c.Command.Name)
}</span>

func (c *contextCommandLine) ShowVersion() <span class="cov0" title="0">{
        cli.ShowVersion(c.Context)
}</span>

func (c *contextCommandLine) Application() *cli.App <span class="cov0" title="0">{
        return c.App
}</span>

func (c *contextCommandLine) PluginDirectory() string <span class="cov0" title="0">{
        return c.GlobalString("pluginsDir")
}</span>

func (c *contextCommandLine) RepoDirectory() string <span class="cov0" title="0">{
        return c.GlobalString("repo")
}</span>
</pre>
		
		<pre class="file" id="file38" style="display: none">package commands

import (
        "flag"
        "os"

        "github.com/codegangsta/cli"
        "github.com/fatih/color"
        "github.com/grafana/grafana/pkg/cmd/grafana-cli/logger"
        "github.com/grafana/grafana/pkg/services/sqlstore"
        "github.com/grafana/grafana/pkg/setting"
)

var configFile = flag.String("config", "", "path to config file")
var homePath = flag.String("homepath", "", "path to grafana install/home path, defaults to working directory")

func runDbCommand(command func(commandLine CommandLine) error) func(context *cli.Context) <span class="cov8" title="1">{
        return func(context *cli.Context) </span><span class="cov0" title="0">{

                flag.Parse()
                setting.NewConfigContext(&amp;setting.CommandLineArgs{
                        Config:   *configFile,
                        HomePath: *homePath,
                        Args:     flag.Args(),
                })

                sqlstore.NewEngine()

                cmd := &amp;contextCommandLine{context}
                if err := command(cmd); err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("\n%s: ", color.RedString("Error"))
                        logger.Errorf("%s\n\n", err)

                        cmd.ShowHelp()
                        os.Exit(1)
                }</span><span class="cov0" title="0"> else {
                        logger.Info("\n\n")
                }</span>
        }
}

func runPluginCommand(command func(commandLine CommandLine) error) func(context *cli.Context) <span class="cov8" title="1">{
        return func(context *cli.Context) </span><span class="cov0" title="0">{

                cmd := &amp;contextCommandLine{context}
                if err := command(cmd); err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("\n%s: ", color.RedString("Error"))
                        logger.Errorf("%s %s\n\n", color.RedString("✗"), err)

                        cmd.ShowHelp()
                        os.Exit(1)
                }</span><span class="cov0" title="0"> else {
                        logger.Info("\nRestart grafana after installing plugins . &lt;service grafana-server restart&gt;\n\n")
                }</span>
        }
}

var pluginCommands = []cli.Command{
        {
                Name:   "install",
                Usage:  "install &lt;plugin id&gt; &lt;plugin version (optional)&gt;",
                Action: runPluginCommand(installCommand),
        }, {
                Name:   "list-remote",
                Usage:  "list remote available plugins",
                Action: runPluginCommand(listremoteCommand),
        }, {
                Name:   "list-versions",
                Usage:  "list-versions &lt;plugin id&gt;",
                Action: runPluginCommand(listversionsCommand),
        }, {
                Name:    "update",
                Usage:   "update &lt;plugin id&gt;",
                Aliases: []string{"upgrade"},
                Action:  runPluginCommand(upgradeCommand),
        }, {
                Name:    "update-all",
                Aliases: []string{"upgrade-all"},
                Usage:   "update all your installed plugins",
                Action:  runPluginCommand(upgradeAllCommand),
        }, {
                Name:   "ls",
                Usage:  "list all installed plugins",
                Action: runPluginCommand(lsCommand),
        }, {
                Name:    "uninstall",
                Aliases: []string{"remove"},
                Usage:   "uninstall &lt;plugin id&gt;",
                Action:  runPluginCommand(removeCommand),
        },
}

var adminCommands = []cli.Command{
        {
                Name:   "reset-admin-password",
                Usage:  "reset-admin-password &lt;new password&gt;",
                Action: runDbCommand(resetPasswordCommand),
        },
}

var Commands = []cli.Command{
        {
                Name:        "plugins",
                Usage:       "Manage plugins for grafana",
                Subcommands: pluginCommands,
        },
        {
                Name:        "admin",
                Usage:       "Grafana admin commands",
                Subcommands: adminCommands,
        },
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package commands

import (
        "archive/zip"
        "bytes"
        "errors"
        "fmt"
        "io"
        "io/ioutil"
        "net/http"
        "os"
        "path"
        "regexp"
        "strings"

        "github.com/fatih/color"
        "github.com/grafana/grafana/pkg/cmd/grafana-cli/logger"
        m "github.com/grafana/grafana/pkg/cmd/grafana-cli/models"
        s "github.com/grafana/grafana/pkg/cmd/grafana-cli/services"
)

func validateInput(c CommandLine, pluginFolder string) error <span class="cov0" title="0">{
        arg := c.Args().First()
        if arg == "" </span><span class="cov0" title="0">{
                return errors.New("please specify plugin to install")
        }</span>

        <span class="cov0" title="0">pluginsDir := c.PluginDirectory()
        if pluginsDir == "" </span><span class="cov0" title="0">{
                return errors.New("missing pluginsDir flag")
        }</span>

        <span class="cov0" title="0">fileInfo, err := os.Stat(pluginsDir)
        if err != nil </span><span class="cov0" title="0">{
                if err = os.MkdirAll(pluginsDir, os.ModePerm); err != nil </span><span class="cov0" title="0">{
                        return errors.New(fmt.Sprintf("pluginsDir (%s) is not a directory", pluginsDir))
                }</span>
                <span class="cov0" title="0">return nil</span>
        }

        <span class="cov0" title="0">if !fileInfo.IsDir() </span><span class="cov0" title="0">{
                return errors.New("path is not a directory")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func installCommand(c CommandLine) error <span class="cov0" title="0">{
        pluginFolder := c.PluginDirectory()
        if err := validateInput(c, pluginFolder); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">pluginToInstall := c.Args().First()
        version := c.Args().Get(1)

        return InstallPlugin(pluginToInstall, version, c)</span>
}

func InstallPlugin(pluginName, version string, c CommandLine) error <span class="cov0" title="0">{
        plugin, err := s.GetPlugin(pluginName, c.RepoDirectory())
        pluginFolder := c.PluginDirectory()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">v, err := SelectVersion(plugin, version)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if version == "" </span><span class="cov0" title="0">{
                version = v.Version
        }</span>

        <span class="cov0" title="0">downloadURL := fmt.Sprintf("%s/%s/versions/%s/download",
                c.GlobalString("repo"),
                pluginName,
                version)

        logger.Infof("installing %v @ %v\n", plugin.Id, version)
        logger.Infof("from url: %v\n", downloadURL)
        logger.Infof("into: %v\n", pluginFolder)
        logger.Info("\n")

        err = downloadFile(plugin.Id, pluginFolder, downloadURL)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">logger.Infof("%s Installed %s successfully \n", color.GreenString("✔"), plugin.Id)

        res, _ := s.ReadPlugin(pluginFolder, pluginName)
        for _, v := range res.Dependencies.Plugins </span><span class="cov0" title="0">{
                InstallPlugin(v.Id, version, c)
                logger.Infof("Installed dependency: %v ✔\n", v.Id)
        }</span>

        <span class="cov0" title="0">return err</span>
}

func SelectVersion(plugin m.Plugin, version string) (m.Version, error) <span class="cov0" title="0">{
        if version == "" </span><span class="cov0" title="0">{
                return plugin.Versions[0], nil
        }</span>

        <span class="cov0" title="0">for _, v := range plugin.Versions </span><span class="cov0" title="0">{
                if v.Version == version </span><span class="cov0" title="0">{
                        return v, nil
                }</span>
        }

        <span class="cov0" title="0">return m.Version{}, errors.New("Could not find the version your looking for")</span>
}

func RemoveGitBuildFromName(pluginName, filename string) string <span class="cov8" title="1">{
        r := regexp.MustCompile("^[a-zA-Z0-9_.-]*/")
        return r.ReplaceAllString(filename, pluginName+"/")
}</span>

var retryCount = 0
var permissionsDeniedMessage = "Could not create %s. Permission denied. Make sure you have write access to plugindir"

func downloadFile(pluginName, filePath, url string) (err error) <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        retryCount++
                        if retryCount &lt; 3 </span><span class="cov0" title="0">{
                                fmt.Println("Failed downloading. Will retry once.")
                                err = downloadFile(pluginName, filePath, url)
                        }</span><span class="cov0" title="0"> else {
                                failure := fmt.Sprintf("%v", r)
                                if failure == "runtime error: makeslice: len out of range" </span><span class="cov0" title="0">{
                                        err = fmt.Errorf("Corrupt http response from source. Please try again.\n")
                                }</span><span class="cov0" title="0"> else {
                                        panic(r)</span>
                                }
                        }
                }
        }()

        <span class="cov0" title="0">resp, err := http.Get(url)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        body, err := ioutil.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">r, err := zip.NewReader(bytes.NewReader(body), resp.ContentLength)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">for _, zf := range r.File </span><span class="cov0" title="0">{
                newFile := path.Join(filePath, RemoveGitBuildFromName(pluginName, zf.Name))

                if zf.FileInfo().IsDir() </span><span class="cov0" title="0">{
                        err := os.Mkdir(newFile, 0777)
                        if PermissionsError(err) </span><span class="cov0" title="0">{
                                return fmt.Errorf(permissionsDeniedMessage, newFile)
                        }</span>
                }<span class="cov0" title="0"> else {
                        dst, err := os.Create(newFile)
                        if PermissionsError(err) </span><span class="cov0" title="0">{
                                return fmt.Errorf(permissionsDeniedMessage, newFile)
                        }</span>

                        <span class="cov0" title="0">src, err := zf.Open()
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Errorf("Failed to extract file: %v", err)
                        }</span>

                        <span class="cov0" title="0">io.Copy(dst, src)
                        dst.Close()
                        src.Close()</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

func PermissionsError(err error) bool <span class="cov0" title="0">{
        return err != nil &amp;&amp; strings.Contains(err.Error(), "permission denied")
}</span>
</pre>
		
		<pre class="file" id="file40" style="display: none">package commands

import (
        "github.com/grafana/grafana/pkg/cmd/grafana-cli/logger"
        s "github.com/grafana/grafana/pkg/cmd/grafana-cli/services"
)

func listremoteCommand(c CommandLine) error <span class="cov0" title="0">{
        plugin, err := s.ListAllPlugins(c.RepoDirectory())

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">for _, i := range plugin.Plugins </span><span class="cov0" title="0">{
                pluginVersion := ""
                if len(i.Versions) &gt; 0 </span><span class="cov0" title="0">{
                        pluginVersion = i.Versions[0].Version
                }</span>

                <span class="cov0" title="0">logger.Infof("id: %v version: %s\n", i.Id, pluginVersion)</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package commands

import (
        "errors"

        "github.com/grafana/grafana/pkg/cmd/grafana-cli/logger"
        s "github.com/grafana/grafana/pkg/cmd/grafana-cli/services"
)

func validateVersionInput(c CommandLine) error <span class="cov0" title="0">{
        arg := c.Args().First()
        if arg == "" </span><span class="cov0" title="0">{
                return errors.New("please specify plugin to list versions for")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func listversionsCommand(c CommandLine) error <span class="cov0" title="0">{
        if err := validateVersionInput(c); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">pluginToList := c.Args().First()

        plugin, err := s.GetPlugin(pluginToList, c.GlobalString("repo"))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">for _, i := range plugin.Versions </span><span class="cov0" title="0">{
                logger.Infof("%v\n", i.Version)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package commands

import (
        "errors"
        "fmt"

        "github.com/fatih/color"
        "github.com/grafana/grafana/pkg/cmd/grafana-cli/logger"
        m "github.com/grafana/grafana/pkg/cmd/grafana-cli/models"
        s "github.com/grafana/grafana/pkg/cmd/grafana-cli/services"
)

var ls_getPlugins func(path string) []m.InstalledPlugin = s.GetLocalPlugins

var validateLsCommand = func(pluginDir string) error <span class="cov8" title="1">{
        if pluginDir == "" </span><span class="cov8" title="1">{
                return errors.New("missing path flag")
        }</span>

        <span class="cov0" title="0">logger.Debug("plugindir: " + pluginDir + "\n")
        pluginDirInfo, err := s.IoHelper.Stat(pluginDir)

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error: %s", err)
        }</span>

        <span class="cov0" title="0">if pluginDirInfo.IsDir() == false </span><span class="cov0" title="0">{
                return errors.New("plugin path is not a directory")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func lsCommand(c CommandLine) error <span class="cov8" title="1">{
        pluginDir := c.PluginDirectory()
        if err := validateLsCommand(pluginDir); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov0" title="0">plugins := ls_getPlugins(pluginDir)

        if len(plugins) &gt; 0 </span><span class="cov0" title="0">{
                logger.Info("installed plugins:\n")
        }</span>

        <span class="cov0" title="0">for _, plugin := range plugins </span><span class="cov0" title="0">{
                logger.Infof("%s %s %s \n", plugin.Id, color.YellowString("@"), plugin.Info.Version)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package commands

import (
        "errors"
        "fmt"
        m "github.com/grafana/grafana/pkg/cmd/grafana-cli/models"
        services "github.com/grafana/grafana/pkg/cmd/grafana-cli/services"
        "strings"
)

var getPluginss func(path string) []m.InstalledPlugin = services.GetLocalPlugins
var removePlugin func(pluginPath, id string) error = services.RemoveInstalledPlugin

func removeCommand(c CommandLine) error <span class="cov0" title="0">{
        pluginPath := c.PluginDirectory()

        plugin := c.Args().First()
        if plugin == "" </span><span class="cov0" title="0">{
                return errors.New("Missing plugin parameter")
        }</span>

        <span class="cov0" title="0">err := removePlugin(pluginPath, plugin)

        if err != nil </span><span class="cov0" title="0">{
                if strings.Contains(err.Error(), "no such file or directory") </span><span class="cov0" title="0">{
                        return fmt.Errorf("Plugin does not exist")
                }</span>

                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package commands

import (
        "fmt"

        "github.com/fatih/color"
        "github.com/grafana/grafana/pkg/bus"
        "github.com/grafana/grafana/pkg/cmd/grafana-cli/logger"
        "github.com/grafana/grafana/pkg/models"
        "github.com/grafana/grafana/pkg/util"
)

const AdminUserId = 1

func resetPasswordCommand(c CommandLine) error <span class="cov0" title="0">{
        newPassword := c.Args().First()

        password := models.Password(newPassword)
        if password.IsWeak() </span><span class="cov0" title="0">{
                return fmt.Errorf("New password is too short")
        }</span>

        <span class="cov0" title="0">userQuery := models.GetUserByIdQuery{Id: AdminUserId}

        if err := bus.Dispatch(&amp;userQuery); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Could not read user from database. Error: %v", err)
        }</span>

        <span class="cov0" title="0">passwordHashed := util.EncodePassword(newPassword, userQuery.Result.Salt)

        cmd := models.ChangeUserPasswordCommand{
                UserId:      AdminUserId,
                NewPassword: passwordHashed,
        }

        if err := bus.Dispatch(&amp;cmd); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Failed to update user password")
        }</span>

        <span class="cov0" title="0">logger.Infof("\n")
        logger.Infof("Admin password changed successfully %s", color.GreenString("✔"))

        return nil</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">package commands

import (
        "github.com/grafana/grafana/pkg/cmd/grafana-cli/logger"
        m "github.com/grafana/grafana/pkg/cmd/grafana-cli/models"
        s "github.com/grafana/grafana/pkg/cmd/grafana-cli/services"
        "github.com/hashicorp/go-version"
)

func ShouldUpgrade(installed string, remote m.Plugin) bool <span class="cov8" title="1">{
        installedVersion, err1 := version.NewVersion(installed)

        if err1 != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">for _, v := range remote.Versions </span><span class="cov8" title="1">{
                remoteVersion, err2 := version.NewVersion(v.Version)

                if err2 == nil </span><span class="cov8" title="1">{
                        if installedVersion.LessThan(remoteVersion) </span><span class="cov8" title="1">{
                                return true
                        }</span>
                }
        }

        <span class="cov8" title="1">return false</span>
}

func upgradeAllCommand(c CommandLine) error <span class="cov0" title="0">{
        pluginsDir := c.PluginDirectory()

        localPlugins := s.GetLocalPlugins(pluginsDir)

        remotePlugins, err := s.ListAllPlugins(c.GlobalString("repo"))

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">pluginsToUpgrade := make([]m.InstalledPlugin, 0)

        for _, localPlugin := range localPlugins </span><span class="cov0" title="0">{
                for _, remotePlugin := range remotePlugins.Plugins </span><span class="cov0" title="0">{
                        if localPlugin.Id == remotePlugin.Id </span><span class="cov0" title="0">{
                                if ShouldUpgrade(localPlugin.Info.Version, remotePlugin) </span><span class="cov0" title="0">{
                                        pluginsToUpgrade = append(pluginsToUpgrade, localPlugin)
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">for _, p := range pluginsToUpgrade </span><span class="cov0" title="0">{
                logger.Infof("Updating %v \n", p.Id)

                var err error
                err = s.RemoveInstalledPlugin(pluginsDir, p.Id)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">err = InstallPlugin(p.Id, "", c)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">package commands

import (
        "github.com/fatih/color"
        "github.com/grafana/grafana/pkg/cmd/grafana-cli/logger"
        s "github.com/grafana/grafana/pkg/cmd/grafana-cli/services"
)

func upgradeCommand(c CommandLine) error <span class="cov0" title="0">{
        pluginsDir := c.PluginDirectory()
        pluginName := c.Args().First()

        localPlugin, err := s.ReadPlugin(pluginsDir, pluginName)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">v, err2 := s.GetPlugin(localPlugin.Id, c.RepoDirectory())

        if err2 != nil </span><span class="cov0" title="0">{
                return err2
        }</span>

        <span class="cov0" title="0">if ShouldUpgrade(localPlugin.Info.Version, v) </span><span class="cov0" title="0">{
                s.RemoveInstalledPlugin(pluginsDir, pluginName)
                return InstallPlugin(localPlugin.Id, "", c)
        }</span>

        <span class="cov0" title="0">logger.Infof("%s %s is up to date \n", color.GreenString("✔"), localPlugin.Id)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">package apikeygen

import (
        "encoding/base64"
        "encoding/json"
        "errors"

        "github.com/grafana/grafana/pkg/util"
)

var ErrInvalidApiKey = errors.New("Invalid Api Key")

type KeyGenResult struct {
        HashedKey    string
        ClientSecret string
}

type ApiKeyJson struct {
        Key   string `json:"k"`
        Name  string `json:"n"`
        OrgId int64  `json:"id"`
}

func New(orgId int64, name string) KeyGenResult <span class="cov8" title="1">{
        jsonKey := ApiKeyJson{}

        jsonKey.OrgId = orgId
        jsonKey.Name = name
        jsonKey.Key = util.GetRandomString(32)

        result := KeyGenResult{}
        result.HashedKey = util.EncodePassword(jsonKey.Key, name)

        jsonString, _ := json.Marshal(jsonKey)

        result.ClientSecret = base64.StdEncoding.EncodeToString([]byte(jsonString))
        return result
}</span>

func Decode(keyString string) (*ApiKeyJson, error) <span class="cov8" title="1">{
        jsonString, err := base64.StdEncoding.DecodeString(keyString)
        if err != nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidApiKey
        }</span>

        <span class="cov8" title="1">var keyObj ApiKeyJson
        err = json.Unmarshal([]byte(jsonString), &amp;keyObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidApiKey
        }</span>

        <span class="cov8" title="1">return &amp;keyObj, nil</span>
}

func IsValid(key *ApiKeyJson, hashedKey string) bool <span class="cov0" title="0">{
        check := util.EncodePassword(key.Key, key.Name)
        return check == hashedKey
}</span>
</pre>
		
		<pre class="file" id="file48" style="display: none">// uses code from https://github.com/antonholmquist/jason/blob/master/jason.go
// MIT Licence

package dynmap

import (
        "bytes"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "strings"
)

// Error values returned when validation functions fail
var (
        ErrNotNull        = errors.New("is not null")
        ErrNotArray       = errors.New("Not an array")
        ErrNotNumber      = errors.New("not a number")
        ErrNotBool        = errors.New("no bool")
        ErrNotObject      = errors.New("not an object")
        ErrNotObjectArray = errors.New("not an object array")
        ErrNotString      = errors.New("not a string")
)

type KeyNotFoundError struct {
        Key string
}

func (k KeyNotFoundError) Error() string <span class="cov0" title="0">{
        if k.Key != "" </span><span class="cov0" title="0">{
                return fmt.Sprintf("key '%s' not found", k.Key)
        }</span>

        <span class="cov0" title="0">return "key not found"</span>
}

// Value represents an arbitrary JSON value.
// It may contain a bool, number, string, object, array or null.
type Value struct {
        data   interface{}
        exists bool // Used to separate nil and non-existing values
}

// Object represents an object JSON object.
// It inherets from Value but with an additional method to access
// a map representation of it's content. It's useful when iterating.
type Object struct {
        Value
        m     map[string]*Value
        valid bool
}

// Returns the golang map.
// Needed when iterating through the values of the object.
func (v *Object) Map() map[string]*Value <span class="cov8" title="1">{
        return v.m
}</span>

func NewFromMap(data map[string]interface{}) *Object <span class="cov0" title="0">{
        val := &amp;Value{data: data, exists: true}
        obj, _ := val.Object()
        return obj
}</span>

func NewObject() *Object <span class="cov0" title="0">{
        val := &amp;Value{data: make(map[string]interface{}), exists: true}
        obj, _ := val.Object()
        return obj
}</span>

// Creates a new value from an io.reader.
// Returns an error if the reader does not contain valid json.
// Useful for parsing the body of a net/http response.
// Example: NewFromReader(res.Body)
func NewValueFromReader(reader io.Reader) (*Value, error) <span class="cov8" title="1">{
        j := new(Value)
        d := json.NewDecoder(reader)
        d.UseNumber()
        err := d.Decode(&amp;j.data)
        return j, err
}</span>

// Creates a new value from bytes.
// Returns an error if the bytes are not valid json.
func NewValueFromBytes(b []byte) (*Value, error) <span class="cov8" title="1">{
        r := bytes.NewReader(b)
        return NewValueFromReader(r)
}</span>

func objectFromValue(v *Value, err error) (*Object, error) <span class="cov8" title="1">{
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">o, err := v.Object()

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return o, nil</span>
}

func NewObjectFromBytes(b []byte) (*Object, error) <span class="cov8" title="1">{
        return objectFromValue(NewValueFromBytes(b))
}</span>

func NewObjectFromReader(reader io.Reader) (*Object, error) <span class="cov0" title="0">{
        return objectFromValue(NewValueFromReader(reader))
}</span>

// Marshal into bytes.
func (v *Value) Marshal() ([]byte, error) <span class="cov0" title="0">{
        return json.Marshal(v.data)
}</span>

// Get the interyling data as interface
func (v *Value) Interface() interface{} <span class="cov8" title="1">{
        return v.data
}</span>

func (v *Value) StringMap() map[string]interface{} <span class="cov0" title="0">{
        return v.data.(map[string]interface{})
}</span>

// Private Get
func (v *Value) get(key string) (*Value, error) <span class="cov8" title="1">{

        // Assume this is an object
        obj, err := v.Object()

        if err == nil </span><span class="cov8" title="1">{
                child, ok := obj.Map()[key]
                if ok </span><span class="cov8" title="1">{
                        return child, nil
                }</span><span class="cov8" title="1"> else {
                        return nil, KeyNotFoundError{key}
                }</span>
        }

        <span class="cov0" title="0">return nil, err</span>
}

// Private get path
func (v *Value) getPath(keys []string) (*Value, error) <span class="cov8" title="1">{
        current := v
        var err error
        for _, key := range keys </span><span class="cov8" title="1">{
                current, err = current.get(key)

                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
        }
        <span class="cov8" title="1">return current, nil</span>
}

// Gets the value at key path.
// Returns error if the value does not exist.
// Consider using the more specific Get&lt;Type&gt;(..) methods instead.
// Example:
//                value, err := GetValue("address", "street")
func (v *Object) GetValue(keys ...string) (*Value, error) <span class="cov8" title="1">{
        return v.getPath(keys)
}</span>

// Gets the value at key path and attempts to typecast the value into an object.
// Returns error if the value is not a json object.
// Example:
//                object, err := GetObject("person", "address")
func (v *Object) GetObject(keys ...string) (*Object, error) <span class="cov8" title="1">{
        child, err := v.getPath(keys)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span><span class="cov8" title="1"> else {

                obj, err := child.Object()

                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span><span class="cov8" title="1"> else {
                        return obj, nil
                }</span>

        }
}

// Gets the value at key path and attempts to typecast the value into a string.
// Returns error if the value is not a json string.
// Example:
//                string, err := GetString("address", "street")
func (v *Object) GetString(keys ...string) (string, error) <span class="cov8" title="1">{
        child, err := v.getPath(keys)

        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span><span class="cov8" title="1"> else {
                return child.String()
        }</span>
}

func (v *Object) MustGetString(path string, def string) string <span class="cov8" title="1">{
        keys := strings.Split(path, ".")
        if str, err := v.GetString(keys...); err != nil </span><span class="cov8" title="1">{
                return def
        }</span><span class="cov8" title="1"> else {
                return str
        }</span>
}

// Gets the value at key path and attempts to typecast the value into null.
// Returns error if the value is not json null.
// Example:
//                err := GetNull("address", "street")
func (v *Object) GetNull(keys ...string) error <span class="cov8" title="1">{
        child, err := v.getPath(keys)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return child.Null()</span>
}

// Gets the value at key path and attempts to typecast the value into a number.
// Returns error if the value is not a json number.
// Example:
//                n, err := GetNumber("address", "street_number")
func (v *Object) GetNumber(keys ...string) (json.Number, error) <span class="cov8" title="1">{
        child, err := v.getPath(keys)

        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span><span class="cov8" title="1"> else {

                n, err := child.Number()

                if err != nil </span><span class="cov8" title="1">{
                        return "", err
                }</span><span class="cov8" title="1"> else {
                        return n, nil
                }</span>
        }
}

// Gets the value at key path and attempts to typecast the value into a float64.
// Returns error if the value is not a json number.
// Example:
//                n, err := GetNumber("address", "street_number")
func (v *Object) GetFloat64(keys ...string) (float64, error) <span class="cov0" title="0">{
        child, err := v.getPath(keys)

        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span><span class="cov0" title="0"> else {

                n, err := child.Float64()

                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span><span class="cov0" title="0"> else {
                        return n, nil
                }</span>
        }
}

// Gets the value at key path and attempts to typecast the value into a float64.
// Returns error if the value is not a json number.
// Example:
//                n, err := GetNumber("address", "street_number")
func (v *Object) GetInt64(keys ...string) (int64, error) <span class="cov8" title="1">{
        child, err := v.getPath(keys)

        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span><span class="cov8" title="1"> else {

                n, err := child.Int64()

                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span><span class="cov8" title="1"> else {
                        return n, nil
                }</span>
        }
}

// Gets the value at key path and attempts to typecast the value into a float64.
// Returns error if the value is not a json number.
// Example:
//                v, err := GetInterface("address", "anything")
func (v *Object) GetInterface(keys ...string) (interface{}, error) <span class="cov8" title="1">{
        child, err := v.getPath(keys)

        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span><span class="cov8" title="1"> else {
                return child.Interface(), nil
        }</span>
}

// Gets the value at key path and attempts to typecast the value into a bool.
// Returns error if the value is not a json boolean.
// Example:
//                married, err := GetBoolean("person", "married")
func (v *Object) GetBoolean(keys ...string) (bool, error) <span class="cov8" title="1">{
        child, err := v.getPath(keys)

        if err != nil </span><span class="cov8" title="1">{
                return false, err
        }</span>

        <span class="cov8" title="1">return child.Boolean()</span>
}

// Gets the value at key path and attempts to typecast the value into an array.
// Returns error if the value is not a json array.
// Consider using the more specific Get&lt;Type&gt;Array() since it may reduce later type casts.
// Example:
//                friends, err := GetValueArray("person", "friends")
//                for i, friend := range friends {
//                        ... // friend will be of type Value here
//                }
func (v *Object) GetValueArray(keys ...string) ([]*Value, error) <span class="cov8" title="1">{
        child, err := v.getPath(keys)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span><span class="cov8" title="1"> else {

                return child.Array()

        }</span>
}

// Gets the value at key path and attempts to typecast the value into an array of objects.
// Returns error if the value is not a json array or if any of the contained objects are not objects.
// Example:
//                friends, err := GetObjectArray("person", "friends")
//                for i, friend := range friends {
//                        ... // friend will be of type Object here
//                }
func (v *Object) GetObjectArray(keys ...string) ([]*Object, error) <span class="cov8" title="1">{
        child, err := v.getPath(keys)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span><span class="cov8" title="1"> else {

                array, err := child.Array()

                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span><span class="cov8" title="1"> else {

                        typedArray := make([]*Object, len(array))

                        for index, arrayItem := range array </span><span class="cov8" title="1">{
                                typedArrayItem, err := arrayItem.
                                        Object()

                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span><span class="cov8" title="1"> else {
                                        typedArray[index] = typedArrayItem
                                }</span>

                        }
                        <span class="cov8" title="1">return typedArray, nil</span>
                }
        }
}

// Gets the value at key path and attempts to typecast the value into an array of string.
// Returns error if the value is not a json array or if any of the contained objects are not strings.
// Gets the value at key path and attempts to typecast the value into an array of objects.
// Returns error if the value is not a json array or if any of the contained objects are not objects.
// Example:
//                friendNames, err := GetStringArray("person", "friend_names")
//                for i, friendName := range friendNames {
//                        ... // friendName will be of type string here
//                }
func (v *Object) GetStringArray(keys ...string) ([]string, error) <span class="cov8" title="1">{
        child, err := v.getPath(keys)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span><span class="cov8" title="1"> else {

                array, err := child.Array()

                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span><span class="cov8" title="1"> else {

                        typedArray := make([]string, len(array))

                        for index, arrayItem := range array </span><span class="cov8" title="1">{
                                typedArrayItem, err := arrayItem.String()

                                if err != nil </span><span class="cov8" title="1">{
                                        return nil, err
                                }</span><span class="cov0" title="0"> else {
                                        typedArray[index] = typedArrayItem
                                }</span>

                        }
                        <span class="cov0" title="0">return typedArray, nil</span>
                }
        }
}

// Gets the value at key path and attempts to typecast the value into an array of numbers.
// Returns error if the value is not a json array or if any of the contained objects are not numbers.
// Example:
//                friendAges, err := GetNumberArray("person", "friend_ages")
//                for i, friendAge := range friendAges {
//                        ... // friendAge will be of type float64 here
//                }
func (v *Object) GetNumberArray(keys ...string) ([]json.Number, error) <span class="cov0" title="0">{
        child, err := v.getPath(keys)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span><span class="cov0" title="0"> else {

                array, err := child.Array()

                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span><span class="cov0" title="0"> else {

                        typedArray := make([]json.Number, len(array))

                        for index, arrayItem := range array </span><span class="cov0" title="0">{
                                typedArrayItem, err := arrayItem.Number()

                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span><span class="cov0" title="0"> else {
                                        typedArray[index] = typedArrayItem
                                }</span>

                        }
                        <span class="cov0" title="0">return typedArray, nil</span>
                }
        }
}

// Gets the value at key path and attempts to typecast the value into an array of floats.
// Returns error if the value is not a json array or if any of the contained objects are not numbers.
func (v *Object) GetFloat64Array(keys ...string) ([]float64, error) <span class="cov0" title="0">{
        child, err := v.getPath(keys)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span><span class="cov0" title="0"> else {

                array, err := child.Array()

                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span><span class="cov0" title="0"> else {

                        typedArray := make([]float64, len(array))

                        for index, arrayItem := range array </span><span class="cov0" title="0">{
                                typedArrayItem, err := arrayItem.Float64()

                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span><span class="cov0" title="0"> else {
                                        typedArray[index] = typedArrayItem
                                }</span>

                        }
                        <span class="cov0" title="0">return typedArray, nil</span>
                }
        }
}

// Gets the value at key path and attempts to typecast the value into an array of ints.
// Returns error if the value is not a json array or if any of the contained objects are not numbers.
func (v *Object) GetInt64Array(keys ...string) ([]int64, error) <span class="cov0" title="0">{
        child, err := v.getPath(keys)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span><span class="cov0" title="0"> else {

                array, err := child.Array()

                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span><span class="cov0" title="0"> else {

                        typedArray := make([]int64, len(array))

                        for index, arrayItem := range array </span><span class="cov0" title="0">{
                                typedArrayItem, err := arrayItem.Int64()

                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span><span class="cov0" title="0"> else {
                                        typedArray[index] = typedArrayItem
                                }</span>

                        }
                        <span class="cov0" title="0">return typedArray, nil</span>
                }
        }
}

// Gets the value at key path and attempts to typecast the value into an array of bools.
// Returns error if the value is not a json array or if any of the contained objects are not booleans.
func (v *Object) GetBooleanArray(keys ...string) ([]bool, error) <span class="cov0" title="0">{
        child, err := v.getPath(keys)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span><span class="cov0" title="0"> else {

                array, err := child.Array()

                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span><span class="cov0" title="0"> else {

                        typedArray := make([]bool, len(array))

                        for index, arrayItem := range array </span><span class="cov0" title="0">{
                                typedArrayItem, err := arrayItem.Boolean()

                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span><span class="cov0" title="0"> else {
                                        typedArray[index] = typedArrayItem
                                }</span>

                        }
                        <span class="cov0" title="0">return typedArray, nil</span>
                }
        }
}

// Gets the value at key path and attempts to typecast the value into an array of nulls.
// Returns length, or an error if the value is not a json array or if any of the contained objects are not nulls.
func (v *Object) GetNullArray(keys ...string) (int64, error) <span class="cov0" title="0">{
        child, err := v.getPath(keys)

        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span><span class="cov0" title="0"> else {

                array, err := child.Array()

                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span><span class="cov0" title="0"> else {

                        var length int64 = 0

                        for _, arrayItem := range array </span><span class="cov0" title="0">{
                                err := arrayItem.Null()

                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span><span class="cov0" title="0"> else {
                                        length++
                                }</span>

                        }
                        <span class="cov0" title="0">return length, nil</span>
                }
        }
}

// Returns an error if the value is not actually null
func (v *Value) Null() error <span class="cov8" title="1">{
        var valid bool

        // Check the type of this data
        switch v.data.(type) </span>{
        case nil:<span class="cov0" title="0">
                valid = v.exists // Valid only if j also exists, since other values could possibly also be nil
                break</span>
        }

        <span class="cov8" title="1">if valid </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">return ErrNotNull</span>

}

// Attempts to typecast the current value into an array.
// Returns error if the current value is not a json array.
// Example:
//                friendsArray, err := friendsValue.Array()
func (v *Value) Array() ([]*Value, error) <span class="cov8" title="1">{
        var valid bool

        // Check the type of this data
        switch v.data.(type) </span>{
        case []interface{}:<span class="cov8" title="1">
                valid = true
                break</span>
        }

        // Unsure if this is a good way to use slices, it's probably not
        <span class="cov8" title="1">var slice []*Value

        if valid </span><span class="cov8" title="1">{

                for _, element := range v.data.([]interface{}) </span><span class="cov8" title="1">{
                        child := Value{element, true}
                        slice = append(slice, &amp;child)
                }</span>

                <span class="cov8" title="1">return slice, nil</span>
        }

        <span class="cov8" title="1">return slice, ErrNotArray</span>

}

// Attempts to typecast the current value into a number.
// Returns error if the current value is not a json number.
// Example:
//                ageNumber, err := ageValue.Number()
func (v *Value) Number() (json.Number, error) <span class="cov8" title="1">{
        var valid bool

        // Check the type of this data
        switch v.data.(type) </span>{
        case json.Number:<span class="cov8" title="1">
                valid = true
                break</span>
        }

        <span class="cov8" title="1">if valid </span><span class="cov8" title="1">{
                return v.data.(json.Number), nil
        }</span>

        <span class="cov8" title="1">return "", ErrNotNumber</span>
}

// Attempts to typecast the current value into a float64.
// Returns error if the current value is not a json number.
// Example:
//                percentage, err := v.Float64()
func (v *Value) Float64() (float64, error) <span class="cov0" title="0">{
        n, err := v.Number()

        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">return n.Float64()</span>
}

// Attempts to typecast the current value into a int64.
// Returns error if the current value is not a json number.
// Example:
//                id, err := v.Int64()
func (v *Value) Int64() (int64, error) <span class="cov8" title="1">{
        n, err := v.Number()

        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov8" title="1">return n.Int64()</span>
}

// Attempts to typecast the current value into a bool.
// Returns error if the current value is not a json boolean.
// Example:
//                marriedBool, err := marriedValue.Boolean()
func (v *Value) Boolean() (bool, error) <span class="cov8" title="1">{
        var valid bool

        // Check the type of this data
        switch v.data.(type) </span>{
        case bool:<span class="cov8" title="1">
                valid = true
                break</span>
        }

        <span class="cov8" title="1">if valid </span><span class="cov8" title="1">{
                return v.data.(bool), nil
        }</span>

        <span class="cov8" title="1">return false, ErrNotBool</span>
}

// Attempts to typecast the current value into an object.
// Returns error if the current value is not a json object.
// Example:
//                friendObject, err := friendValue.Object()
func (v *Value) Object() (*Object, error) <span class="cov8" title="1">{

        var valid bool

        // Check the type of this data
        switch v.data.(type) </span>{
        case map[string]interface{}:<span class="cov8" title="1">
                valid = true
                break</span>
        }

        <span class="cov8" title="1">if valid </span><span class="cov8" title="1">{
                obj := new(Object)
                obj.valid = valid

                m := make(map[string]*Value)

                if valid </span><span class="cov8" title="1">{
                        for key, element := range v.data.(map[string]interface{}) </span><span class="cov8" title="1">{
                                m[key] = &amp;Value{element, true}

                        }</span>
                }

                <span class="cov8" title="1">obj.data = v.data
                obj.m = m

                return obj, nil</span>
        }

        <span class="cov8" title="1">return nil, ErrNotObject</span>
}

// Attempts to typecast the current value into an object arrau.
// Returns error if the current value is not an array of json objects
// Example:
//                friendObjects, err := friendValues.ObjectArray()
func (v *Value) ObjectArray() ([]*Object, error) <span class="cov8" title="1">{

        var valid bool

        // Check the type of this data
        switch v.data.(type) </span>{
        case []interface{}:<span class="cov8" title="1">
                valid = true
                break</span>
        }

        // Unsure if this is a good way to use slices, it's probably not
        <span class="cov8" title="1">var slice []*Object

        if valid </span><span class="cov8" title="1">{

                for _, element := range v.data.([]interface{}) </span><span class="cov8" title="1">{
                        childValue := Value{element, true}
                        childObject, err := childValue.Object()

                        if err != nil </span><span class="cov0" title="0">{
                                return nil, ErrNotObjectArray
                        }</span>
                        <span class="cov8" title="1">slice = append(slice, childObject)</span>
                }

                <span class="cov8" title="1">return slice, nil</span>
        }

        <span class="cov0" title="0">return nil, ErrNotObjectArray</span>

}

// Attempts to typecast the current value into a string.
// Returns error if the current value is not a json string
// Example:
//                nameObject, err := nameValue.String()
func (v *Value) String() (string, error) <span class="cov8" title="1">{
        var valid bool

        // Check the type of this data
        switch v.data.(type) </span>{
        case string:<span class="cov8" title="1">
                valid = true
                break</span>
        }

        <span class="cov8" title="1">if valid </span><span class="cov8" title="1">{
                return v.data.(string), nil
        }</span>

        <span class="cov8" title="1">return "", ErrNotString</span>
}

// Returns the value a json formatted string.
// Note: The method named String() is used by golang's log method for logging.
// Example:
func (v *Object) String() string <span class="cov0" title="0">{

        f, err := json.Marshal(v.data)
        if err != nil </span><span class="cov0" title="0">{
                return err.Error()
        }</span>

        <span class="cov0" title="0">return string(f)</span>

}

func (v *Object) SetValue(key string, value interface{}) *Value <span class="cov8" title="1">{
        data := v.Interface().(map[string]interface{})
        data[key] = value

        return &amp;Value{
                data:   value,
                exists: true,
        }
}</span>
</pre>
		
		<pre class="file" id="file49" style="display: none">package imguploader

import (
        "fmt"
        "regexp"

        "github.com/grafana/grafana/pkg/setting"
)

type ImageUploader interface {
        Upload(path string) (string, error)
}

type NopImageUploader struct {
}

func (NopImageUploader) Upload(path string) (string, error) <span class="cov0" title="0">{
        return "", nil
}</span>

func NewImageUploader() (ImageUploader, error) <span class="cov8" title="1">{

        switch setting.ImageUploadProvider </span>{
        case "s3":<span class="cov8" title="1">
                s3sec, err := setting.Cfg.GetSection("external_image_storage.s3")
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">bucket := s3sec.Key("bucket_url").MustString("")
                accessKey := s3sec.Key("access_key").MustString("")
                secretKey := s3sec.Key("secret_key").MustString("")

                region := ""
                rBucket := regexp.MustCompile(`https?:\/\/(.*)\.s3(-([^.]+))?\.amazonaws\.com\/?`)
                matches := rBucket.FindStringSubmatch(bucket)
                if len(matches) == 0 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("Could not find bucket setting for image.uploader.s3")
                }</span><span class="cov8" title="1"> else {
                        bucket = matches[1]
                        if matches[3] != "" </span><span class="cov8" title="1">{
                                region = matches[3]
                        }</span><span class="cov0" title="0"> else {
                                region = "us-east-1"
                        }</span>
                }

                <span class="cov8" title="1">return NewS3Uploader(region, bucket, "public-read", accessKey, secretKey), nil</span>
        case "webdav":<span class="cov8" title="1">
                webdavSec, err := setting.Cfg.GetSection("external_image_storage.webdav")
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">url := webdavSec.Key("url").String()
                if url == "" </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("Could not find url key for image.uploader.webdav")
                }</span>

                <span class="cov8" title="1">username := webdavSec.Key("username").String()
                password := webdavSec.Key("password").String()

                return NewWebdavImageUploader(url, username, password)</span>
        }

        <span class="cov0" title="0">return NopImageUploader{}, nil</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">package imguploader

import (
        "os"
        "time"

        "github.com/aws/aws-sdk-go/aws"
        "github.com/aws/aws-sdk-go/aws/credentials"
        "github.com/aws/aws-sdk-go/aws/credentials/ec2rolecreds"
        "github.com/aws/aws-sdk-go/aws/ec2metadata"
        "github.com/aws/aws-sdk-go/aws/session"
        "github.com/aws/aws-sdk-go/service/s3"
        "github.com/grafana/grafana/pkg/log"
        "github.com/grafana/grafana/pkg/util"
)

type S3Uploader struct {
        region    string
        bucket    string
        acl       string
        secretKey string
        accessKey string
        log       log.Logger
}

func NewS3Uploader(region, bucket, acl, accessKey, secretKey string) *S3Uploader <span class="cov8" title="1">{
        return &amp;S3Uploader{
                region:    region,
                bucket:    bucket,
                acl:       acl,
                accessKey: accessKey,
                secretKey: secretKey,
                log:       log.New("s3uploader"),
        }
}</span>

func (u *S3Uploader) Upload(imageDiskPath string) (string, error) <span class="cov0" title="0">{
        sess := session.New()
        creds := credentials.NewChainCredentials(
                []credentials.Provider{
                        &amp;credentials.StaticProvider{Value: credentials.Value{
                                AccessKeyID:     u.accessKey,
                                SecretAccessKey: u.secretKey,
                        }},
                        &amp;credentials.EnvProvider{},
                        &amp;ec2rolecreds.EC2RoleProvider{Client: ec2metadata.New(sess), ExpiryWindow: 5 * time.Minute},
                })
        cfg := &amp;aws.Config{
                Region:      aws.String(u.region),
                Credentials: creds,
        }

        key := util.GetRandomString(20) + ".png"
        log.Debug("Uploading image to s3", "bucket = ", u.bucket, ", key = ", key)

        file, err := os.Open(imageDiskPath)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">svc := s3.New(session.New(cfg), cfg)
        params := &amp;s3.PutObjectInput{
                Bucket:      aws.String(u.bucket),
                Key:         aws.String(key),
                ACL:         aws.String(u.acl),
                Body:        file,
                ContentType: aws.String("image/png"),
        }
        _, err = svc.PutObject(params)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return "https://" + u.bucket + ".s3.amazonaws.com/" + key, nil</span>
}
</pre>
		
		<pre class="file" id="file51" style="display: none">package imguploader

import (
        "bytes"
        "fmt"
        "io/ioutil"
        "net/http"
        "net/url"
        "path"

        "github.com/grafana/grafana/pkg/util"
)

type WebdavUploader struct {
        url      string
        username string
        password string
}

func (u *WebdavUploader) Upload(pa string) (string, error) <span class="cov0" title="0">{
        url, _ := url.Parse(u.url)
        url.Path = path.Join(url.Path, util.GetRandomString(20)+".png")

        imgData, err := ioutil.ReadFile(pa)
        req, err := http.NewRequest("PUT", url.String(), bytes.NewReader(imgData))

        if u.username != "" </span><span class="cov0" title="0">{
                req.SetBasicAuth(u.username, u.password)
        }</span>

        <span class="cov0" title="0">res, err := http.DefaultClient.Do(req)

        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">if res.StatusCode != http.StatusCreated </span><span class="cov0" title="0">{
                body, _ := ioutil.ReadAll(res.Body)
                return "", fmt.Errorf("Failed to upload image. Returned statuscode %v body %s", res.StatusCode, body)
        }</span>

        <span class="cov0" title="0">return url.String(), nil</span>
}

func NewWebdavImageUploader(url, username, passwrod string) (*WebdavUploader, error) <span class="cov8" title="1">{
        return &amp;WebdavUploader{
                url:      url,
                username: username,
                password: passwrod,
        }, nil
}</span>
</pre>
		
		<pre class="file" id="file52" style="display: none">package renderer

import (
        "fmt"
        "io"
        "os"
        "os/exec"
        "path/filepath"
        "runtime"
        "time"

        "strconv"

        "strings"

        "github.com/grafana/grafana/pkg/log"
        "github.com/grafana/grafana/pkg/middleware"
        "github.com/grafana/grafana/pkg/setting"
        "github.com/grafana/grafana/pkg/util"
)

type RenderOpts struct {
        Path     string
        Width    string
        Height   string
        Timeout  string
        OrgId    int64
        Timezone string
}

var rendererLog log.Logger = log.New("png-renderer")

func isoTimeOffsetToPosixTz(isoOffset string) string <span class="cov0" title="0">{
        // invert offset
        if strings.HasPrefix(isoOffset, "UTC+") </span><span class="cov0" title="0">{
                return strings.Replace(isoOffset, "UTC+", "UTC-", 1)
        }</span>
        <span class="cov0" title="0">if strings.HasPrefix(isoOffset, "UTC-") </span><span class="cov0" title="0">{
                return strings.Replace(isoOffset, "UTC-", "UTC+", 1)
        }</span>
        <span class="cov0" title="0">return isoOffset</span>
}

func appendEnviron(baseEnviron []string, name string, value string) []string <span class="cov0" title="0">{
        results := make([]string, 0)
        prefix := fmt.Sprintf("%s=", name)
        for _, v := range baseEnviron </span><span class="cov0" title="0">{
                if !strings.HasPrefix(v, prefix) </span><span class="cov0" title="0">{
                        results = append(results, v)
                }</span>
        }
        <span class="cov0" title="0">return append(results, fmt.Sprintf("%s=%s", name, value))</span>
}

func RenderToPng(params *RenderOpts) (string, error) <span class="cov0" title="0">{
        rendererLog.Info("Rendering", "path", params.Path)

        var executable = "phantomjs"
        if runtime.GOOS == "windows" </span><span class="cov0" title="0">{
                executable = executable + ".exe"
        }</span>

        <span class="cov0" title="0">localDomain := "localhost"
        if setting.HttpAddr != setting.DEFAULT_HTTP_ADDR </span><span class="cov0" title="0">{
                localDomain = setting.HttpAddr
        }</span>

        <span class="cov0" title="0">url := fmt.Sprintf("%s://%s:%s/%s", setting.Protocol, localDomain, setting.HttpPort, params.Path)

        binPath, _ := filepath.Abs(filepath.Join(setting.PhantomDir, executable))
        scriptPath, _ := filepath.Abs(filepath.Join(setting.PhantomDir, "render.js"))
        pngPath, _ := filepath.Abs(filepath.Join(setting.ImagesDir, util.GetRandomString(20)))
        pngPath = pngPath + ".png"

        renderKey := middleware.AddRenderAuthKey(params.OrgId)
        defer middleware.RemoveRenderAuthKey(renderKey)

        cmdArgs := []string{
                "--ignore-ssl-errors=true",
                "--web-security=false",
                scriptPath,
                "url=" + url,
                "width=" + params.Width,
                "height=" + params.Height,
                "png=" + pngPath,
                "domain=" + localDomain,
                "renderKey=" + renderKey,
        }

        cmd := exec.Command(binPath, cmdArgs...)
        stdout, err := cmd.StdoutPipe()

        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">stderr, err := cmd.StderrPipe()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">if params.Timezone != "" </span><span class="cov0" title="0">{
                baseEnviron := os.Environ()
                cmd.Env = appendEnviron(baseEnviron, "TZ", isoTimeOffsetToPosixTz(params.Timezone))
        }</span>

        <span class="cov0" title="0">err = cmd.Start()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">go io.Copy(os.Stdout, stdout)
        go io.Copy(os.Stdout, stderr)

        done := make(chan error)
        go func() </span><span class="cov0" title="0">{
                cmd.Wait()
                close(done)
        }</span>()

        <span class="cov0" title="0">timeout, err := strconv.Atoi(params.Timeout)
        if err != nil </span><span class="cov0" title="0">{
                timeout = 15
        }</span>

        <span class="cov0" title="0">select </span>{
        case &lt;-time.After(time.Duration(timeout) * time.Second):<span class="cov0" title="0">
                if err := cmd.Process.Kill(); err != nil </span><span class="cov0" title="0">{
                        rendererLog.Error("failed to kill", "error", err)
                }</span>
                <span class="cov0" title="0">return "", fmt.Errorf("PhantomRenderer::renderToPng timeout (&gt;%vs)", timeout)</span>
        case &lt;-done:</span><span class="cov0" title="0">
        }

        <span class="cov0" title="0">rendererLog.Debug("Image rendered", "path", pngPath)
        return pngPath, nil</span>
}
</pre>
		
		<pre class="file" id="file53" style="display: none">package simplejson

import (
        "bytes"
        "encoding/json"
        "errors"
        "log"
)

// returns the current implementation version
func Version() string <span class="cov0" title="0">{
        return "0.5.0"
}</span>

type Json struct {
        data interface{}
}

func (j *Json) FromDB(data []byte) error <span class="cov0" title="0">{
        j.data = make(map[string]interface{})

        dec := json.NewDecoder(bytes.NewBuffer(data))
        dec.UseNumber()
        return dec.Decode(&amp;j.data)
}</span>

func (j *Json) ToDB() ([]byte, error) <span class="cov0" title="0">{
        if j == nil || j.data == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">return j.Encode()</span>
}

// NewJson returns a pointer to a new `Json` object
// after unmarshaling `body` bytes
func NewJson(body []byte) (*Json, error) <span class="cov8" title="1">{
        j := new(Json)
        err := j.UnmarshalJSON(body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return j, nil</span>
}

// New returns a pointer to a new, empty `Json` object
func New() *Json <span class="cov0" title="0">{
        return &amp;Json{
                data: make(map[string]interface{}),
        }
}</span>

// New returns a pointer to a new, empty `Json` object
func NewFromAny(data interface{}) *Json <span class="cov0" title="0">{
        return &amp;Json{data: data}
}</span>

// Interface returns the underlying data
func (j *Json) Interface() interface{} <span class="cov0" title="0">{
        return j.data
}</span>

// Encode returns its marshaled data as `[]byte`
func (j *Json) Encode() ([]byte, error) <span class="cov0" title="0">{
        return j.MarshalJSON()
}</span>

// EncodePretty returns its marshaled data as `[]byte` with indentation
func (j *Json) EncodePretty() ([]byte, error) <span class="cov0" title="0">{
        return json.MarshalIndent(&amp;j.data, "", "  ")
}</span>

// Implements the json.Marshaler interface.
func (j *Json) MarshalJSON() ([]byte, error) <span class="cov8" title="1">{
        return json.Marshal(&amp;j.data)
}</span>

// Set modifies `Json` map by `key` and `value`
// Useful for changing single key/value in a `Json` object easily.
func (j *Json) Set(key string, val interface{}) <span class="cov8" title="1">{
        m, err := j.Map()
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">m[key] = val</span>
}

// SetPath modifies `Json`, recursively checking/creating map keys for the supplied path,
// and then finally writing in the value
func (j *Json) SetPath(branch []string, val interface{}) <span class="cov8" title="1">{
        if len(branch) == 0 </span><span class="cov8" title="1">{
                j.data = val
                return
        }</span>

        // in order to insert our branch, we need map[string]interface{}
        <span class="cov8" title="1">if _, ok := (j.data).(map[string]interface{}); !ok </span><span class="cov0" title="0">{
                // have to replace with something suitable
                j.data = make(map[string]interface{})
        }</span>
        <span class="cov8" title="1">curr := j.data.(map[string]interface{})

        for i := 0; i &lt; len(branch)-1; i++ </span><span class="cov8" title="1">{
                b := branch[i]
                // key exists?
                if _, ok := curr[b]; !ok </span><span class="cov8" title="1">{
                        n := make(map[string]interface{})
                        curr[b] = n
                        curr = n
                        continue</span>
                }

                // make sure the value is the right sort of thing
                <span class="cov8" title="1">if _, ok := curr[b].(map[string]interface{}); !ok </span><span class="cov8" title="1">{
                        // have to replace with something suitable
                        n := make(map[string]interface{})
                        curr[b] = n
                }</span>

                <span class="cov8" title="1">curr = curr[b].(map[string]interface{})</span>
        }

        // add remaining k/v
        <span class="cov8" title="1">curr[branch[len(branch)-1]] = val</span>
}

// Del modifies `Json` map by deleting `key` if it is present.
func (j *Json) Del(key string) <span class="cov8" title="1">{
        m, err := j.Map()
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">delete(m, key)</span>
}

// Get returns a pointer to a new `Json` object
// for `key` in its `map` representation
//
// useful for chaining operations (to traverse a nested JSON):
//    js.Get("top_level").Get("dict").Get("value").Int()
func (j *Json) Get(key string) *Json <span class="cov8" title="1">{
        m, err := j.Map()
        if err == nil </span><span class="cov8" title="1">{
                if val, ok := m[key]; ok </span><span class="cov8" title="1">{
                        return &amp;Json{val}
                }</span>
        }
        <span class="cov8" title="1">return &amp;Json{nil}</span>
}

// GetPath searches for the item as specified by the branch
// without the need to deep dive using Get()'s.
//
//   js.GetPath("top_level", "dict")
func (j *Json) GetPath(branch ...string) *Json <span class="cov8" title="1">{
        jin := j
        for _, p := range branch </span><span class="cov8" title="1">{
                jin = jin.Get(p)
        }</span>
        <span class="cov8" title="1">return jin</span>
}

// GetIndex returns a pointer to a new `Json` object
// for `index` in its `array` representation
//
// this is the analog to Get when accessing elements of
// a json array instead of a json object:
//    js.Get("top_level").Get("array").GetIndex(1).Get("key").Int()
func (j *Json) GetIndex(index int) *Json <span class="cov8" title="1">{
        a, err := j.Array()
        if err == nil </span><span class="cov8" title="1">{
                if len(a) &gt; index </span><span class="cov8" title="1">{
                        return &amp;Json{a[index]}
                }</span>
        }
        <span class="cov0" title="0">return &amp;Json{nil}</span>
}

// CheckGet returns a pointer to a new `Json` object and
// a `bool` identifying success or failure
//
// useful for chained operations when success is important:
//    if data, ok := js.Get("top_level").CheckGet("inner"); ok {
//        log.Println(data)
//    }
func (j *Json) CheckGet(key string) (*Json, bool) <span class="cov8" title="1">{
        m, err := j.Map()
        if err == nil </span><span class="cov8" title="1">{
                if val, ok := m[key]; ok </span><span class="cov8" title="1">{
                        return &amp;Json{val}, true
                }</span>
        }
        <span class="cov8" title="1">return nil, false</span>
}

// Map type asserts to `map`
func (j *Json) Map() (map[string]interface{}, error) <span class="cov8" title="1">{
        if m, ok := (j.data).(map[string]interface{}); ok </span><span class="cov8" title="1">{
                return m, nil
        }</span>
        <span class="cov8" title="1">return nil, errors.New("type assertion to map[string]interface{} failed")</span>
}

// Array type asserts to an `array`
func (j *Json) Array() ([]interface{}, error) <span class="cov8" title="1">{
        if a, ok := (j.data).([]interface{}); ok </span><span class="cov8" title="1">{
                return a, nil
        }</span>
        <span class="cov8" title="1">return nil, errors.New("type assertion to []interface{} failed")</span>
}

// Bool type asserts to `bool`
func (j *Json) Bool() (bool, error) <span class="cov8" title="1">{
        if s, ok := (j.data).(bool); ok </span><span class="cov8" title="1">{
                return s, nil
        }</span>
        <span class="cov0" title="0">return false, errors.New("type assertion to bool failed")</span>
}

// String type asserts to `string`
func (j *Json) String() (string, error) <span class="cov8" title="1">{
        if s, ok := (j.data).(string); ok </span><span class="cov8" title="1">{
                return s, nil
        }</span>
        <span class="cov8" title="1">return "", errors.New("type assertion to string failed")</span>
}

// Bytes type asserts to `[]byte`
func (j *Json) Bytes() ([]byte, error) <span class="cov0" title="0">{
        if s, ok := (j.data).(string); ok </span><span class="cov0" title="0">{
                return []byte(s), nil
        }</span>
        <span class="cov0" title="0">return nil, errors.New("type assertion to []byte failed")</span>
}

// StringArray type asserts to an `array` of `string`
func (j *Json) StringArray() ([]string, error) <span class="cov8" title="1">{
        arr, err := j.Array()
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">retArr := make([]string, 0, len(arr))
        for _, a := range arr </span><span class="cov8" title="1">{
                if a == nil </span><span class="cov8" title="1">{
                        retArr = append(retArr, "")
                        continue</span>
                }
                <span class="cov8" title="1">s, ok := a.(string)
                if !ok </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">retArr = append(retArr, s)</span>
        }
        <span class="cov8" title="1">return retArr, nil</span>
}

// MustArray guarantees the return of a `[]interface{}` (with optional default)
//
// useful when you want to interate over array values in a succinct manner:
//                for i, v := range js.Get("results").MustArray() {
//                        fmt.Println(i, v)
//                }
func (j *Json) MustArray(args ...[]interface{}) []interface{} <span class="cov8" title="1">{
        var def []interface{}

        switch len(args) </span>{
        case 0:</span><span class="cov0" title="0">
        case 1:<span class="cov8" title="1">
                def = args[0]</span>
        default:<span class="cov0" title="0">
                log.Panicf("MustArray() received too many arguments %d", len(args))</span>
        }

        <span class="cov8" title="1">a, err := j.Array()
        if err == nil </span><span class="cov0" title="0">{
                return a
        }</span>

        <span class="cov8" title="1">return def</span>
}

// MustMap guarantees the return of a `map[string]interface{}` (with optional default)
//
// useful when you want to interate over map values in a succinct manner:
//                for k, v := range js.Get("dictionary").MustMap() {
//                        fmt.Println(k, v)
//                }
func (j *Json) MustMap(args ...map[string]interface{}) map[string]interface{} <span class="cov8" title="1">{
        var def map[string]interface{}

        switch len(args) </span>{
        case 0:</span><span class="cov0" title="0">
        case 1:<span class="cov8" title="1">
                def = args[0]</span>
        default:<span class="cov0" title="0">
                log.Panicf("MustMap() received too many arguments %d", len(args))</span>
        }

        <span class="cov8" title="1">a, err := j.Map()
        if err == nil </span><span class="cov0" title="0">{
                return a
        }</span>

        <span class="cov8" title="1">return def</span>
}

// MustString guarantees the return of a `string` (with optional default)
//
// useful when you explicitly want a `string` in a single value return context:
//     myFunc(js.Get("param1").MustString(), js.Get("optional_param").MustString("my_default"))
func (j *Json) MustString(args ...string) string <span class="cov8" title="1">{
        var def string

        switch len(args) </span>{
        case 0:</span><span class="cov8" title="1">
        case 1:<span class="cov8" title="1">
                def = args[0]</span>
        default:<span class="cov0" title="0">
                log.Panicf("MustString() received too many arguments %d", len(args))</span>
        }

        <span class="cov8" title="1">s, err := j.String()
        if err == nil </span><span class="cov8" title="1">{
                return s
        }</span>

        <span class="cov8" title="1">return def</span>
}

// MustStringArray guarantees the return of a `[]string` (with optional default)
//
// useful when you want to interate over array values in a succinct manner:
//                for i, s := range js.Get("results").MustStringArray() {
//                        fmt.Println(i, s)
//                }
func (j *Json) MustStringArray(args ...[]string) []string <span class="cov8" title="1">{
        var def []string

        switch len(args) </span>{
        case 0:</span><span class="cov8" title="1">
        case 1:<span class="cov8" title="1">
                def = args[0]</span>
        default:<span class="cov0" title="0">
                log.Panicf("MustStringArray() received too many arguments %d", len(args))</span>
        }

        <span class="cov8" title="1">a, err := j.StringArray()
        if err == nil </span><span class="cov8" title="1">{
                return a
        }</span>

        <span class="cov8" title="1">return def</span>
}

// MustInt guarantees the return of an `int` (with optional default)
//
// useful when you explicitly want an `int` in a single value return context:
//     myFunc(js.Get("param1").MustInt(), js.Get("optional_param").MustInt(5150))
func (j *Json) MustInt(args ...int) int <span class="cov8" title="1">{
        var def int

        switch len(args) </span>{
        case 0:</span><span class="cov8" title="1">
        case 1:<span class="cov8" title="1">
                def = args[0]</span>
        default:<span class="cov0" title="0">
                log.Panicf("MustInt() received too many arguments %d", len(args))</span>
        }

        <span class="cov8" title="1">i, err := j.Int()
        if err == nil </span><span class="cov8" title="1">{
                return i
        }</span>

        <span class="cov8" title="1">return def</span>
}

// MustFloat64 guarantees the return of a `float64` (with optional default)
//
// useful when you explicitly want a `float64` in a single value return context:
//     myFunc(js.Get("param1").MustFloat64(), js.Get("optional_param").MustFloat64(5.150))
func (j *Json) MustFloat64(args ...float64) float64 <span class="cov8" title="1">{
        var def float64

        switch len(args) </span>{
        case 0:</span><span class="cov8" title="1">
        case 1:<span class="cov8" title="1">
                def = args[0]</span>
        default:<span class="cov0" title="0">
                log.Panicf("MustFloat64() received too many arguments %d", len(args))</span>
        }

        <span class="cov8" title="1">f, err := j.Float64()
        if err == nil </span><span class="cov8" title="1">{
                return f
        }</span>

        <span class="cov8" title="1">return def</span>
}

// MustBool guarantees the return of a `bool` (with optional default)
//
// useful when you explicitly want a `bool` in a single value return context:
//     myFunc(js.Get("param1").MustBool(), js.Get("optional_param").MustBool(true))
func (j *Json) MustBool(args ...bool) bool <span class="cov8" title="1">{
        var def bool

        switch len(args) </span>{
        case 0:</span><span class="cov8" title="1">
        case 1:<span class="cov0" title="0">
                def = args[0]</span>
        default:<span class="cov0" title="0">
                log.Panicf("MustBool() received too many arguments %d", len(args))</span>
        }

        <span class="cov8" title="1">b, err := j.Bool()
        if err == nil </span><span class="cov8" title="1">{
                return b
        }</span>

        <span class="cov0" title="0">return def</span>
}

// MustInt64 guarantees the return of an `int64` (with optional default)
//
// useful when you explicitly want an `int64` in a single value return context:
//     myFunc(js.Get("param1").MustInt64(), js.Get("optional_param").MustInt64(5150))
func (j *Json) MustInt64(args ...int64) int64 <span class="cov0" title="0">{
        var def int64

        switch len(args) </span>{
        case 0:</span><span class="cov0" title="0">
        case 1:<span class="cov0" title="0">
                def = args[0]</span>
        default:<span class="cov0" title="0">
                log.Panicf("MustInt64() received too many arguments %d", len(args))</span>
        }

        <span class="cov0" title="0">i, err := j.Int64()
        if err == nil </span><span class="cov0" title="0">{
                return i
        }</span>

        <span class="cov0" title="0">return def</span>
}

// MustUInt64 guarantees the return of an `uint64` (with optional default)
//
// useful when you explicitly want an `uint64` in a single value return context:
//     myFunc(js.Get("param1").MustUint64(), js.Get("optional_param").MustUint64(5150))
func (j *Json) MustUint64(args ...uint64) uint64 <span class="cov0" title="0">{
        var def uint64

        switch len(args) </span>{
        case 0:</span><span class="cov0" title="0">
        case 1:<span class="cov0" title="0">
                def = args[0]</span>
        default:<span class="cov0" title="0">
                log.Panicf("MustUint64() received too many arguments %d", len(args))</span>
        }

        <span class="cov0" title="0">i, err := j.Uint64()
        if err == nil </span><span class="cov0" title="0">{
                return i
        }</span>

        <span class="cov0" title="0">return def</span>
}
</pre>
		
		<pre class="file" id="file54" style="display: none">// +build go1.1

package simplejson

import (
        "bytes"
        "encoding/json"
        "errors"
        "io"
        "reflect"
        "strconv"
)

// Implements the json.Unmarshaler interface.
func (j *Json) UnmarshalJSON(p []byte) error <span class="cov8" title="1">{
        dec := json.NewDecoder(bytes.NewBuffer(p))
        dec.UseNumber()
        return dec.Decode(&amp;j.data)
}</span>

// NewFromReader returns a *Json by decoding from an io.Reader
func NewFromReader(r io.Reader) (*Json, error) <span class="cov0" title="0">{
        j := new(Json)
        dec := json.NewDecoder(r)
        dec.UseNumber()
        err := dec.Decode(&amp;j.data)
        return j, err
}</span>

// Float64 coerces into a float64
func (j *Json) Float64() (float64, error) <span class="cov8" title="1">{
        switch j.data.(type) </span>{
        case json.Number:<span class="cov8" title="1">
                return j.data.(json.Number).Float64()</span>
        case float32, float64:<span class="cov8" title="1">
                return reflect.ValueOf(j.data).Float(), nil</span>
        case int, int8, int16, int32, int64:<span class="cov0" title="0">
                return float64(reflect.ValueOf(j.data).Int()), nil</span>
        case uint, uint8, uint16, uint32, uint64:<span class="cov0" title="0">
                return float64(reflect.ValueOf(j.data).Uint()), nil</span>
        }
        <span class="cov8" title="1">return 0, errors.New("invalid value type")</span>
}

// Int coerces into an int
func (j *Json) Int() (int, error) <span class="cov8" title="1">{
        switch j.data.(type) </span>{
        case json.Number:<span class="cov8" title="1">
                i, err := j.data.(json.Number).Int64()
                return int(i), err</span>
        case float32, float64:<span class="cov0" title="0">
                return int(reflect.ValueOf(j.data).Float()), nil</span>
        case int, int8, int16, int32, int64:<span class="cov8" title="1">
                return int(reflect.ValueOf(j.data).Int()), nil</span>
        case uint, uint8, uint16, uint32, uint64:<span class="cov0" title="0">
                return int(reflect.ValueOf(j.data).Uint()), nil</span>
        }
        <span class="cov8" title="1">return 0, errors.New("invalid value type")</span>
}

// Int64 coerces into an int64
func (j *Json) Int64() (int64, error) <span class="cov0" title="0">{
        switch j.data.(type) </span>{
        case json.Number:<span class="cov0" title="0">
                return j.data.(json.Number).Int64()</span>
        case float32, float64:<span class="cov0" title="0">
                return int64(reflect.ValueOf(j.data).Float()), nil</span>
        case int, int8, int16, int32, int64:<span class="cov0" title="0">
                return reflect.ValueOf(j.data).Int(), nil</span>
        case uint, uint8, uint16, uint32, uint64:<span class="cov0" title="0">
                return int64(reflect.ValueOf(j.data).Uint()), nil</span>
        }
        <span class="cov0" title="0">return 0, errors.New("invalid value type")</span>
}

// Uint64 coerces into an uint64
func (j *Json) Uint64() (uint64, error) <span class="cov0" title="0">{
        switch j.data.(type) </span>{
        case json.Number:<span class="cov0" title="0">
                return strconv.ParseUint(j.data.(json.Number).String(), 10, 64)</span>
        case float32, float64:<span class="cov0" title="0">
                return uint64(reflect.ValueOf(j.data).Float()), nil</span>
        case int, int8, int16, int32, int64:<span class="cov0" title="0">
                return uint64(reflect.ValueOf(j.data).Int()), nil</span>
        case uint, uint8, uint16, uint32, uint64:<span class="cov0" title="0">
                return reflect.ValueOf(j.data).Uint(), nil</span>
        }
        <span class="cov0" title="0">return 0, errors.New("invalid value type")</span>
}
</pre>
		
		<pre class="file" id="file55" style="display: none">package events

import (
        "reflect"
        "time"
)

// Events can be passed to external systems via for example AMQP
// Treat these events as basically DTOs so changes has to be backward compatible

type Priority string

const (
        PRIO_DEBUG Priority = "DEBUG"
        PRIO_INFO  Priority = "INFO"
        PRIO_ERROR Priority = "ERROR"
)

type Event struct {
        Timestamp time.Time `json:"timestamp"`
}

type OnTheWireEvent struct {
        EventType string      `json:"event_type"`
        Priority  Priority    `json:"priority"`
        Timestamp time.Time   `json:"timestamp"`
        Payload   interface{} `json:"payload"`
}

type EventBase interface {
        ToOnWriteEvent() *OnTheWireEvent
}

func ToOnWriteEvent(event interface{}) (*OnTheWireEvent, error) <span class="cov8" title="1">{
        eventType := reflect.TypeOf(event).Elem()

        wireEvent := OnTheWireEvent{
                Priority:  PRIO_INFO,
                EventType: eventType.Name(),
                Payload:   event,
        }

        baseField := reflect.Indirect(reflect.ValueOf(event)).FieldByName("Timestamp")
        if baseField.IsValid() </span><span class="cov8" title="1">{
                wireEvent.Timestamp = baseField.Interface().(time.Time)
        }</span><span class="cov0" title="0"> else {
                wireEvent.Timestamp = time.Now()
        }</span>

        <span class="cov8" title="1">return &amp;wireEvent, nil</span>
}

type OrgCreated struct {
        Timestamp time.Time `json:"timestamp"`
        Id        int64     `json:"id"`
        Name      string    `json:"name"`
}

type OrgUpdated struct {
        Timestamp time.Time `json:"timestamp"`
        Id        int64     `json:"id"`
        Name      string    `json:"name"`
}

type UserCreated struct {
        Timestamp time.Time `json:"timestamp"`
        Id        int64     `json:"id"`
        Name      string    `json:"name"`
        Login     string    `json:"login"`
        Email     string    `json:"email"`
}

type SignUpStarted struct {
        Timestamp time.Time `json:"timestamp"`
        Email     string    `json:"email"`
        Code      string    `json:"code"`
}

type SignUpCompleted struct {
        Timestamp time.Time `json:"timestamp"`
        Name      string    `json:"name"`
        Email     string    `json:"email"`
}

type UserUpdated struct {
        Timestamp time.Time `json:"timestamp"`
        Id        int64     `json:"id"`
        Name      string    `json:"name"`
        Login     string    `json:"login"`
        Email     string    `json:"email"`
}
</pre>
		
		<pre class="file" id="file56" style="display: none">package login

import (
        "errors"

        "crypto/subtle"
        "github.com/grafana/grafana/pkg/bus"
        m "github.com/grafana/grafana/pkg/models"
        "github.com/grafana/grafana/pkg/setting"
        "github.com/grafana/grafana/pkg/util"
)

var (
        ErrInvalidCredentials = errors.New("Invalid Username or Password")
)

type LoginUserQuery struct {
        Username string
        Password string
        User     *m.User
}

func Init() <span class="cov0" title="0">{
        bus.AddHandler("auth", AuthenticateUser)
        loadLdapConfig()
}</span>

func AuthenticateUser(query *LoginUserQuery) error <span class="cov0" title="0">{
        err := loginUsingGrafanaDB(query)
        if err == nil || err != ErrInvalidCredentials </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if setting.LdapEnabled </span><span class="cov0" title="0">{
                for _, server := range LdapCfg.Servers </span><span class="cov0" title="0">{
                        auther := NewLdapAuthenticator(server)
                        err = auther.Login(query)
                        if err == nil || err != ErrInvalidCredentials </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov0" title="0">return err</span>
}

func loginUsingGrafanaDB(query *LoginUserQuery) error <span class="cov0" title="0">{
        userQuery := m.GetUserByLoginQuery{LoginOrEmail: query.Username}

        if err := bus.Dispatch(&amp;userQuery); err != nil </span><span class="cov0" title="0">{
                if err == m.ErrUserNotFound </span><span class="cov0" title="0">{
                        return ErrInvalidCredentials
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">user := userQuery.Result

        passwordHashed := util.EncodePassword(query.Password, user.Salt)
        if subtle.ConstantTimeCompare([]byte(passwordHashed), []byte(user.Password)) != 1 </span><span class="cov0" title="0">{
                return ErrInvalidCredentials
        }</span>

        <span class="cov0" title="0">query.User = user
        return nil</span>
}
</pre>
		
		<pre class="file" id="file57" style="display: none">package login

import (
        "crypto/tls"
        "crypto/x509"
        "errors"
        "fmt"
        "io/ioutil"
        "strings"

        "github.com/davecgh/go-spew/spew"
        "github.com/go-ldap/ldap"
        "github.com/grafana/grafana/pkg/bus"
        "github.com/grafana/grafana/pkg/log"
        m "github.com/grafana/grafana/pkg/models"
        "github.com/grafana/grafana/pkg/setting"
)

type ILdapConn interface {
        Bind(username, password string) error
        Search(*ldap.SearchRequest) (*ldap.SearchResult, error)
        StartTLS(*tls.Config) error
        Close()
}

type ILdapAuther interface {
        Login(query *LoginUserQuery) error
        SyncSignedInUser(signedInUser *m.SignedInUser) error
        GetGrafanaUserFor(ldapUser *LdapUserInfo) (*m.User, error)
        SyncOrgRoles(user *m.User, ldapUser *LdapUserInfo) error
}

type ldapAuther struct {
        server            *LdapServerConf
        conn              ILdapConn
        requireSecondBind bool
        log               log.Logger
}

var NewLdapAuthenticator = func(server *LdapServerConf) ILdapAuther <span class="cov8" title="1">{
        return &amp;ldapAuther{server: server, log: log.New("ldap")}
}</span>

var ldapDial = func(network, addr string) (ILdapConn, error) <span class="cov0" title="0">{
        return ldap.Dial(network, addr)
}</span>

func (a *ldapAuther) Dial() error <span class="cov8" title="1">{
        var err error
        var certPool *x509.CertPool
        if a.server.RootCACert != "" </span><span class="cov0" title="0">{
                certPool = x509.NewCertPool()
                for _, caCertFile := range strings.Split(a.server.RootCACert, " ") </span><span class="cov0" title="0">{
                        if pem, err := ioutil.ReadFile(caCertFile); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span><span class="cov0" title="0"> else {
                                if !certPool.AppendCertsFromPEM(pem) </span><span class="cov0" title="0">{
                                        return errors.New("Failed to append CA certificate " + caCertFile)
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">for _, host := range strings.Split(a.server.Host, " ") </span><span class="cov8" title="1">{
                address := fmt.Sprintf("%s:%d", host, a.server.Port)
                if a.server.UseSSL </span><span class="cov0" title="0">{
                        tlsCfg := &amp;tls.Config{
                                InsecureSkipVerify: a.server.SkipVerifySSL,
                                ServerName:         host,
                                RootCAs:            certPool,
                        }
                        if a.server.StartTLS </span><span class="cov0" title="0">{
                                a.conn, err = ldap.Dial("tcp", address)
                                if err == nil </span><span class="cov0" title="0">{
                                        if err = a.conn.StartTLS(tlsCfg); err == nil </span><span class="cov0" title="0">{
                                                return nil
                                        }</span>
                                }
                        }<span class="cov0" title="0"> else {
                                a.conn, err = ldap.DialTLS("tcp", address, tlsCfg)
                        }</span>
                }<span class="cov8" title="1"> else {
                        a.conn, err = ldapDial("tcp", address)
                }</span>

                <span class="cov8" title="1">if err == nil </span><span class="cov8" title="1">{
                        return nil
                }</span>
        }
        <span class="cov0" title="0">return err</span>
}

func (a *ldapAuther) Login(query *LoginUserQuery) error <span class="cov0" title="0">{
        if err := a.Dial(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer a.conn.Close()

        // perform initial authentication
        if err := a.initialBind(query.Username, query.Password); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // find user entry &amp; attributes
        <span class="cov0" title="0">if ldapUser, err := a.searchForUser(query.Username); err != nil </span><span class="cov0" title="0">{
                return err
        }</span><span class="cov0" title="0"> else {
                a.log.Debug("Ldap User found", "info", spew.Sdump(ldapUser))

                // check if a second user bind is needed
                if a.requireSecondBind </span><span class="cov0" title="0">{
                        if err := a.secondBind(ldapUser, query.Password); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                <span class="cov0" title="0">if grafanaUser, err := a.GetGrafanaUserFor(ldapUser); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span><span class="cov0" title="0"> else {
                        if syncErr := a.syncInfoAndOrgRoles(grafanaUser, ldapUser); syncErr != nil </span><span class="cov0" title="0">{
                                return syncErr
                        }</span>
                        <span class="cov0" title="0">query.User = grafanaUser
                        return nil</span>
                }
        }
}

func (a *ldapAuther) SyncSignedInUser(signedInUser *m.SignedInUser) error <span class="cov8" title="1">{
        grafanaUser := m.User{
                Id:    signedInUser.UserId,
                Login: signedInUser.Login,
                Email: signedInUser.Email,
                Name:  signedInUser.Name,
        }

        if err := a.Dial(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">defer a.conn.Close()
        if err := a.serverBind(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if ldapUser, err := a.searchForUser(signedInUser.Login); err != nil </span><span class="cov0" title="0">{
                a.log.Error("Failed searching for user in ldap", "error", err)

                return err
        }</span><span class="cov8" title="1"> else {
                if err := a.syncInfoAndOrgRoles(&amp;grafanaUser, ldapUser); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">a.log.Debug("Got Ldap User Info", "user", spew.Sdump(ldapUser))</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// Sync info for ldap user and grafana user
func (a *ldapAuther) syncInfoAndOrgRoles(user *m.User, ldapUser *LdapUserInfo) error <span class="cov8" title="1">{
        // sync user details
        if err := a.syncUserInfo(user, ldapUser); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // sync org roles
        <span class="cov8" title="1">if err := a.SyncOrgRoles(user, ldapUser); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (a *ldapAuther) GetGrafanaUserFor(ldapUser *LdapUserInfo) (*m.User, error) <span class="cov8" title="1">{
        // validate that the user has access
        // if there are no ldap group mappings access is true
        // otherwise a single group must match
        access := len(a.server.LdapGroups) == 0
        for _, ldapGroup := range a.server.LdapGroups </span><span class="cov8" title="1">{
                if ldapUser.isMemberOf(ldapGroup.GroupDN) </span><span class="cov8" title="1">{
                        access = true
                        break</span>
                }
        }

        <span class="cov8" title="1">if !access </span><span class="cov8" title="1">{
                a.log.Info("Ldap Auth: user does not belong in any of the specified ldap groups", "username", ldapUser.Username, "groups", ldapUser.MemberOf)
                return nil, ErrInvalidCredentials
        }</span>

        // get user from grafana db
        <span class="cov8" title="1">userQuery := m.GetUserByLoginQuery{LoginOrEmail: ldapUser.Username}
        if err := bus.Dispatch(&amp;userQuery); err != nil </span><span class="cov8" title="1">{
                if err == m.ErrUserNotFound &amp;&amp; setting.LdapAllowSignup </span><span class="cov8" title="1">{
                        return a.createGrafanaUser(ldapUser)
                }</span><span class="cov0" title="0"> else if err == m.ErrUserNotFound </span><span class="cov0" title="0">{
                        a.log.Warn("Not allowing LDAP login, user not found in internal user database, and ldap allow signup = false")
                        return nil, ErrInvalidCredentials
                }</span><span class="cov0" title="0"> else {
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">return userQuery.Result, nil</span>

}
func (a *ldapAuther) createGrafanaUser(ldapUser *LdapUserInfo) (*m.User, error) <span class="cov8" title="1">{
        cmd := m.CreateUserCommand{
                Login: ldapUser.Username,
                Email: ldapUser.Email,
                Name:  fmt.Sprintf("%s %s", ldapUser.FirstName, ldapUser.LastName),
        }

        if err := bus.Dispatch(&amp;cmd); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;cmd.Result, nil</span>
}

func (a *ldapAuther) syncUserInfo(user *m.User, ldapUser *LdapUserInfo) error <span class="cov8" title="1">{
        var name = fmt.Sprintf("%s %s", ldapUser.FirstName, ldapUser.LastName)
        if user.Email == ldapUser.Email &amp;&amp; user.Name == name </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">a.log.Debug("Syncing user info", "username", ldapUser.Username)
        updateCmd := m.UpdateUserCommand{}
        updateCmd.UserId = user.Id
        updateCmd.Login = user.Login
        updateCmd.Email = ldapUser.Email
        updateCmd.Name = fmt.Sprintf("%s %s", ldapUser.FirstName, ldapUser.LastName)
        return bus.Dispatch(&amp;updateCmd)</span>
}

func (a *ldapAuther) SyncOrgRoles(user *m.User, ldapUser *LdapUserInfo) error <span class="cov8" title="1">{
        if len(a.server.LdapGroups) == 0 </span><span class="cov0" title="0">{
                a.log.Warn("No group mappings defined")
                return nil
        }</span>

        <span class="cov8" title="1">orgsQuery := m.GetUserOrgListQuery{UserId: user.Id}
        if err := bus.Dispatch(&amp;orgsQuery); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">handledOrgIds := map[int64]bool{}

        // update or remove org roles
        for _, org := range orgsQuery.Result </span><span class="cov8" title="1">{
                match := false
                handledOrgIds[org.OrgId] = true

                for _, group := range a.server.LdapGroups </span><span class="cov8" title="1">{
                        if org.OrgId != group.OrgId </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov8" title="1">if ldapUser.isMemberOf(group.GroupDN) </span><span class="cov8" title="1">{
                                match = true
                                if org.Role != group.OrgRole </span><span class="cov8" title="1">{
                                        // update role
                                        cmd := m.UpdateOrgUserCommand{OrgId: org.OrgId, UserId: user.Id, Role: group.OrgRole}
                                        if err := bus.Dispatch(&amp;cmd); err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                }
                                // ignore subsequent ldap group mapping matches
                                <span class="cov8" title="1">break</span>
                        }
                }

                // remove role if no mappings match
                <span class="cov8" title="1">if !match </span><span class="cov8" title="1">{
                        cmd := m.RemoveOrgUserCommand{OrgId: org.OrgId, UserId: user.Id}
                        if err := bus.Dispatch(&amp;cmd); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        // add missing org roles
        <span class="cov8" title="1">for _, group := range a.server.LdapGroups </span><span class="cov8" title="1">{
                if !ldapUser.isMemberOf(group.GroupDN) </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">if _, exists := handledOrgIds[group.OrgId]; exists </span><span class="cov8" title="1">{
                        continue</span>
                }

                // add role
                <span class="cov8" title="1">cmd := m.AddOrgUserCommand{UserId: user.Id, Role: group.OrgRole, OrgId: group.OrgId}
                err := bus.Dispatch(&amp;cmd)
                if err != nil &amp;&amp; err != m.ErrOrgNotFound </span><span class="cov0" title="0">{
                        return err
                }</span>

                // mark this group has handled so we do not process it again
                <span class="cov8" title="1">handledOrgIds[group.OrgId] = true</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (a *ldapAuther) serverBind() error <span class="cov8" title="1">{
        // bind_dn and bind_password to bind
        if err := a.conn.Bind(a.server.BindDN, a.server.BindPassword); err != nil </span><span class="cov0" title="0">{
                a.log.Info("LDAP initial bind failed, %v", err)

                if ldapErr, ok := err.(*ldap.Error); ok </span><span class="cov0" title="0">{
                        if ldapErr.ResultCode == 49 </span><span class="cov0" title="0">{
                                return ErrInvalidCredentials
                        }</span>
                }
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (a *ldapAuther) secondBind(ldapUser *LdapUserInfo, userPassword string) error <span class="cov0" title="0">{
        if err := a.conn.Bind(ldapUser.DN, userPassword); err != nil </span><span class="cov0" title="0">{
                a.log.Info("Second bind failed", "error", err)

                if ldapErr, ok := err.(*ldap.Error); ok </span><span class="cov0" title="0">{
                        if ldapErr.ResultCode == 49 </span><span class="cov0" title="0">{
                                return ErrInvalidCredentials
                        }</span>
                }
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (a *ldapAuther) initialBind(username, userPassword string) error <span class="cov0" title="0">{
        if a.server.BindPassword != "" || a.server.BindDN == "" </span><span class="cov0" title="0">{
                userPassword = a.server.BindPassword
                a.requireSecondBind = true
        }</span>

        <span class="cov0" title="0">bindPath := a.server.BindDN
        if strings.Contains(bindPath, "%s") </span><span class="cov0" title="0">{
                bindPath = fmt.Sprintf(a.server.BindDN, username)
        }</span>

        <span class="cov0" title="0">if err := a.conn.Bind(bindPath, userPassword); err != nil </span><span class="cov0" title="0">{
                a.log.Info("Initial bind failed", "error", err)

                if ldapErr, ok := err.(*ldap.Error); ok </span><span class="cov0" title="0">{
                        if ldapErr.ResultCode == 49 </span><span class="cov0" title="0">{
                                return ErrInvalidCredentials
                        }</span>
                }
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (a *ldapAuther) searchForUser(username string) (*LdapUserInfo, error) <span class="cov8" title="1">{
        var searchResult *ldap.SearchResult
        var err error

        for _, searchBase := range a.server.SearchBaseDNs </span><span class="cov8" title="1">{
                searchReq := ldap.SearchRequest{
                        BaseDN:       searchBase,
                        Scope:        ldap.ScopeWholeSubtree,
                        DerefAliases: ldap.NeverDerefAliases,
                        Attributes: []string{
                                a.server.Attr.Username,
                                a.server.Attr.Surname,
                                a.server.Attr.Email,
                                a.server.Attr.Name,
                                a.server.Attr.MemberOf,
                        },
                        Filter: strings.Replace(a.server.SearchFilter, "%s", ldap.EscapeFilter(username), -1),
                }

                searchResult, err = a.conn.Search(&amp;searchReq)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">if len(searchResult.Entries) &gt; 0 </span><span class="cov8" title="1">{
                        break</span>
                }
        }

        <span class="cov8" title="1">if len(searchResult.Entries) == 0 </span><span class="cov0" title="0">{
                return nil, ErrInvalidCredentials
        }</span>

        <span class="cov8" title="1">if len(searchResult.Entries) &gt; 1 </span><span class="cov0" title="0">{
                return nil, errors.New("Ldap search matched more than one entry, please review your filter setting")
        }</span>

        <span class="cov8" title="1">var memberOf []string
        if a.server.GroupSearchFilter == "" </span><span class="cov8" title="1">{
                memberOf = getLdapAttrArray(a.server.Attr.MemberOf, searchResult)
        }</span><span class="cov0" title="0"> else {
                // If we are using a POSIX LDAP schema it won't support memberOf, so we manually search the groups
                var groupSearchResult *ldap.SearchResult
                for _, groupSearchBase := range a.server.GroupSearchBaseDNs </span><span class="cov0" title="0">{
                        var filter_replace string
                        filter_replace = getLdapAttr(a.server.GroupSearchFilterUserAttribute, searchResult)
                        if a.server.GroupSearchFilterUserAttribute == "" </span><span class="cov0" title="0">{
                                filter_replace = getLdapAttr(a.server.Attr.Username, searchResult)
                        }</span>
                        <span class="cov0" title="0">filter := strings.Replace(a.server.GroupSearchFilter, "%s", ldap.EscapeFilter(filter_replace), -1)

                        a.log.Info("Searching for user's groups", "filter", filter)

                        groupSearchReq := ldap.SearchRequest{
                                BaseDN:       groupSearchBase,
                                Scope:        ldap.ScopeWholeSubtree,
                                DerefAliases: ldap.NeverDerefAliases,
                                Attributes: []string{
                                        // Here MemberOf would be the thing that identifies the group, which is normally 'cn'
                                        a.server.Attr.MemberOf,
                                },
                                Filter: filter,
                        }

                        groupSearchResult, err = a.conn.Search(&amp;groupSearchReq)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov0" title="0">if len(groupSearchResult.Entries) &gt; 0 </span><span class="cov0" title="0">{
                                for i := range groupSearchResult.Entries </span><span class="cov0" title="0">{
                                        memberOf = append(memberOf, getLdapAttrN(a.server.Attr.MemberOf, groupSearchResult, i))
                                }</span>
                                <span class="cov0" title="0">break</span>
                        }
                }
        }

        <span class="cov8" title="1">return &amp;LdapUserInfo{
                DN:        searchResult.Entries[0].DN,
                LastName:  getLdapAttr(a.server.Attr.Surname, searchResult),
                FirstName: getLdapAttr(a.server.Attr.Name, searchResult),
                Username:  getLdapAttr(a.server.Attr.Username, searchResult),
                Email:     getLdapAttr(a.server.Attr.Email, searchResult),
                MemberOf:  memberOf,
        }, nil</span>
}

func getLdapAttrN(name string, result *ldap.SearchResult, n int) string <span class="cov8" title="1">{
        for _, attr := range result.Entries[n].Attributes </span><span class="cov8" title="1">{
                if attr.Name == name </span><span class="cov8" title="1">{
                        if len(attr.Values) &gt; 0 </span><span class="cov8" title="1">{
                                return attr.Values[0]
                        }</span>
                }
        }
        <span class="cov0" title="0">return ""</span>
}

func getLdapAttr(name string, result *ldap.SearchResult) string <span class="cov8" title="1">{
        return getLdapAttrN(name, result, 0)
}</span>

func getLdapAttrArray(name string, result *ldap.SearchResult) []string <span class="cov8" title="1">{
        for _, attr := range result.Entries[0].Attributes </span><span class="cov8" title="1">{
                if attr.Name == name </span><span class="cov8" title="1">{
                        return attr.Values
                }</span>
        }
        <span class="cov0" title="0">return []string{}</span>
}

func createUserFromLdapInfo() error <span class="cov0" title="0">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file58" style="display: none">package login

type LdapUserInfo struct {
        DN        string
        FirstName string
        LastName  string
        Username  string
        Email     string
        MemberOf  []string
}

func (u *LdapUserInfo) isMemberOf(group string) bool <span class="cov8" title="1">{
        if group == "*" </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">for _, member := range u.MemberOf </span><span class="cov8" title="1">{
                if member == group </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file59" style="display: none">package login

import (
        "fmt"
        "os"

        "github.com/BurntSushi/toml"
        "github.com/grafana/grafana/pkg/log"
        m "github.com/grafana/grafana/pkg/models"
        "github.com/grafana/grafana/pkg/setting"
)

type LdapConfig struct {
        Servers []*LdapServerConf `toml:"servers"`
}

type LdapServerConf struct {
        Host          string           `toml:"host"`
        Port          int              `toml:"port"`
        UseSSL        bool             `toml:"use_ssl"`
        StartTLS      bool             `toml:"start_tls"`
        SkipVerifySSL bool             `toml:"ssl_skip_verify"`
        RootCACert    string           `toml:"root_ca_cert"`
        BindDN        string           `toml:"bind_dn"`
        BindPassword  string           `toml:"bind_password"`
        Attr          LdapAttributeMap `toml:"attributes"`

        SearchFilter  string   `toml:"search_filter"`
        SearchBaseDNs []string `toml:"search_base_dns"`

        GroupSearchFilter              string   `toml:"group_search_filter"`
        GroupSearchFilterUserAttribute string   `toml:"group_search_filter_user_attribute"`
        GroupSearchBaseDNs             []string `toml:"group_search_base_dns"`

        LdapGroups []*LdapGroupToOrgRole `toml:"group_mappings"`
}

type LdapAttributeMap struct {
        Username string `toml:"username"`
        Name     string `toml:"name"`
        Surname  string `toml:"surname"`
        Email    string `toml:"email"`
        MemberOf string `toml:"member_of"`
}

type LdapGroupToOrgRole struct {
        GroupDN string     `toml:"group_dn"`
        OrgId   int64      `toml:"org_id"`
        OrgRole m.RoleType `toml:"org_role"`
}

var LdapCfg LdapConfig
var ldapLogger log.Logger = log.New("ldap")

func loadLdapConfig() <span class="cov0" title="0">{
        if !setting.LdapEnabled </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">ldapLogger.Info("Ldap enabled, reading config file", "file", setting.LdapConfigFile)

        _, err := toml.DecodeFile(setting.LdapConfigFile, &amp;LdapCfg)
        if err != nil </span><span class="cov0" title="0">{
                ldapLogger.Crit("Failed to load ldap config file", "error", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">if len(LdapCfg.Servers) == 0 </span><span class="cov0" title="0">{
                ldapLogger.Crit("ldap enabled but no ldap servers defined in config file")
                os.Exit(1)
        }</span>

        // set default org id
        <span class="cov0" title="0">for _, server := range LdapCfg.Servers </span><span class="cov0" title="0">{
                assertNotEmptyCfg(server.SearchFilter, "search_filter")
                assertNotEmptyCfg(server.SearchBaseDNs, "search_base_dns")

                for _, groupMap := range server.LdapGroups </span><span class="cov0" title="0">{
                        if groupMap.OrgId == 0 </span><span class="cov0" title="0">{
                                groupMap.OrgId = 1
                        }</span>
                }
        }
}

func assertNotEmptyCfg(val interface{}, propName string) <span class="cov0" title="0">{
        switch v := val.(type) </span>{
        case string:<span class="cov0" title="0">
                if v == "" </span><span class="cov0" title="0">{
                        ldapLogger.Crit("LDAP config file is missing option", "option", propName)
                        os.Exit(1)
                }</span>
        case []string:<span class="cov0" title="0">
                if len(v) == 0 </span><span class="cov0" title="0">{
                        ldapLogger.Crit("LDAP config file is missing option", "option", propName)
                        os.Exit(1)
                }</span>
        default:<span class="cov0" title="0">
                fmt.Println("unknown")</span>
        }
}
</pre>
		
		<pre class="file" id="file60" style="display: none">// includes code from
// https://raw.githubusercontent.com/rcrowley/go-metrics/master/sample.go
// Copyright 2012 Richard Crowley. All rights reserved.

package metrics

import (
        "math"
        "sync"
        "sync/atomic"
)

// EWMAs continuously calculate an exponentially-weighted moving average
// based on an outside source of clock ticks.
type EWMA interface {
        Rate() float64
        Snapshot() EWMA
        Tick()
        Update(int64)
}

// NewEWMA constructs a new EWMA with the given alpha.
func NewEWMA(alpha float64) EWMA <span class="cov0" title="0">{
        if UseNilMetrics </span><span class="cov0" title="0">{
                return NilEWMA{}
        }</span>
        <span class="cov0" title="0">return &amp;StandardEWMA{alpha: alpha}</span>
}

// NewEWMA1 constructs a new EWMA for a one-minute moving average.
func NewEWMA1() EWMA <span class="cov0" title="0">{
        return NewEWMA(1 - math.Exp(-5.0/60.0/1))
}</span>

// NewEWMA5 constructs a new EWMA for a five-minute moving average.
func NewEWMA5() EWMA <span class="cov0" title="0">{
        return NewEWMA(1 - math.Exp(-5.0/60.0/5))
}</span>

// NewEWMA15 constructs a new EWMA for a fifteen-minute moving average.
func NewEWMA15() EWMA <span class="cov0" title="0">{
        return NewEWMA(1 - math.Exp(-5.0/60.0/15))
}</span>

// EWMASnapshot is a read-only copy of another EWMA.
type EWMASnapshot float64

// Rate returns the rate of events per second at the time the snapshot was
// taken.
func (a EWMASnapshot) Rate() float64 <span class="cov0" title="0">{ return float64(a) }</span>

// Snapshot returns the snapshot.
func (a EWMASnapshot) Snapshot() EWMA <span class="cov0" title="0">{ return a }</span>

// Tick panics.
func (EWMASnapshot) Tick() <span class="cov0" title="0">{
        panic("Tick called on an EWMASnapshot")</span>
}

// Update panics.
func (EWMASnapshot) Update(int64) <span class="cov0" title="0">{
        panic("Update called on an EWMASnapshot")</span>
}

// NilEWMA is a no-op EWMA.
type NilEWMA struct{}

// Rate is a no-op.
func (NilEWMA) Rate() float64 <span class="cov0" title="0">{ return 0.0 }</span>

// Snapshot is a no-op.
func (NilEWMA) Snapshot() EWMA <span class="cov0" title="0">{ return NilEWMA{} }</span>

// Tick is a no-op.
func (NilEWMA) Tick() <span class="cov0" title="0">{}</span>

// Update is a no-op.
func (NilEWMA) Update(n int64) <span class="cov0" title="0">{}</span>

// StandardEWMA is the standard implementation of an EWMA and tracks the number
// of uncounted events and processes them on each tick.  It uses the
// sync/atomic package to manage uncounted events.
type StandardEWMA struct {
        uncounted int64 // /!\ this should be the first member to ensure 64-bit alignment
        alpha     float64
        rate      float64
        init      bool
        mutex     sync.Mutex
}

// Rate returns the moving average rate of events per second.
func (a *StandardEWMA) Rate() float64 <span class="cov0" title="0">{
        a.mutex.Lock()
        defer a.mutex.Unlock()
        return a.rate * float64(1e9)
}</span>

// Snapshot returns a read-only copy of the EWMA.
func (a *StandardEWMA) Snapshot() EWMA <span class="cov0" title="0">{
        return EWMASnapshot(a.Rate())
}</span>

// Tick ticks the clock to update the moving average.  It assumes it is called
// every five seconds.
func (a *StandardEWMA) Tick() <span class="cov0" title="0">{
        count := atomic.LoadInt64(&amp;a.uncounted)
        atomic.AddInt64(&amp;a.uncounted, -count)
        instantRate := float64(count) / float64(5e9)
        a.mutex.Lock()
        defer a.mutex.Unlock()
        if a.init </span><span class="cov0" title="0">{
                a.rate += a.alpha * (instantRate - a.rate)
        }</span><span class="cov0" title="0"> else {
                a.init = true
                a.rate = instantRate
        }</span>
}

// Update adds n uncounted events.
func (a *StandardEWMA) Update(n int64) <span class="cov0" title="0">{
        atomic.AddInt64(&amp;a.uncounted, n)
}</span>
</pre>
		
		<pre class="file" id="file61" style="display: none">package metrics

import "github.com/grafana/grafana/pkg/log"

type MetricMeta struct {
        tags map[string]string
        name string
}

func NewMetricMeta(name string, tagStrings []string) *MetricMeta <span class="cov8" title="1">{
        if len(tagStrings)%2 != 0 </span><span class="cov0" title="0">{
                log.Fatal(3, "Metrics: tags array is missing value for key, %v", tagStrings)
        }</span>

        <span class="cov8" title="1">tags := make(map[string]string)
        for i := 0; i &lt; len(tagStrings); i += 2 </span><span class="cov8" title="1">{
                tags[tagStrings[i]] = tagStrings[i+1]
        }</span>

        <span class="cov8" title="1">return &amp;MetricMeta{
                tags: tags,
                name: name,
        }</span>
}

func (m *MetricMeta) Name() string <span class="cov0" title="0">{
        return m.name
}</span>

func (m *MetricMeta) GetTagsCopy() map[string]string <span class="cov0" title="0">{
        if len(m.tags) == 0 </span><span class="cov0" title="0">{
                return make(map[string]string)
        }</span>

        <span class="cov0" title="0">copy := make(map[string]string)
        for k2, v2 := range m.tags </span><span class="cov0" title="0">{
                copy[k2] = v2
        }</span>

        <span class="cov0" title="0">return copy</span>
}

func (m *MetricMeta) StringifyTags() string <span class="cov0" title="0">{
        if len(m.tags) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">str := ""
        for key, value := range m.tags </span><span class="cov0" title="0">{
                str += "." + key + "_" + value
        }</span>

        <span class="cov0" title="0">return str</span>
}

type Metric interface {
        Name() string
        GetTagsCopy() map[string]string
        StringifyTags() string
        Snapshot() Metric
}
</pre>
		
		<pre class="file" id="file62" style="display: none">package metrics

import "sync/atomic"

// Counters hold an int64 value that can be incremented and decremented.
type Counter interface {
        Metric

        Clear()
        Count() int64
        Dec(int64)
        Inc(int64)
}

// NewCounter constructs a new StandardCounter.
func NewCounter(meta *MetricMeta) Counter <span class="cov8" title="1">{
        return &amp;StandardCounter{
                MetricMeta: meta,
                count:      0,
        }
}</span>

func RegCounter(name string, tagStrings ...string) Counter <span class="cov8" title="1">{
        cr := NewCounter(NewMetricMeta(name, tagStrings))
        MetricStats.Register(cr)
        return cr
}</span>

// StandardCounter is the standard implementation of a Counter and uses the
// sync/atomic package to manage a single int64 value.
type StandardCounter struct {
        count int64 //Due to a bug in golang the 64bit variable need to come first to be 64bit aligned. https://golang.org/pkg/sync/atomic/#pkg-note-BUG
        *MetricMeta
}

// Clear sets the counter to zero.
func (c *StandardCounter) Clear() <span class="cov0" title="0">{
        atomic.StoreInt64(&amp;c.count, 0)
}</span>

// Count returns the current count.
func (c *StandardCounter) Count() int64 <span class="cov0" title="0">{
        return atomic.LoadInt64(&amp;c.count)
}</span>

// Dec decrements the counter by the given amount.
func (c *StandardCounter) Dec(i int64) <span class="cov0" title="0">{
        atomic.AddInt64(&amp;c.count, -i)
}</span>

// Inc increments the counter by the given amount.
func (c *StandardCounter) Inc(i int64) <span class="cov0" title="0">{
        atomic.AddInt64(&amp;c.count, i)
}</span>

func (c *StandardCounter) Snapshot() Metric <span class="cov0" title="0">{
        return &amp;StandardCounter{
                MetricMeta: c.MetricMeta,
                count:      c.count,
        }
}</span>
</pre>
		
		<pre class="file" id="file63" style="display: none">package metrics

import "math"

func calculateDelta(oldValue, newValue int64) int64 <span class="cov0" title="0">{
        if oldValue &lt; newValue </span><span class="cov0" title="0">{
                return newValue - oldValue
        }</span><span class="cov0" title="0"> else {
                return (math.MaxInt64 - oldValue) + (newValue - math.MinInt64) + 1
        }</span>
}
</pre>
		
		<pre class="file" id="file64" style="display: none">// includes code from
// https://raw.githubusercontent.com/rcrowley/go-metrics/master/sample.go
// Copyright 2012 Richard Crowley. All rights reserved.

package metrics

import "sync/atomic"

// Gauges hold an int64 value that can be set arbitrarily.
type Gauge interface {
        Metric

        Update(int64)
        Value() int64
}

func NewGauge(meta *MetricMeta) Gauge <span class="cov8" title="1">{
        if UseNilMetrics </span><span class="cov8" title="1">{
                return NilGauge{}
        }</span>
        <span class="cov0" title="0">return &amp;StandardGauge{
                MetricMeta: meta,
                value:      0,
        }</span>
}

func RegGauge(name string, tagStrings ...string) Gauge <span class="cov8" title="1">{
        tr := NewGauge(NewMetricMeta(name, tagStrings))
        MetricStats.Register(tr)
        return tr
}</span>

// GaugeSnapshot is a read-only copy of another Gauge.
type GaugeSnapshot struct {
        value int64
        *MetricMeta
}

// Snapshot returns the snapshot.
func (g GaugeSnapshot) Snapshot() Metric <span class="cov0" title="0">{ return g }</span>

// Update panics.
func (GaugeSnapshot) Update(int64) <span class="cov0" title="0">{
        panic("Update called on a GaugeSnapshot")</span>
}

// Value returns the value at the time the snapshot was taken.
func (g GaugeSnapshot) Value() int64 <span class="cov0" title="0">{ return g.value }</span>

// NilGauge is a no-op Gauge.
type NilGauge struct{ *MetricMeta }

// Snapshot is a no-op.
func (NilGauge) Snapshot() Metric <span class="cov0" title="0">{ return NilGauge{} }</span>

// Update is a no-op.
func (NilGauge) Update(v int64) <span class="cov0" title="0">{}</span>

// Value is a no-op.
func (NilGauge) Value() int64 <span class="cov0" title="0">{ return 0 }</span>

// StandardGauge is the standard implementation of a Gauge and uses the
// sync/atomic package to manage a single int64 value.
// atomic needs 64-bit aligned memory which is ensure for first word
type StandardGauge struct {
        value int64
        *MetricMeta
}

// Snapshot returns a read-only copy of the gauge.
func (g *StandardGauge) Snapshot() Metric <span class="cov0" title="0">{
        return GaugeSnapshot{MetricMeta: g.MetricMeta, value: g.value}
}</span>

// Update updates the gauge's value.
func (g *StandardGauge) Update(v int64) <span class="cov0" title="0">{
        atomic.StoreInt64(&amp;g.value, v)
}</span>

// Value returns the gauge's current value.
func (g *StandardGauge) Value() int64 <span class="cov0" title="0">{
        return atomic.LoadInt64(&amp;g.value)
}</span>
</pre>
		
		<pre class="file" id="file65" style="display: none">package metrics

import (
        "bytes"
        "fmt"
        "net"
        "strings"
        "time"

        "github.com/grafana/grafana/pkg/log"
        "github.com/grafana/grafana/pkg/setting"
)

type GraphitePublisher struct {
        address    string
        protocol   string
        prefix     string
        prevCounts map[string]int64
}

func CreateGraphitePublisher() (*GraphitePublisher, error) <span class="cov8" title="1">{
        graphiteSection, err := setting.Cfg.GetSection("metrics.graphite")
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov8" title="1">address := graphiteSection.Key("address").String()
        if address == "" </span><span class="cov8" title="1">{
                return nil, nil
        }</span>

        <span class="cov8" title="1">publisher := &amp;GraphitePublisher{}
        publisher.prevCounts = make(map[string]int64)
        publisher.protocol = "tcp"
        publisher.prefix = graphiteSection.Key("prefix").MustString("prod.grafana.%(instance_name)s")
        publisher.address = address

        safeInstanceName := strings.Replace(setting.InstanceName, ".", "_", -1)
        prefix := graphiteSection.Key("prefix").Value()

        if prefix == "" </span><span class="cov0" title="0">{
                prefix = "prod.grafana.%(instance_name)s."
        }</span>

        <span class="cov8" title="1">publisher.prefix = strings.Replace(prefix, "%(instance_name)s", safeInstanceName, -1)
        return publisher, nil</span>
}

func (this *GraphitePublisher) Publish(metrics []Metric) <span class="cov0" title="0">{
        conn, err := net.DialTimeout(this.protocol, this.address, time.Second*5)

        if err != nil </span><span class="cov0" title="0">{
                log.Error(3, "Metrics: GraphitePublisher:  Failed to connect to %s!", err)
                return
        }</span>

        <span class="cov0" title="0">buf := bytes.NewBufferString("")
        now := time.Now().Unix()

        for _, m := range metrics </span><span class="cov0" title="0">{
                metricName := this.prefix + m.Name() + m.StringifyTags()

                switch metric := m.(type) </span>{
                case Counter:<span class="cov0" title="0">
                        this.addCount(buf, metricName+".count", metric.Count(), now)</span>
                case Gauge:<span class="cov0" title="0">
                        this.addCount(buf, metricName, metric.Value(), now)</span>
                case Timer:<span class="cov0" title="0">
                        percentiles := metric.Percentiles([]float64{0.25, 0.75, 0.90, 0.99})
                        this.addCount(buf, metricName+".count", metric.Count(), now)
                        this.addInt(buf, metricName+".max", metric.Max(), now)
                        this.addInt(buf, metricName+".min", metric.Min(), now)
                        this.addFloat(buf, metricName+".mean", metric.Mean(), now)
                        this.addFloat(buf, metricName+".std", metric.StdDev(), now)
                        this.addFloat(buf, metricName+".p25", percentiles[0], now)
                        this.addFloat(buf, metricName+".p75", percentiles[1], now)
                        this.addFloat(buf, metricName+".p90", percentiles[2], now)
                        this.addFloat(buf, metricName+".p99", percentiles[3], now)</span>
                }
        }

        <span class="cov0" title="0">log.Trace("Metrics: GraphitePublisher.Publish() \n%s", buf)
        _, err = conn.Write(buf.Bytes())

        if err != nil </span><span class="cov0" title="0">{
                log.Error(3, "Metrics: GraphitePublisher: Failed to send metrics! %s", err)
        }</span>
}

func (this *GraphitePublisher) addInt(buf *bytes.Buffer, metric string, value int64, now int64) <span class="cov0" title="0">{
        buf.WriteString(fmt.Sprintf("%s %d %d\n", metric, value, now))
}</span>

func (this *GraphitePublisher) addFloat(buf *bytes.Buffer, metric string, value float64, now int64) <span class="cov0" title="0">{
        buf.WriteString(fmt.Sprintf("%s %f %d\n", metric, value, now))
}</span>

func (this *GraphitePublisher) addCount(buf *bytes.Buffer, metric string, value int64, now int64) <span class="cov0" title="0">{
        delta := value

        if last, ok := this.prevCounts[metric]; ok </span><span class="cov0" title="0">{
                delta = calculateDelta(last, value)
        }</span>

        <span class="cov0" title="0">this.prevCounts[metric] = value
        buf.WriteString(fmt.Sprintf("%s %d %d\n", metric, delta, now))</span>
}
</pre>
		
		<pre class="file" id="file66" style="display: none">// includes code from
// https://raw.githubusercontent.com/rcrowley/go-metrics/master/sample.go
// Copyright 2012 Richard Crowley. All rights reserved.

package metrics

// Histograms calculate distribution statistics from a series of int64 values.
type Histogram interface {
        Metric

        Clear()
        Count() int64
        Max() int64
        Mean() float64
        Min() int64
        Percentile(float64) float64
        Percentiles([]float64) []float64
        StdDev() float64
        Sum() int64
        Update(int64)
        Variance() float64
}

func NewHistogram(meta *MetricMeta, s Sample) Histogram <span class="cov8" title="1">{
        return &amp;StandardHistogram{
                MetricMeta: meta,
                sample:     s,
        }
}</span>

// HistogramSnapshot is a read-only copy of another Histogram.
type HistogramSnapshot struct {
        *MetricMeta
        sample *SampleSnapshot
}

// Clear panics.
func (*HistogramSnapshot) Clear() <span class="cov0" title="0">{
        panic("Clear called on a HistogramSnapshot")</span>
}

// Count returns the number of samples recorded at the time the snapshot was
// taken.
func (h *HistogramSnapshot) Count() int64 <span class="cov8" title="1">{ return h.sample.Count() }</span>

// Max returns the maximum value in the sample at the time the snapshot was
// taken.
func (h *HistogramSnapshot) Max() int64 <span class="cov8" title="1">{ return h.sample.Max() }</span>

// Mean returns the mean of the values in the sample at the time the snapshot
// was taken.
func (h *HistogramSnapshot) Mean() float64 <span class="cov8" title="1">{ return h.sample.Mean() }</span>

// Min returns the minimum value in the sample at the time the snapshot was
// taken.
func (h *HistogramSnapshot) Min() int64 <span class="cov8" title="1">{ return h.sample.Min() }</span>

// Percentile returns an arbitrary percentile of values in the sample at the
// time the snapshot was taken.
func (h *HistogramSnapshot) Percentile(p float64) float64 <span class="cov0" title="0">{
        return h.sample.Percentile(p)
}</span>

// Percentiles returns a slice of arbitrary percentiles of values in the sample
// at the time the snapshot was taken.
func (h *HistogramSnapshot) Percentiles(ps []float64) []float64 <span class="cov8" title="1">{
        return h.sample.Percentiles(ps)
}</span>

// Sample returns the Sample underlying the histogram.
func (h *HistogramSnapshot) Sample() Sample <span class="cov0" title="0">{ return h.sample }</span>

// Snapshot returns the snapshot.
func (h *HistogramSnapshot) Snapshot() Metric <span class="cov0" title="0">{ return h }</span>

// StdDev returns the standard deviation of the values in the sample at the
// time the snapshot was taken.
func (h *HistogramSnapshot) StdDev() float64 <span class="cov8" title="1">{ return h.sample.StdDev() }</span>

// Sum returns the sum in the sample at the time the snapshot was taken.
func (h *HistogramSnapshot) Sum() int64 <span class="cov0" title="0">{ return h.sample.Sum() }</span>

// Update panics.
func (*HistogramSnapshot) Update(int64) <span class="cov0" title="0">{
        panic("Update called on a HistogramSnapshot")</span>
}

// Variance returns the variance of inputs at the time the snapshot was taken.
func (h *HistogramSnapshot) Variance() float64 <span class="cov0" title="0">{ return h.sample.Variance() }</span>

// NilHistogram is a no-op Histogram.
type NilHistogram struct {
        *MetricMeta
}

// Clear is a no-op.
func (NilHistogram) Clear() <span class="cov0" title="0">{}</span>

// Count is a no-op.
func (NilHistogram) Count() int64 <span class="cov0" title="0">{ return 0 }</span>

// Max is a no-op.
func (NilHistogram) Max() int64 <span class="cov0" title="0">{ return 0 }</span>

// Mean is a no-op.
func (NilHistogram) Mean() float64 <span class="cov0" title="0">{ return 0.0 }</span>

// Min is a no-op.
func (NilHistogram) Min() int64 <span class="cov0" title="0">{ return 0 }</span>

// Percentile is a no-op.
func (NilHistogram) Percentile(p float64) float64 <span class="cov0" title="0">{ return 0.0 }</span>

// Percentiles is a no-op.
func (NilHistogram) Percentiles(ps []float64) []float64 <span class="cov0" title="0">{
        return make([]float64, len(ps))
}</span>

// Sample is a no-op.
func (NilHistogram) Sample() Sample <span class="cov0" title="0">{ return NilSample{} }</span>

// Snapshot is a no-op.
func (n NilHistogram) Snapshot() Metric <span class="cov0" title="0">{ return n }</span>

// StdDev is a no-op.
func (NilHistogram) StdDev() float64 <span class="cov0" title="0">{ return 0.0 }</span>

// Sum is a no-op.
func (NilHistogram) Sum() int64 <span class="cov0" title="0">{ return 0 }</span>

// Update is a no-op.
func (NilHistogram) Update(v int64) <span class="cov0" title="0">{}</span>

// Variance is a no-op.
func (NilHistogram) Variance() float64 <span class="cov0" title="0">{ return 0.0 }</span>

// StandardHistogram is the standard implementation of a Histogram and uses a
// Sample to bound its memory use.
type StandardHistogram struct {
        *MetricMeta
        sample Sample
}

// Clear clears the histogram and its sample.
func (h *StandardHistogram) Clear() <span class="cov0" title="0">{ h.sample.Clear() }</span>

// Count returns the number of samples recorded since the histogram was last
// cleared.
func (h *StandardHistogram) Count() int64 <span class="cov8" title="1">{ return h.sample.Count() }</span>

// Max returns the maximum value in the sample.
func (h *StandardHistogram) Max() int64 <span class="cov8" title="1">{ return h.sample.Max() }</span>

// Mean returns the mean of the values in the sample.
func (h *StandardHistogram) Mean() float64 <span class="cov8" title="1">{ return h.sample.Mean() }</span>

// Min returns the minimum value in the sample.
func (h *StandardHistogram) Min() int64 <span class="cov8" title="1">{ return h.sample.Min() }</span>

// Percentile returns an arbitrary percentile of the values in the sample.
func (h *StandardHistogram) Percentile(p float64) float64 <span class="cov0" title="0">{
        return h.sample.Percentile(p)
}</span>

// Percentiles returns a slice of arbitrary percentiles of the values in the
// sample.
func (h *StandardHistogram) Percentiles(ps []float64) []float64 <span class="cov8" title="1">{
        return h.sample.Percentiles(ps)
}</span>

// Sample returns the Sample underlying the histogram.
func (h *StandardHistogram) Sample() Sample <span class="cov0" title="0">{ return h.sample }</span>

// Snapshot returns a read-only copy of the histogram.
func (h *StandardHistogram) Snapshot() Metric <span class="cov8" title="1">{
        return &amp;HistogramSnapshot{sample: h.sample.Snapshot().(*SampleSnapshot)}
}</span>

// StdDev returns the standard deviation of the values in the sample.
func (h *StandardHistogram) StdDev() float64 <span class="cov8" title="1">{ return h.sample.StdDev() }</span>

// Sum returns the sum in the sample.
func (h *StandardHistogram) Sum() int64 <span class="cov0" title="0">{ return h.sample.Sum() }</span>

// Update samples a new value.
func (h *StandardHistogram) Update(v int64) <span class="cov8" title="1">{ h.sample.Update(v) }</span>

// Variance returns the variance of the values in the sample.
func (h *StandardHistogram) Variance() float64 <span class="cov0" title="0">{ return h.sample.Variance() }</span>
</pre>
		
		<pre class="file" id="file67" style="display: none">// includes code from
// https://raw.githubusercontent.com/rcrowley/go-metrics/master/sample.go
// Copyright 2012 Richard Crowley. All rights reserved.

package metrics

import (
        "sync"
        "time"
)

// Meters count events to produce exponentially-weighted moving average rates
// at one-, five-, and fifteen-minutes and a mean rate.
type Meter interface {
        Metric

        Count() int64
        Mark(int64)
        Rate1() float64
        Rate5() float64
        Rate15() float64
        RateMean() float64
}

// NewMeter constructs a new StandardMeter and launches a goroutine.
func NewMeter(meta *MetricMeta) Meter <span class="cov0" title="0">{
        if UseNilMetrics </span><span class="cov0" title="0">{
                return NilMeter{}
        }</span>

        <span class="cov0" title="0">m := newStandardMeter(meta)
        arbiter.Lock()
        defer arbiter.Unlock()
        arbiter.meters = append(arbiter.meters, m)
        if !arbiter.started </span><span class="cov0" title="0">{
                arbiter.started = true
                go arbiter.tick()
        }</span>
        <span class="cov0" title="0">return m</span>
}

type MeterSnapshot struct {
        *MetricMeta
        count                          int64
        rate1, rate5, rate15, rateMean float64
}

// Count returns the count of events at the time the snapshot was taken.
func (m *MeterSnapshot) Count() int64 <span class="cov0" title="0">{ return m.count }</span>

// Mark panics.
func (*MeterSnapshot) Mark(n int64) <span class="cov0" title="0">{
        panic("Mark called on a MeterSnapshot")</span>
}

// Rate1 returns the one-minute moving average rate of events per second at the
// time the snapshot was taken.
func (m *MeterSnapshot) Rate1() float64 <span class="cov0" title="0">{ return m.rate1 }</span>

// Rate5 returns the five-minute moving average rate of events per second at
// the time the snapshot was taken.
func (m *MeterSnapshot) Rate5() float64 <span class="cov0" title="0">{ return m.rate5 }</span>

// Rate15 returns the fifteen-minute moving average rate of events per second
// at the time the snapshot was taken.
func (m *MeterSnapshot) Rate15() float64 <span class="cov0" title="0">{ return m.rate15 }</span>

// RateMean returns the meter's mean rate of events per second at the time the
// snapshot was taken.
func (m *MeterSnapshot) RateMean() float64 <span class="cov0" title="0">{ return m.rateMean }</span>

// Snapshot returns the snapshot.
func (m *MeterSnapshot) Snapshot() Metric <span class="cov0" title="0">{ return m }</span>

// NilMeter is a no-op Meter.
type NilMeter struct{ *MetricMeta }

// Count is a no-op.
func (NilMeter) Count() int64 <span class="cov0" title="0">{ return 0 }</span>

// Mark is a no-op.
func (NilMeter) Mark(n int64) <span class="cov0" title="0">{}</span>

// Rate1 is a no-op.
func (NilMeter) Rate1() float64 <span class="cov0" title="0">{ return 0.0 }</span>

// Rate5 is a no-op.
func (NilMeter) Rate5() float64 <span class="cov0" title="0">{ return 0.0 }</span>

// Rate15is a no-op.
func (NilMeter) Rate15() float64 <span class="cov0" title="0">{ return 0.0 }</span>

// RateMean is a no-op.
func (NilMeter) RateMean() float64 <span class="cov0" title="0">{ return 0.0 }</span>

// Snapshot is a no-op.
func (NilMeter) Snapshot() Metric <span class="cov0" title="0">{ return NilMeter{} }</span>

// StandardMeter is the standard implementation of a Meter.
type StandardMeter struct {
        *MetricMeta
        lock        sync.RWMutex
        snapshot    *MeterSnapshot
        a1, a5, a15 EWMA
        startTime   time.Time
}

func newStandardMeter(meta *MetricMeta) *StandardMeter <span class="cov0" title="0">{
        return &amp;StandardMeter{
                MetricMeta: meta,
                snapshot:   &amp;MeterSnapshot{MetricMeta: meta},
                a1:         NewEWMA1(),
                a5:         NewEWMA5(),
                a15:        NewEWMA15(),
                startTime:  time.Now(),
        }
}</span>

// Count returns the number of events recorded.
func (m *StandardMeter) Count() int64 <span class="cov0" title="0">{
        m.lock.RLock()
        count := m.snapshot.count
        m.lock.RUnlock()
        return count
}</span>

// Mark records the occurance of n events.
func (m *StandardMeter) Mark(n int64) <span class="cov0" title="0">{
        m.lock.Lock()
        defer m.lock.Unlock()
        m.snapshot.count += n
        m.a1.Update(n)
        m.a5.Update(n)
        m.a15.Update(n)
        m.updateSnapshot()
}</span>

// Rate1 returns the one-minute moving average rate of events per second.
func (m *StandardMeter) Rate1() float64 <span class="cov0" title="0">{
        m.lock.RLock()
        rate1 := m.snapshot.rate1
        m.lock.RUnlock()
        return rate1
}</span>

// Rate5 returns the five-minute moving average rate of events per second.
func (m *StandardMeter) Rate5() float64 <span class="cov0" title="0">{
        m.lock.RLock()
        rate5 := m.snapshot.rate5
        m.lock.RUnlock()
        return rate5
}</span>

// Rate15 returns the fifteen-minute moving average rate of events per second.
func (m *StandardMeter) Rate15() float64 <span class="cov0" title="0">{
        m.lock.RLock()
        rate15 := m.snapshot.rate15
        m.lock.RUnlock()
        return rate15
}</span>

// RateMean returns the meter's mean rate of events per second.
func (m *StandardMeter) RateMean() float64 <span class="cov0" title="0">{
        m.lock.RLock()
        rateMean := m.snapshot.rateMean
        m.lock.RUnlock()
        return rateMean
}</span>

// Snapshot returns a read-only copy of the meter.
func (m *StandardMeter) Snapshot() Metric <span class="cov0" title="0">{
        m.lock.RLock()
        snapshot := *m.snapshot
        m.lock.RUnlock()
        return &amp;snapshot
}</span>

func (m *StandardMeter) updateSnapshot() <span class="cov0" title="0">{
        // should run with write lock held on m.lock
        snapshot := m.snapshot
        snapshot.rate1 = m.a1.Rate()
        snapshot.rate5 = m.a5.Rate()
        snapshot.rate15 = m.a15.Rate()
        snapshot.rateMean = float64(snapshot.count) / time.Since(m.startTime).Seconds()
}</span>

func (m *StandardMeter) tick() <span class="cov0" title="0">{
        m.lock.Lock()
        defer m.lock.Unlock()
        m.a1.Tick()
        m.a5.Tick()
        m.a15.Tick()
        m.updateSnapshot()
}</span>

type meterArbiter struct {
        sync.RWMutex
        started bool
        meters  []*StandardMeter
        ticker  *time.Ticker
}

var arbiter = meterArbiter{ticker: time.NewTicker(5e9)}

// Ticks meters on the scheduled interval
func (ma *meterArbiter) tick() <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ma.ticker.C:<span class="cov0" title="0">
                        ma.tickMeters()</span>
                }
        }
}

func (ma *meterArbiter) tickMeters() <span class="cov0" title="0">{
        ma.RLock()
        defer ma.RUnlock()
        for _, meter := range ma.meters </span><span class="cov0" title="0">{
                meter.tick()
        }</span>
}
</pre>
		
		<pre class="file" id="file68" style="display: none">package metrics

var MetricStats Registry
var UseNilMetrics bool

func init() <span class="cov8" title="1">{
        // init with nil metrics
        initMetricVars(&amp;MetricSettings{})
}</span>

var (
        M_Instance_Start                       Counter
        M_Page_Status_200                      Counter
        M_Page_Status_500                      Counter
        M_Page_Status_404                      Counter
        M_Page_Status_Unknown                  Counter
        M_Api_Status_200                       Counter
        M_Api_Status_404                       Counter
        M_Api_Status_500                       Counter
        M_Api_Status_Unknown                   Counter
        M_Proxy_Status_200                     Counter
        M_Proxy_Status_404                     Counter
        M_Proxy_Status_500                     Counter
        M_Proxy_Status_Unknown                 Counter
        M_Api_User_SignUpStarted               Counter
        M_Api_User_SignUpCompleted             Counter
        M_Api_User_SignUpInvite                Counter
        M_Api_Dashboard_Save                   Timer
        M_Api_Dashboard_Get                    Timer
        M_Api_Dashboard_Search                 Timer
        M_Api_Admin_User_Create                Counter
        M_Api_Login_Post                       Counter
        M_Api_Login_OAuth                      Counter
        M_Api_Org_Create                       Counter
        M_Api_Dashboard_Snapshot_Create        Counter
        M_Api_Dashboard_Snapshot_External      Counter
        M_Api_Dashboard_Snapshot_Get           Counter
        M_Models_Dashboard_Insert              Counter
        M_Alerting_Result_State_Alerting       Counter
        M_Alerting_Result_State_Ok             Counter
        M_Alerting_Result_State_Paused         Counter
        M_Alerting_Result_State_NoData         Counter
        M_Alerting_Result_State_Pending        Counter
        M_Alerting_Notification_Sent_Slack     Counter
        M_Alerting_Notification_Sent_Email     Counter
        M_Alerting_Notification_Sent_Webhook   Counter
        M_Alerting_Notification_Sent_PagerDuty Counter
        M_Alerting_Notification_Sent_LINE      Counter
        M_Alerting_Notification_Sent_Victorops Counter
        M_Alerting_Notification_Sent_OpsGenie  Counter
        M_Alerting_Notification_Sent_Telegram  Counter
        M_Alerting_Notification_Sent_Sensu     Counter
        M_Aws_CloudWatch_GetMetricStatistics   Counter
        M_Aws_CloudWatch_ListMetrics           Counter

        // Timers
        M_DataSource_ProxyReq_Timer Timer
        M_Alerting_Execution_Time   Timer

        // StatTotals
        M_Alerting_Active_Alerts Gauge
        M_StatTotal_Dashboards   Gauge
        M_StatTotal_Users        Gauge
        M_StatTotal_Orgs         Gauge
        M_StatTotal_Playlists    Gauge
)

func initMetricVars(settings *MetricSettings) <span class="cov8" title="1">{
        UseNilMetrics = settings.Enabled == false
        MetricStats = NewRegistry()

        M_Instance_Start = RegCounter("instance_start")

        M_Page_Status_200 = RegCounter("page.resp_status", "code", "200")
        M_Page_Status_500 = RegCounter("page.resp_status", "code", "500")
        M_Page_Status_404 = RegCounter("page.resp_status", "code", "404")
        M_Page_Status_Unknown = RegCounter("page.resp_status", "code", "unknown")

        M_Api_Status_200 = RegCounter("api.resp_status", "code", "200")
        M_Api_Status_404 = RegCounter("api.resp_status", "code", "404")
        M_Api_Status_500 = RegCounter("api.resp_status", "code", "500")
        M_Api_Status_Unknown = RegCounter("api.resp_status", "code", "unknown")

        M_Proxy_Status_200 = RegCounter("proxy.resp_status", "code", "200")
        M_Proxy_Status_404 = RegCounter("proxy.resp_status", "code", "404")
        M_Proxy_Status_500 = RegCounter("proxy.resp_status", "code", "500")
        M_Proxy_Status_Unknown = RegCounter("proxy.resp_status", "code", "unknown")

        M_Api_User_SignUpStarted = RegCounter("api.user.signup_started")
        M_Api_User_SignUpCompleted = RegCounter("api.user.signup_completed")
        M_Api_User_SignUpInvite = RegCounter("api.user.signup_invite")

        M_Api_Dashboard_Save = RegTimer("api.dashboard.save")
        M_Api_Dashboard_Get = RegTimer("api.dashboard.get")
        M_Api_Dashboard_Search = RegTimer("api.dashboard.search")

        M_Api_Admin_User_Create = RegCounter("api.admin.user_create")
        M_Api_Login_Post = RegCounter("api.login.post")
        M_Api_Login_OAuth = RegCounter("api.login.oauth")
        M_Api_Org_Create = RegCounter("api.org.create")

        M_Api_Dashboard_Snapshot_Create = RegCounter("api.dashboard_snapshot.create")
        M_Api_Dashboard_Snapshot_External = RegCounter("api.dashboard_snapshot.external")
        M_Api_Dashboard_Snapshot_Get = RegCounter("api.dashboard_snapshot.get")

        M_Models_Dashboard_Insert = RegCounter("models.dashboard.insert")

        M_Alerting_Result_State_Alerting = RegCounter("alerting.result", "state", "alerting")
        M_Alerting_Result_State_Ok = RegCounter("alerting.result", "state", "ok")
        M_Alerting_Result_State_Paused = RegCounter("alerting.result", "state", "paused")
        M_Alerting_Result_State_NoData = RegCounter("alerting.result", "state", "no_data")
        M_Alerting_Result_State_Pending = RegCounter("alerting.result", "state", "pending")

        M_Alerting_Notification_Sent_Slack = RegCounter("alerting.notifications_sent", "type", "slack")
        M_Alerting_Notification_Sent_Email = RegCounter("alerting.notifications_sent", "type", "email")
        M_Alerting_Notification_Sent_Webhook = RegCounter("alerting.notifications_sent", "type", "webhook")
        M_Alerting_Notification_Sent_PagerDuty = RegCounter("alerting.notifications_sent", "type", "pagerduty")
        M_Alerting_Notification_Sent_Victorops = RegCounter("alerting.notifications_sent", "type", "victorops")
        M_Alerting_Notification_Sent_OpsGenie = RegCounter("alerting.notifications_sent", "type", "opsgenie")
        M_Alerting_Notification_Sent_Telegram = RegCounter("alerting.notifications_sent", "type", "telegram")
        M_Alerting_Notification_Sent_Sensu = RegCounter("alerting.notifications_sent", "type", "sensu")
        M_Alerting_Notification_Sent_LINE = RegCounter("alerting.notifications_sent", "type", "LINE")

        M_Aws_CloudWatch_GetMetricStatistics = RegCounter("aws.cloudwatch.get_metric_statistics")
        M_Aws_CloudWatch_ListMetrics = RegCounter("aws.cloudwatch.list_metrics")

        // Timers
        M_DataSource_ProxyReq_Timer = RegTimer("api.dataproxy.request.all")
        M_Alerting_Execution_Time = RegTimer("alerting.execution_time")

        // StatTotals
        M_Alerting_Active_Alerts = RegGauge("alerting.active_alerts")
        M_StatTotal_Dashboards = RegGauge("stat_totals", "stat", "dashboards")
        M_StatTotal_Users = RegGauge("stat_totals", "stat", "users")
        M_StatTotal_Orgs = RegGauge("stat_totals", "stat", "orgs")
        M_StatTotal_Playlists = RegGauge("stat_totals", "stat", "playlists")
}</span>
</pre>
		
		<pre class="file" id="file69" style="display: none">package metrics

import (
        "bytes"
        "encoding/json"
        "net/http"
        "strings"
        "time"

        "github.com/grafana/grafana/pkg/bus"
        "github.com/grafana/grafana/pkg/log"
        m "github.com/grafana/grafana/pkg/models"
        "github.com/grafana/grafana/pkg/plugins"
        "github.com/grafana/grafana/pkg/setting"
)

var metricsLogger log.Logger = log.New("metrics")
var metricPublishCounter int64 = 0

func Init() <span class="cov0" title="0">{
        settings := readSettings()
        initMetricVars(settings)
        go instrumentationLoop(settings)
}</span>

func instrumentationLoop(settings *MetricSettings) chan struct{} <span class="cov0" title="0">{
        M_Instance_Start.Inc(1)

        onceEveryDayTick := time.NewTicker(time.Hour * 24)
        secondTicker := time.NewTicker(time.Second * time.Duration(settings.IntervalSeconds))

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-onceEveryDayTick.C:<span class="cov0" title="0">
                        sendUsageStats()</span>
                case &lt;-secondTicker.C:<span class="cov0" title="0">
                        if settings.Enabled </span><span class="cov0" title="0">{
                                sendMetrics(settings)
                        }</span>
                }
        }
}

func sendMetrics(settings *MetricSettings) <span class="cov0" title="0">{
        if len(settings.Publishers) == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">updateTotalStats()

        metrics := MetricStats.GetSnapshots()
        for _, publisher := range settings.Publishers </span><span class="cov0" title="0">{
                publisher.Publish(metrics)
        }</span>
}

func updateTotalStats() <span class="cov0" title="0">{

        // every interval also publish totals
        metricPublishCounter++
        if metricPublishCounter%10 == 0 </span><span class="cov0" title="0">{
                // get stats
                statsQuery := m.GetSystemStatsQuery{}
                if err := bus.Dispatch(&amp;statsQuery); err != nil </span><span class="cov0" title="0">{
                        metricsLogger.Error("Failed to get system stats", "error", err)
                        return
                }</span>

                <span class="cov0" title="0">M_StatTotal_Dashboards.Update(statsQuery.Result.DashboardCount)
                M_StatTotal_Users.Update(statsQuery.Result.UserCount)
                M_StatTotal_Playlists.Update(statsQuery.Result.PlaylistCount)
                M_StatTotal_Orgs.Update(statsQuery.Result.OrgCount)</span>
        }
}

func sendUsageStats() <span class="cov0" title="0">{
        if !setting.ReportingEnabled </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">metricsLogger.Debug("Sending anonymous usage stats to stats.grafana.org")

        version := strings.Replace(setting.BuildVersion, ".", "_", -1)

        metrics := map[string]interface{}{}
        report := map[string]interface{}{
                "version": version,
                "metrics": metrics,
        }

        statsQuery := m.GetSystemStatsQuery{}
        if err := bus.Dispatch(&amp;statsQuery); err != nil </span><span class="cov0" title="0">{
                metricsLogger.Error("Failed to get system stats", "error", err)
                return
        }</span>

        <span class="cov0" title="0">metrics["stats.dashboards.count"] = statsQuery.Result.DashboardCount
        metrics["stats.users.count"] = statsQuery.Result.UserCount
        metrics["stats.orgs.count"] = statsQuery.Result.OrgCount
        metrics["stats.playlist.count"] = statsQuery.Result.PlaylistCount
        metrics["stats.plugins.apps.count"] = len(plugins.Apps)
        metrics["stats.plugins.panels.count"] = len(plugins.Panels)
        metrics["stats.plugins.datasources.count"] = len(plugins.DataSources)
        metrics["stats.alerts.count"] = statsQuery.Result.AlertCount

        dsStats := m.GetDataSourceStatsQuery{}
        if err := bus.Dispatch(&amp;dsStats); err != nil </span><span class="cov0" title="0">{
                metricsLogger.Error("Failed to get datasource stats", "error", err)
                return
        }</span>

        // send counters for each data source
        // but ignore any custom data sources
        // as sending that name could be sensitive information
        <span class="cov0" title="0">dsOtherCount := 0
        for _, dsStat := range dsStats.Result </span><span class="cov0" title="0">{
                if m.IsKnownDataSourcePlugin(dsStat.Type) </span><span class="cov0" title="0">{
                        metrics["stats.ds."+dsStat.Type+".count"] = dsStat.Count
                }</span><span class="cov0" title="0"> else {
                        dsOtherCount += dsStat.Count
                }</span>
        }
        <span class="cov0" title="0">metrics["stats.ds.other.count"] = dsOtherCount

        out, _ := json.MarshalIndent(report, "", " ")
        data := bytes.NewBuffer(out)

        client := http.Client{Timeout: time.Duration(5 * time.Second)}
        go client.Post("https://stats.grafana.org/grafana-usage-report", "application/json", data)</span>
}
</pre>
		
		<pre class="file" id="file70" style="display: none">package metrics

import "sync"

type Registry interface {
        GetSnapshots() []Metric
        Register(metric Metric)
}

// The standard implementation of a Registry is a mutex-protected map
// of names to metrics.
type StandardRegistry struct {
        metrics []Metric
        mutex   sync.Mutex
}

// Create a new registry.
func NewRegistry() Registry <span class="cov8" title="1">{
        return &amp;StandardRegistry{
                metrics: make([]Metric, 0),
        }
}</span>

func (r *StandardRegistry) Register(metric Metric) <span class="cov8" title="1">{
        r.mutex.Lock()
        defer r.mutex.Unlock()
        r.metrics = append(r.metrics, metric)
}</span>

// Call the given function for each registered metric.
func (r *StandardRegistry) GetSnapshots() []Metric <span class="cov0" title="0">{
        metrics := make([]Metric, len(r.metrics))
        for i, metric := range r.metrics </span><span class="cov0" title="0">{
                metrics[i] = metric.Snapshot()
        }</span>
        <span class="cov0" title="0">return metrics</span>
}
</pre>
		
		<pre class="file" id="file71" style="display: none">// includes code from
// https://raw.githubusercontent.com/rcrowley/go-metrics/master/sample.go
// Copyright 2012 Richard Crowley. All rights reserved.

package metrics

import (
        "math"
        "math/rand"
        "sort"
        "sync"
        "time"
)

const rescaleThreshold = time.Hour

// Samples maintain a statistically-significant selection of values from
// a stream.
type Sample interface {
        Clear()
        Count() int64
        Max() int64
        Mean() float64
        Min() int64
        Percentile(float64) float64
        Percentiles([]float64) []float64
        Size() int
        Snapshot() Sample
        StdDev() float64
        Sum() int64
        Update(int64)
        Values() []int64
        Variance() float64
}

// ExpDecaySample is an exponentially-decaying sample using a forward-decaying
// priority reservoir.  See Cormode et al's "Forward Decay: A Practical Time
// Decay Model for Streaming Systems".
//
// &lt;http://www.research.att.com/people/Cormode_Graham/library/publications/CormodeShkapenyukSrivastavaXu09.pdf&gt;
type ExpDecaySample struct {
        alpha         float64
        count         int64
        mutex         sync.Mutex
        reservoirSize int
        t0, t1        time.Time
        values        *expDecaySampleHeap
}

// NewExpDecaySample constructs a new exponentially-decaying sample with the
// given reservoir size and alpha.
func NewExpDecaySample(reservoirSize int, alpha float64) Sample <span class="cov8" title="1">{
        s := &amp;ExpDecaySample{
                alpha:         alpha,
                reservoirSize: reservoirSize,
                t0:            time.Now(),
                values:        newExpDecaySampleHeap(reservoirSize),
        }
        s.t1 = s.t0.Add(rescaleThreshold)
        return s
}</span>

// Clear clears all samples.
func (s *ExpDecaySample) Clear() <span class="cov0" title="0">{
        s.mutex.Lock()
        defer s.mutex.Unlock()
        s.count = 0
        s.t0 = time.Now()
        s.t1 = s.t0.Add(rescaleThreshold)
        s.values.Clear()
}</span>

// Count returns the number of samples recorded, which may exceed the
// reservoir size.
func (s *ExpDecaySample) Count() int64 <span class="cov8" title="1">{
        s.mutex.Lock()
        defer s.mutex.Unlock()
        return s.count
}</span>

// Max returns the maximum value in the sample, which may not be the maximum
// value ever to be part of the sample.
func (s *ExpDecaySample) Max() int64 <span class="cov8" title="1">{
        return SampleMax(s.Values())
}</span>

// Mean returns the mean of the values in the sample.
func (s *ExpDecaySample) Mean() float64 <span class="cov8" title="1">{
        return SampleMean(s.Values())
}</span>

// Min returns the minimum value in the sample, which may not be the minimum
// value ever to be part of the sample.
func (s *ExpDecaySample) Min() int64 <span class="cov8" title="1">{
        return SampleMin(s.Values())
}</span>

// Percentile returns an arbitrary percentile of values in the sample.
func (s *ExpDecaySample) Percentile(p float64) float64 <span class="cov0" title="0">{
        return SamplePercentile(s.Values(), p)
}</span>

// Percentiles returns a slice of arbitrary percentiles of values in the
// sample.
func (s *ExpDecaySample) Percentiles(ps []float64) []float64 <span class="cov8" title="1">{
        return SamplePercentiles(s.Values(), ps)
}</span>

// Size returns the size of the sample, which is at most the reservoir size.
func (s *ExpDecaySample) Size() int <span class="cov8" title="1">{
        s.mutex.Lock()
        defer s.mutex.Unlock()
        return s.values.Size()
}</span>

// Snapshot returns a read-only copy of the sample.
func (s *ExpDecaySample) Snapshot() Sample <span class="cov8" title="1">{
        s.mutex.Lock()
        defer s.mutex.Unlock()
        vals := s.values.Values()
        values := make([]int64, len(vals))
        for i, v := range vals </span><span class="cov8" title="1">{
                values[i] = v.v
        }</span>
        <span class="cov8" title="1">return &amp;SampleSnapshot{
                count:  s.count,
                values: values,
        }</span>
}

// StdDev returns the standard deviation of the values in the sample.
func (s *ExpDecaySample) StdDev() float64 <span class="cov8" title="1">{
        return SampleStdDev(s.Values())
}</span>

// Sum returns the sum of the values in the sample.
func (s *ExpDecaySample) Sum() int64 <span class="cov0" title="0">{
        return SampleSum(s.Values())
}</span>

// Update samples a new value.
func (s *ExpDecaySample) Update(v int64) <span class="cov8" title="1">{
        s.update(time.Now(), v)
}</span>

// Values returns a copy of the values in the sample.
func (s *ExpDecaySample) Values() []int64 <span class="cov8" title="1">{
        s.mutex.Lock()
        defer s.mutex.Unlock()
        vals := s.values.Values()
        values := make([]int64, len(vals))
        for i, v := range vals </span><span class="cov8" title="1">{
                values[i] = v.v
        }</span>
        <span class="cov8" title="1">return values</span>
}

// Variance returns the variance of the values in the sample.
func (s *ExpDecaySample) Variance() float64 <span class="cov0" title="0">{
        return SampleVariance(s.Values())
}</span>

// update samples a new value at a particular timestamp.  This is a method all
// its own to facilitate testing.
func (s *ExpDecaySample) update(t time.Time, v int64) <span class="cov8" title="1">{
        s.mutex.Lock()
        defer s.mutex.Unlock()
        s.count++
        if s.values.Size() == s.reservoirSize </span><span class="cov8" title="1">{
                s.values.Pop()
        }</span>
        <span class="cov8" title="1">s.values.Push(expDecaySample{
                k: math.Exp(t.Sub(s.t0).Seconds()*s.alpha) / rand.Float64(),
                v: v,
        })
        if t.After(s.t1) </span><span class="cov8" title="1">{
                values := s.values.Values()
                t0 := s.t0
                s.values.Clear()
                s.t0 = t
                s.t1 = s.t0.Add(rescaleThreshold)
                for _, v := range values </span><span class="cov8" title="1">{
                        v.k = v.k * math.Exp(-s.alpha*s.t0.Sub(t0).Seconds())
                        s.values.Push(v)
                }</span>
        }
}

// NilSample is a no-op Sample.
type NilSample struct{}

// Clear is a no-op.
func (NilSample) Clear() <span class="cov0" title="0">{}</span>

// Count is a no-op.
func (NilSample) Count() int64 <span class="cov0" title="0">{ return 0 }</span>

// Max is a no-op.
func (NilSample) Max() int64 <span class="cov0" title="0">{ return 0 }</span>

// Mean is a no-op.
func (NilSample) Mean() float64 <span class="cov0" title="0">{ return 0.0 }</span>

// Min is a no-op.
func (NilSample) Min() int64 <span class="cov0" title="0">{ return 0 }</span>

// Percentile is a no-op.
func (NilSample) Percentile(p float64) float64 <span class="cov0" title="0">{ return 0.0 }</span>

// Percentiles is a no-op.
func (NilSample) Percentiles(ps []float64) []float64 <span class="cov0" title="0">{
        return make([]float64, len(ps))
}</span>

// Size is a no-op.
func (NilSample) Size() int <span class="cov0" title="0">{ return 0 }</span>

// Sample is a no-op.
func (NilSample) Snapshot() Sample <span class="cov0" title="0">{ return NilSample{} }</span>

// StdDev is a no-op.
func (NilSample) StdDev() float64 <span class="cov0" title="0">{ return 0.0 }</span>

// Sum is a no-op.
func (NilSample) Sum() int64 <span class="cov0" title="0">{ return 0 }</span>

// Update is a no-op.
func (NilSample) Update(v int64) <span class="cov0" title="0">{}</span>

// Values is a no-op.
func (NilSample) Values() []int64 <span class="cov0" title="0">{ return []int64{} }</span>

// Variance is a no-op.
func (NilSample) Variance() float64 <span class="cov0" title="0">{ return 0.0 }</span>

// SampleMax returns the maximum value of the slice of int64.
func SampleMax(values []int64) int64 <span class="cov8" title="1">{
        if 0 == len(values) </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">var max int64 = math.MinInt64
        for _, v := range values </span><span class="cov8" title="1">{
                if max &lt; v </span><span class="cov8" title="1">{
                        max = v
                }</span>
        }
        <span class="cov8" title="1">return max</span>
}

// SampleMean returns the mean value of the slice of int64.
func SampleMean(values []int64) float64 <span class="cov8" title="1">{
        if 0 == len(values) </span><span class="cov8" title="1">{
                return 0.0
        }</span>
        <span class="cov8" title="1">return float64(SampleSum(values)) / float64(len(values))</span>
}

// SampleMin returns the minimum value of the slice of int64.
func SampleMin(values []int64) int64 <span class="cov8" title="1">{
        if 0 == len(values) </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">var min int64 = math.MaxInt64
        for _, v := range values </span><span class="cov8" title="1">{
                if min &gt; v </span><span class="cov8" title="1">{
                        min = v
                }</span>
        }
        <span class="cov8" title="1">return min</span>
}

// SamplePercentiles returns an arbitrary percentile of the slice of int64.
func SamplePercentile(values int64Slice, p float64) float64 <span class="cov0" title="0">{
        return SamplePercentiles(values, []float64{p})[0]
}</span>

// SamplePercentiles returns a slice of arbitrary percentiles of the slice of
// int64.
func SamplePercentiles(values int64Slice, ps []float64) []float64 <span class="cov8" title="1">{
        scores := make([]float64, len(ps))
        size := len(values)
        if size &gt; 0 </span><span class="cov8" title="1">{
                sort.Sort(values)
                for i, p := range ps </span><span class="cov8" title="1">{
                        pos := p * float64(size+1)
                        if pos &lt; 1.0 </span><span class="cov0" title="0">{
                                scores[i] = float64(values[0])
                        }</span><span class="cov8" title="1"> else if pos &gt;= float64(size) </span><span class="cov0" title="0">{
                                scores[i] = float64(values[size-1])
                        }</span><span class="cov8" title="1"> else {
                                lower := float64(values[int(pos)-1])
                                upper := float64(values[int(pos)])
                                scores[i] = lower + (pos-math.Floor(pos))*(upper-lower)
                        }</span>
                }
        }
        <span class="cov8" title="1">return scores</span>
}

// SampleSnapshot is a read-only copy of another Sample.
type SampleSnapshot struct {
        count  int64
        values []int64
}

// Clear panics.
func (*SampleSnapshot) Clear() <span class="cov0" title="0">{
        panic("Clear called on a SampleSnapshot")</span>
}

// Count returns the count of inputs at the time the snapshot was taken.
func (s *SampleSnapshot) Count() int64 <span class="cov8" title="1">{ return s.count }</span>

// Max returns the maximal value at the time the snapshot was taken.
func (s *SampleSnapshot) Max() int64 <span class="cov8" title="1">{ return SampleMax(s.values) }</span>

// Mean returns the mean value at the time the snapshot was taken.
func (s *SampleSnapshot) Mean() float64 <span class="cov8" title="1">{ return SampleMean(s.values) }</span>

// Min returns the minimal value at the time the snapshot was taken.
func (s *SampleSnapshot) Min() int64 <span class="cov8" title="1">{ return SampleMin(s.values) }</span>

// Percentile returns an arbitrary percentile of values at the time the
// snapshot was taken.
func (s *SampleSnapshot) Percentile(p float64) float64 <span class="cov0" title="0">{
        return SamplePercentile(s.values, p)
}</span>

// Percentiles returns a slice of arbitrary percentiles of values at the time
// the snapshot was taken.
func (s *SampleSnapshot) Percentiles(ps []float64) []float64 <span class="cov8" title="1">{
        return SamplePercentiles(s.values, ps)
}</span>

// Size returns the size of the sample at the time the snapshot was taken.
func (s *SampleSnapshot) Size() int <span class="cov0" title="0">{ return len(s.values) }</span>

// Snapshot returns the snapshot.
func (s *SampleSnapshot) Snapshot() Sample <span class="cov0" title="0">{ return s }</span>

// StdDev returns the standard deviation of values at the time the snapshot was
// taken.
func (s *SampleSnapshot) StdDev() float64 <span class="cov8" title="1">{ return SampleStdDev(s.values) }</span>

// Sum returns the sum of values at the time the snapshot was taken.
func (s *SampleSnapshot) Sum() int64 <span class="cov0" title="0">{ return SampleSum(s.values) }</span>

// Update panics.
func (*SampleSnapshot) Update(int64) <span class="cov0" title="0">{
        panic("Update called on a SampleSnapshot")</span>
}

// Values returns a copy of the values in the sample.
func (s *SampleSnapshot) Values() []int64 <span class="cov0" title="0">{
        values := make([]int64, len(s.values))
        copy(values, s.values)
        return values
}</span>

// Variance returns the variance of values at the time the snapshot was taken.
func (s *SampleSnapshot) Variance() float64 <span class="cov0" title="0">{ return SampleVariance(s.values) }</span>

// SampleStdDev returns the standard deviation of the slice of int64.
func SampleStdDev(values []int64) float64 <span class="cov8" title="1">{
        return math.Sqrt(SampleVariance(values))
}</span>

// SampleSum returns the sum of the slice of int64.
func SampleSum(values []int64) int64 <span class="cov8" title="1">{
        var sum int64
        for _, v := range values </span><span class="cov8" title="1">{
                sum += v
        }</span>
        <span class="cov8" title="1">return sum</span>
}

// SampleVariance returns the variance of the slice of int64.
func SampleVariance(values []int64) float64 <span class="cov8" title="1">{
        if 0 == len(values) </span><span class="cov8" title="1">{
                return 0.0
        }</span>
        <span class="cov8" title="1">m := SampleMean(values)
        var sum float64
        for _, v := range values </span><span class="cov8" title="1">{
                d := float64(v) - m
                sum += d * d
        }</span>
        <span class="cov8" title="1">return sum / float64(len(values))</span>
}

// A uniform sample using Vitter's Algorithm R.
//
// &lt;http://www.cs.umd.edu/~samir/498/vitter.pdf&gt;
type UniformSample struct {
        count         int64
        mutex         sync.Mutex
        reservoirSize int
        values        []int64
}

// NewUniformSample constructs a new uniform sample with the given reservoir
// size.
func NewUniformSample(reservoirSize int) Sample <span class="cov8" title="1">{
        return &amp;UniformSample{
                reservoirSize: reservoirSize,
                values:        make([]int64, 0, reservoirSize),
        }
}</span>

// Clear clears all samples.
func (s *UniformSample) Clear() <span class="cov0" title="0">{
        s.mutex.Lock()
        defer s.mutex.Unlock()
        s.count = 0
        s.values = make([]int64, 0, s.reservoirSize)
}</span>

// Count returns the number of samples recorded, which may exceed the
// reservoir size.
func (s *UniformSample) Count() int64 <span class="cov8" title="1">{
        s.mutex.Lock()
        defer s.mutex.Unlock()
        return s.count
}</span>

// Max returns the maximum value in the sample, which may not be the maximum
// value ever to be part of the sample.
func (s *UniformSample) Max() int64 <span class="cov8" title="1">{
        s.mutex.Lock()
        defer s.mutex.Unlock()
        return SampleMax(s.values)
}</span>

// Mean returns the mean of the values in the sample.
func (s *UniformSample) Mean() float64 <span class="cov8" title="1">{
        s.mutex.Lock()
        defer s.mutex.Unlock()
        return SampleMean(s.values)
}</span>

// Min returns the minimum value in the sample, which may not be the minimum
// value ever to be part of the sample.
func (s *UniformSample) Min() int64 <span class="cov8" title="1">{
        s.mutex.Lock()
        defer s.mutex.Unlock()
        return SampleMin(s.values)
}</span>

// Percentile returns an arbitrary percentile of values in the sample.
func (s *UniformSample) Percentile(p float64) float64 <span class="cov0" title="0">{
        s.mutex.Lock()
        defer s.mutex.Unlock()
        return SamplePercentile(s.values, p)
}</span>

// Percentiles returns a slice of arbitrary percentiles of values in the
// sample.
func (s *UniformSample) Percentiles(ps []float64) []float64 <span class="cov8" title="1">{
        s.mutex.Lock()
        defer s.mutex.Unlock()
        return SamplePercentiles(s.values, ps)
}</span>

// Size returns the size of the sample, which is at most the reservoir size.
func (s *UniformSample) Size() int <span class="cov8" title="1">{
        s.mutex.Lock()
        defer s.mutex.Unlock()
        return len(s.values)
}</span>

// Snapshot returns a read-only copy of the sample.
func (s *UniformSample) Snapshot() Sample <span class="cov8" title="1">{
        s.mutex.Lock()
        defer s.mutex.Unlock()
        values := make([]int64, len(s.values))
        copy(values, s.values)
        return &amp;SampleSnapshot{
                count:  s.count,
                values: values,
        }
}</span>

// StdDev returns the standard deviation of the values in the sample.
func (s *UniformSample) StdDev() float64 <span class="cov8" title="1">{
        s.mutex.Lock()
        defer s.mutex.Unlock()
        return SampleStdDev(s.values)
}</span>

// Sum returns the sum of the values in the sample.
func (s *UniformSample) Sum() int64 <span class="cov0" title="0">{
        s.mutex.Lock()
        defer s.mutex.Unlock()
        return SampleSum(s.values)
}</span>

// Update samples a new value.
func (s *UniformSample) Update(v int64) <span class="cov8" title="1">{
        s.mutex.Lock()
        defer s.mutex.Unlock()
        s.count++
        if len(s.values) &lt; s.reservoirSize </span><span class="cov8" title="1">{
                s.values = append(s.values, v)
        }</span><span class="cov8" title="1"> else {
                r := rand.Int63n(s.count)
                if r &lt; int64(len(s.values)) </span><span class="cov8" title="1">{
                        s.values[int(r)] = v
                }</span>
        }
}

// Values returns a copy of the values in the sample.
func (s *UniformSample) Values() []int64 <span class="cov8" title="1">{
        s.mutex.Lock()
        defer s.mutex.Unlock()
        values := make([]int64, len(s.values))
        copy(values, s.values)
        return values
}</span>

// Variance returns the variance of the values in the sample.
func (s *UniformSample) Variance() float64 <span class="cov0" title="0">{
        s.mutex.Lock()
        defer s.mutex.Unlock()
        return SampleVariance(s.values)
}</span>

// expDecaySample represents an individual sample in a heap.
type expDecaySample struct {
        k float64
        v int64
}

func newExpDecaySampleHeap(reservoirSize int) *expDecaySampleHeap <span class="cov8" title="1">{
        return &amp;expDecaySampleHeap{make([]expDecaySample, 0, reservoirSize)}
}</span>

// expDecaySampleHeap is a min-heap of expDecaySamples.
// The internal implementation is copied from the standard library's container/heap
type expDecaySampleHeap struct {
        s []expDecaySample
}

func (h *expDecaySampleHeap) Clear() <span class="cov8" title="1">{
        h.s = h.s[:0]
}</span>

func (h *expDecaySampleHeap) Push(s expDecaySample) <span class="cov8" title="1">{
        n := len(h.s)
        h.s = h.s[0 : n+1]
        h.s[n] = s
        h.up(n)
}</span>

func (h *expDecaySampleHeap) Pop() expDecaySample <span class="cov8" title="1">{
        n := len(h.s) - 1
        h.s[0], h.s[n] = h.s[n], h.s[0]
        h.down(0, n)

        n = len(h.s)
        s := h.s[n-1]
        h.s = h.s[0 : n-1]
        return s
}</span>

func (h *expDecaySampleHeap) Size() int <span class="cov8" title="1">{
        return len(h.s)
}</span>

func (h *expDecaySampleHeap) Values() []expDecaySample <span class="cov8" title="1">{
        return h.s
}</span>

func (h *expDecaySampleHeap) up(j int) <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                i := (j - 1) / 2 // parent
                if i == j || !(h.s[j].k &lt; h.s[i].k) </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">h.s[i], h.s[j] = h.s[j], h.s[i]
                j = i</span>
        }
}

func (h *expDecaySampleHeap) down(i, n int) <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                j1 := 2*i + 1
                if j1 &gt;= n || j1 &lt; 0 </span><span class="cov8" title="1">{ // j1 &lt; 0 after int overflow
                        break</span>
                }
                <span class="cov8" title="1">j := j1 // left child
                if j2 := j1 + 1; j2 &lt; n &amp;&amp; !(h.s[j1].k &lt; h.s[j2].k) </span><span class="cov8" title="1">{
                        j = j2 // = 2*i + 2  // right child
                }</span>
                <span class="cov8" title="1">if !(h.s[j].k &lt; h.s[i].k) </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">h.s[i], h.s[j] = h.s[j], h.s[i]
                i = j</span>
        }
}

type int64Slice []int64

func (p int64Slice) Len() int           <span class="cov8" title="1">{ return len(p) }</span>
func (p int64Slice) Less(i, j int) bool <span class="cov8" title="1">{ return p[i] &lt; p[j] }</span>
func (p int64Slice) Swap(i, j int)      <span class="cov8" title="1">{ p[i], p[j] = p[j], p[i] }</span>
</pre>
		
		<pre class="file" id="file72" style="display: none">package metrics

import "github.com/grafana/grafana/pkg/setting"

type MetricPublisher interface {
        Publish(metrics []Metric)
}

type MetricSettings struct {
        Enabled         bool
        IntervalSeconds int64

        Publishers []MetricPublisher
}

func readSettings() *MetricSettings <span class="cov0" title="0">{
        var settings = &amp;MetricSettings{
                Enabled:    false,
                Publishers: make([]MetricPublisher, 0),
        }

        var section, err = setting.Cfg.GetSection("metrics")
        if err != nil </span><span class="cov0" title="0">{
                metricsLogger.Crit("Unable to find metrics config section", "error", err)
                return nil
        }</span>

        <span class="cov0" title="0">settings.Enabled = section.Key("enabled").MustBool(false)
        settings.IntervalSeconds = section.Key("interval_seconds").MustInt64(10)

        if !settings.Enabled </span><span class="cov0" title="0">{
                return settings
        }</span>

        <span class="cov0" title="0">if graphitePublisher, err := CreateGraphitePublisher(); err != nil </span><span class="cov0" title="0">{
                metricsLogger.Error("Failed to init Graphite metric publisher", "error", err)
        }</span><span class="cov0" title="0"> else if graphitePublisher != nil </span><span class="cov0" title="0">{
                metricsLogger.Info("Metrics publisher initialized", "type", "graphite")
                settings.Publishers = append(settings.Publishers, graphitePublisher)
        }</span>

        <span class="cov0" title="0">return settings</span>
}
</pre>
		
		<pre class="file" id="file73" style="display: none">// includes code from
// https://raw.githubusercontent.com/rcrowley/go-metrics/master/sample.go
// Copyright 2012 Richard Crowley. All rights reserved.

package metrics

import (
        "sync"
        "time"
)

// Timers capture the duration and rate of events.
type Timer interface {
        Metric

        Count() int64
        Max() int64
        Mean() float64
        Min() int64
        Percentile(float64) float64
        Percentiles([]float64) []float64
        Rate1() float64
        Rate5() float64
        Rate15() float64
        RateMean() float64
        StdDev() float64
        Sum() int64
        Time(func())
        Update(time.Duration)
        UpdateSince(time.Time)
        Variance() float64
}

// NewCustomTimer constructs a new StandardTimer from a Histogram and a Meter.
func NewCustomTimer(meta *MetricMeta, h Histogram, m Meter) Timer <span class="cov0" title="0">{
        if UseNilMetrics </span><span class="cov0" title="0">{
                return NilTimer{}
        }</span>
        <span class="cov0" title="0">return &amp;StandardTimer{
                MetricMeta: meta,
                histogram:  h,
                meter:      m,
        }</span>
}

// NewTimer constructs a new StandardTimer using an exponentially-decaying
// sample with the same reservoir size and alpha as UNIX load averages.
func NewTimer(meta *MetricMeta) Timer <span class="cov8" title="1">{
        if UseNilMetrics </span><span class="cov8" title="1">{
                return NilTimer{}
        }</span>
        <span class="cov0" title="0">return &amp;StandardTimer{
                MetricMeta: meta,
                histogram:  NewHistogram(meta, NewExpDecaySample(1028, 0.015)),
                meter:      NewMeter(meta),
        }</span>
}

func RegTimer(name string, tagStrings ...string) Timer <span class="cov8" title="1">{
        tr := NewTimer(NewMetricMeta(name, tagStrings))
        MetricStats.Register(tr)
        return tr
}</span>

// NilTimer is a no-op Timer.
type NilTimer struct {
        *MetricMeta
        h Histogram
        m Meter
}

// Count is a no-op.
func (NilTimer) Count() int64 <span class="cov0" title="0">{ return 0 }</span>

// Max is a no-op.
func (NilTimer) Max() int64 <span class="cov0" title="0">{ return 0 }</span>

// Mean is a no-op.
func (NilTimer) Mean() float64 <span class="cov0" title="0">{ return 0.0 }</span>

// Min is a no-op.
func (NilTimer) Min() int64 <span class="cov0" title="0">{ return 0 }</span>

// Percentile is a no-op.
func (NilTimer) Percentile(p float64) float64 <span class="cov0" title="0">{ return 0.0 }</span>

// Percentiles is a no-op.
func (NilTimer) Percentiles(ps []float64) []float64 <span class="cov0" title="0">{
        return make([]float64, len(ps))
}</span>

// Rate1 is a no-op.
func (NilTimer) Rate1() float64 <span class="cov0" title="0">{ return 0.0 }</span>

// Rate5 is a no-op.
func (NilTimer) Rate5() float64 <span class="cov0" title="0">{ return 0.0 }</span>

// Rate15 is a no-op.
func (NilTimer) Rate15() float64 <span class="cov0" title="0">{ return 0.0 }</span>

// RateMean is a no-op.
func (NilTimer) RateMean() float64 <span class="cov0" title="0">{ return 0.0 }</span>

// Snapshot is a no-op.
func (n NilTimer) Snapshot() Metric <span class="cov0" title="0">{ return n }</span>

// StdDev is a no-op.
func (NilTimer) StdDev() float64 <span class="cov0" title="0">{ return 0.0 }</span>

// Sum is a no-op.
func (NilTimer) Sum() int64 <span class="cov0" title="0">{ return 0 }</span>

// Time is a no-op.
func (NilTimer) Time(func()) <span class="cov0" title="0">{}</span>

// Update is a no-op.
func (NilTimer) Update(time.Duration) <span class="cov0" title="0">{}</span>

// UpdateSince is a no-op.
func (NilTimer) UpdateSince(time.Time) <span class="cov0" title="0">{}</span>

// Variance is a no-op.
func (NilTimer) Variance() float64 <span class="cov0" title="0">{ return 0.0 }</span>

// StandardTimer is the standard implementation of a Timer and uses a Histogram
// and Meter.
type StandardTimer struct {
        *MetricMeta
        histogram Histogram
        meter     Meter
        mutex     sync.Mutex
}

// Count returns the number of events recorded.
func (t *StandardTimer) Count() int64 <span class="cov0" title="0">{
        return t.histogram.Count()
}</span>

// Max returns the maximum value in the sample.
func (t *StandardTimer) Max() int64 <span class="cov0" title="0">{
        return t.histogram.Max()
}</span>

// Mean returns the mean of the values in the sample.
func (t *StandardTimer) Mean() float64 <span class="cov0" title="0">{
        return t.histogram.Mean()
}</span>

// Min returns the minimum value in the sample.
func (t *StandardTimer) Min() int64 <span class="cov0" title="0">{
        return t.histogram.Min()
}</span>

// Percentile returns an arbitrary percentile of the values in the sample.
func (t *StandardTimer) Percentile(p float64) float64 <span class="cov0" title="0">{
        return t.histogram.Percentile(p)
}</span>

// Percentiles returns a slice of arbitrary percentiles of the values in the
// sample.
func (t *StandardTimer) Percentiles(ps []float64) []float64 <span class="cov0" title="0">{
        return t.histogram.Percentiles(ps)
}</span>

// Rate1 returns the one-minute moving average rate of events per second.
func (t *StandardTimer) Rate1() float64 <span class="cov0" title="0">{
        return t.meter.Rate1()
}</span>

// Rate5 returns the five-minute moving average rate of events per second.
func (t *StandardTimer) Rate5() float64 <span class="cov0" title="0">{
        return t.meter.Rate5()
}</span>

// Rate15 returns the fifteen-minute moving average rate of events per second.
func (t *StandardTimer) Rate15() float64 <span class="cov0" title="0">{
        return t.meter.Rate15()
}</span>

// RateMean returns the meter's mean rate of events per second.
func (t *StandardTimer) RateMean() float64 <span class="cov0" title="0">{
        return t.meter.RateMean()
}</span>

// Snapshot returns a read-only copy of the timer.
func (t *StandardTimer) Snapshot() Metric <span class="cov0" title="0">{
        t.mutex.Lock()
        defer t.mutex.Unlock()
        return &amp;TimerSnapshot{
                MetricMeta: t.MetricMeta,
                histogram:  t.histogram.Snapshot().(*HistogramSnapshot),
                meter:      t.meter.Snapshot().(*MeterSnapshot),
        }
}</span>

// StdDev returns the standard deviation of the values in the sample.
func (t *StandardTimer) StdDev() float64 <span class="cov0" title="0">{
        return t.histogram.StdDev()
}</span>

// Sum returns the sum in the sample.
func (t *StandardTimer) Sum() int64 <span class="cov0" title="0">{
        return t.histogram.Sum()
}</span>

// Record the duration of the execution of the given function.
func (t *StandardTimer) Time(f func()) <span class="cov0" title="0">{
        ts := time.Now()
        f()
        t.Update(time.Since(ts))
}</span>

// Record the duration of an event.
func (t *StandardTimer) Update(d time.Duration) <span class="cov0" title="0">{
        t.mutex.Lock()
        defer t.mutex.Unlock()
        t.histogram.Update(int64(d))
        t.meter.Mark(1)
}</span>

// Record the duration of an event that started at a time and ends now.
func (t *StandardTimer) UpdateSince(ts time.Time) <span class="cov0" title="0">{
        t.mutex.Lock()
        defer t.mutex.Unlock()
        sinceMs := time.Since(ts) / time.Millisecond
        t.histogram.Update(int64(sinceMs))
        t.meter.Mark(1)
}</span>

// Variance returns the variance of the values in the sample.
func (t *StandardTimer) Variance() float64 <span class="cov0" title="0">{
        return t.histogram.Variance()
}</span>

// TimerSnapshot is a read-only copy of another Timer.
type TimerSnapshot struct {
        *MetricMeta
        histogram *HistogramSnapshot
        meter     *MeterSnapshot
}

// Count returns the number of events recorded at the time the snapshot was
// taken.
func (t *TimerSnapshot) Count() int64 <span class="cov0" title="0">{ return t.histogram.Count() }</span>

// Max returns the maximum value at the time the snapshot was taken.
func (t *TimerSnapshot) Max() int64 <span class="cov0" title="0">{ return t.histogram.Max() }</span>

// Mean returns the mean value at the time the snapshot was taken.
func (t *TimerSnapshot) Mean() float64 <span class="cov0" title="0">{ return t.histogram.Mean() }</span>

// Min returns the minimum value at the time the snapshot was taken.
func (t *TimerSnapshot) Min() int64 <span class="cov0" title="0">{ return t.histogram.Min() }</span>

// Percentile returns an arbitrary percentile of sampled values at the time the
// snapshot was taken.
func (t *TimerSnapshot) Percentile(p float64) float64 <span class="cov0" title="0">{
        return t.histogram.Percentile(p)
}</span>

// Percentiles returns a slice of arbitrary percentiles of sampled values at
// the time the snapshot was taken.
func (t *TimerSnapshot) Percentiles(ps []float64) []float64 <span class="cov0" title="0">{
        return t.histogram.Percentiles(ps)
}</span>

// Rate1 returns the one-minute moving average rate of events per second at the
// time the snapshot was taken.
func (t *TimerSnapshot) Rate1() float64 <span class="cov0" title="0">{ return t.meter.Rate1() }</span>

// Rate5 returns the five-minute moving average rate of events per second at
// the time the snapshot was taken.
func (t *TimerSnapshot) Rate5() float64 <span class="cov0" title="0">{ return t.meter.Rate5() }</span>

// Rate15 returns the fifteen-minute moving average rate of events per second
// at the time the snapshot was taken.
func (t *TimerSnapshot) Rate15() float64 <span class="cov0" title="0">{ return t.meter.Rate15() }</span>

// RateMean returns the meter's mean rate of events per second at the time the
// snapshot was taken.
func (t *TimerSnapshot) RateMean() float64 <span class="cov0" title="0">{ return t.meter.RateMean() }</span>

// Snapshot returns the snapshot.
func (t *TimerSnapshot) Snapshot() Metric <span class="cov0" title="0">{ return t }</span>

// StdDev returns the standard deviation of the values at the time the snapshot
// was taken.
func (t *TimerSnapshot) StdDev() float64 <span class="cov0" title="0">{ return t.histogram.StdDev() }</span>

// Sum returns the sum at the time the snapshot was taken.
func (t *TimerSnapshot) Sum() int64 <span class="cov0" title="0">{ return t.histogram.Sum() }</span>

// Time panics.
func (*TimerSnapshot) Time(func()) <span class="cov0" title="0">{
        panic("Time called on a TimerSnapshot")</span>
}

// Update panics.
func (*TimerSnapshot) Update(time.Duration) <span class="cov0" title="0">{
        panic("Update called on a TimerSnapshot")</span>
}

// UpdateSince panics.
func (*TimerSnapshot) UpdateSince(time.Time) <span class="cov0" title="0">{
        panic("UpdateSince called on a TimerSnapshot")</span>
}

// Variance returns the variance of the values at the time the snapshot was
// taken.
func (t *TimerSnapshot) Variance() float64 <span class="cov0" title="0">{ return t.histogram.Variance() }</span>
</pre>
		
		<pre class="file" id="file74" style="display: none">package middleware

import (
        "net/url"
        "strings"

        "gopkg.in/macaron.v1"

        m "github.com/grafana/grafana/pkg/models"
        "github.com/grafana/grafana/pkg/setting"
)

type AuthOptions struct {
        ReqGrafanaAdmin bool
        ReqSignedIn     bool
}

func getRequestUserId(c *Context) int64 <span class="cov8" title="1">{
        userId := c.Session.Get(SESS_KEY_USERID)

        if userId != nil </span><span class="cov8" title="1">{
                return userId.(int64)
        }</span>

        <span class="cov8" title="1">return 0</span>
}

func getApiKey(c *Context) string <span class="cov8" title="1">{
        header := c.Req.Header.Get("Authorization")
        parts := strings.SplitN(header, " ", 2)
        if len(parts) == 2 &amp;&amp; parts[0] == "Bearer" </span><span class="cov8" title="1">{
                key := parts[1]
                return key
        }</span>

        <span class="cov8" title="1">return ""</span>
}

func accessForbidden(c *Context) <span class="cov0" title="0">{
        if c.IsApiRequest() </span><span class="cov0" title="0">{
                c.JsonApiErr(403, "Permission denied", nil)
                return
        }</span>

        <span class="cov0" title="0">c.SetCookie("redirect_to", url.QueryEscape(setting.AppSubUrl+c.Req.RequestURI), 0, setting.AppSubUrl+"/")
        c.Redirect(setting.AppSubUrl + "/login")</span>
}

func notAuthorized(c *Context) <span class="cov8" title="1">{
        if c.IsApiRequest() </span><span class="cov8" title="1">{
                c.JsonApiErr(401, "Unauthorized", nil)
                return
        }</span>

        <span class="cov8" title="1">c.SetCookie("redirect_to", url.QueryEscape(setting.AppSubUrl+c.Req.RequestURI), 0, setting.AppSubUrl+"/")
        c.Redirect(setting.AppSubUrl + "/login")</span>
}

func RoleAuth(roles ...m.RoleType) macaron.Handler <span class="cov0" title="0">{
        return func(c *Context) </span><span class="cov0" title="0">{
                ok := false
                for _, role := range roles </span><span class="cov0" title="0">{
                        if role == c.OrgRole </span><span class="cov0" title="0">{
                                ok = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !ok </span><span class="cov0" title="0">{
                        accessForbidden(c)
                }</span>
        }
}

func Auth(options *AuthOptions) macaron.Handler <span class="cov8" title="1">{
        return func(c *Context) </span><span class="cov8" title="1">{
                if !c.IsSignedIn &amp;&amp; options.ReqSignedIn &amp;&amp; !c.AllowAnonymous </span><span class="cov8" title="1">{
                        notAuthorized(c)
                        return
                }</span>

                <span class="cov0" title="0">if !c.IsGrafanaAdmin &amp;&amp; options.ReqGrafanaAdmin </span><span class="cov0" title="0">{
                        accessForbidden(c)
                        return
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file75" style="display: none">package middleware

import (
        "errors"
        "fmt"
        "strings"
        "time"

        "github.com/grafana/grafana/pkg/bus"
        "github.com/grafana/grafana/pkg/log"
        "github.com/grafana/grafana/pkg/login"
        m "github.com/grafana/grafana/pkg/models"
        "github.com/grafana/grafana/pkg/setting"
)

func initContextWithAuthProxy(ctx *Context) bool <span class="cov8" title="1">{
        if !setting.AuthProxyEnabled </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">proxyHeaderValue := ctx.Req.Header.Get(setting.AuthProxyHeaderName)
        if len(proxyHeaderValue) == 0 </span><span class="cov8" title="1">{
                return false
        }</span>

        // if auth proxy ip(s) defined, check if request comes from one of those
        <span class="cov8" title="1">if err := checkAuthenticationProxy(ctx, proxyHeaderValue); err != nil </span><span class="cov8" title="1">{
                ctx.Handle(407, "Proxy authentication required", err)
                return true
        }</span>

        <span class="cov8" title="1">query := getSignedInUserQueryForProxyAuth(proxyHeaderValue)
        if err := bus.Dispatch(query); err != nil </span><span class="cov8" title="1">{
                if err != m.ErrUserNotFound </span><span class="cov0" title="0">{
                        ctx.Handle(500, "Failed to find user specified in auth proxy header", err)
                        return true
                }</span>

                <span class="cov8" title="1">if setting.AuthProxyAutoSignUp </span><span class="cov8" title="1">{
                        cmd := getCreateUserCommandForProxyAuth(proxyHeaderValue)
                        if setting.LdapEnabled </span><span class="cov8" title="1">{
                                cmd.SkipOrgSetup = true
                        }</span>

                        <span class="cov8" title="1">if err := bus.Dispatch(cmd); err != nil </span><span class="cov0" title="0">{
                                ctx.Handle(500, "Failed to create user specified in auth proxy header", err)
                                return true
                        }</span>
                        <span class="cov8" title="1">query = &amp;m.GetSignedInUserQuery{UserId: cmd.Result.Id}
                        if err := bus.Dispatch(query); err != nil </span><span class="cov0" title="0">{
                                ctx.Handle(500, "Failed find user after creation", err)
                                return true
                        }</span>
                }<span class="cov0" title="0"> else {
                        return false
                }</span>
        }

        // initialize session
        <span class="cov8" title="1">if err := ctx.Session.Start(ctx); err != nil </span><span class="cov0" title="0">{
                log.Error(3, "Failed to start session", err)
                return false
        }</span>

        // Make sure that we cannot share a session between different users!
        <span class="cov8" title="1">if getRequestUserId(ctx) &gt; 0 &amp;&amp; getRequestUserId(ctx) != query.Result.UserId </span><span class="cov8" title="1">{
                // remove session
                if err := ctx.Session.Destory(ctx); err != nil </span><span class="cov0" title="0">{
                        log.Error(3, "Failed to destory session, err")
                }</span>

                // initialize a new session
                <span class="cov8" title="1">if err := ctx.Session.Start(ctx); err != nil </span><span class="cov0" title="0">{
                        log.Error(3, "Failed to start session", err)
                }</span>
        }

        // When ldap is enabled, sync userinfo and org roles
        <span class="cov8" title="1">if err := syncGrafanaUserWithLdapUser(ctx, query); err != nil </span><span class="cov0" title="0">{
                if err == login.ErrInvalidCredentials </span><span class="cov0" title="0">{
                        ctx.Handle(500, "Unable to authenticate user", err)
                        return false
                }</span>

                <span class="cov0" title="0">ctx.Handle(500, "Failed to sync user", err)
                return false</span>
        }

        <span class="cov8" title="1">ctx.SignedInUser = query.Result
        ctx.IsSignedIn = true
        ctx.Session.Set(SESS_KEY_USERID, ctx.UserId)

        return true</span>
}

var syncGrafanaUserWithLdapUser = func(ctx *Context, query *m.GetSignedInUserQuery) error <span class="cov8" title="1">{
        if setting.LdapEnabled </span><span class="cov8" title="1">{
                expireEpoch := time.Now().Add(time.Duration(-setting.AuthProxyLdapSyncTtl) * time.Minute).Unix()

                var lastLdapSync int64
                if lastLdapSyncInSession := ctx.Session.Get(SESS_KEY_LASTLDAPSYNC); lastLdapSyncInSession != nil </span><span class="cov8" title="1">{
                        lastLdapSync = lastLdapSyncInSession.(int64)
                }</span>

                <span class="cov8" title="1">if lastLdapSync &lt; expireEpoch </span><span class="cov8" title="1">{
                        ldapCfg := login.LdapCfg

                        for _, server := range ldapCfg.Servers </span><span class="cov8" title="1">{
                                auther := login.NewLdapAuthenticator(server)
                                if err := auther.SyncSignedInUser(query.Result); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }

                        <span class="cov8" title="1">ctx.Session.Set(SESS_KEY_LASTLDAPSYNC, time.Now().Unix())</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

func checkAuthenticationProxy(ctx *Context, proxyHeaderValue string) error <span class="cov8" title="1">{
        if len(strings.TrimSpace(setting.AuthProxyWhitelist)) &gt; 0 </span><span class="cov8" title="1">{
                proxies := strings.Split(setting.AuthProxyWhitelist, ",")
                remoteAddrSplit := strings.Split(ctx.Req.RemoteAddr, ":")
                sourceIP := remoteAddrSplit[0]

                found := false
                for _, proxyIP := range proxies </span><span class="cov8" title="1">{
                        if sourceIP == strings.TrimSpace(proxyIP) </span><span class="cov8" title="1">{
                                found = true
                                break</span>
                        }
                }

                <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                        msg := fmt.Sprintf("Request for user (%s) is not from the authentication proxy", proxyHeaderValue)
                        err := errors.New(msg)
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func getSignedInUserQueryForProxyAuth(headerVal string) *m.GetSignedInUserQuery <span class="cov8" title="1">{
        query := m.GetSignedInUserQuery{}
        if setting.AuthProxyHeaderProperty == "username" </span><span class="cov8" title="1">{
                query.Login = headerVal
        }</span><span class="cov0" title="0"> else if setting.AuthProxyHeaderProperty == "email" </span><span class="cov0" title="0">{
                query.Email = headerVal
        }</span><span class="cov0" title="0"> else {
                panic("Auth proxy header property invalid")</span>
        }
        <span class="cov8" title="1">return &amp;query</span>
}

func getCreateUserCommandForProxyAuth(headerVal string) *m.CreateUserCommand <span class="cov8" title="1">{
        cmd := m.CreateUserCommand{}
        if setting.AuthProxyHeaderProperty == "username" </span><span class="cov8" title="1">{
                cmd.Login = headerVal
                cmd.Email = headerVal
        }</span><span class="cov0" title="0"> else if setting.AuthProxyHeaderProperty == "email" </span><span class="cov0" title="0">{
                cmd.Email = headerVal
                cmd.Login = headerVal
        }</span><span class="cov0" title="0"> else {
                panic("Auth proxy header property invalid")</span>
        }
        <span class="cov8" title="1">return &amp;cmd</span>
}
</pre>
		
		<pre class="file" id="file76" style="display: none">// Copyright 2013 Martini Authors
// Copyright 2014 Unknwon
//
// Licensed under the Apache License, Version 2.0 (the "License"): you may
// not use this file except in compliance with the License. You may obtain
// a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations
// under the License.

package middleware

import (
        "net/http"
        "time"

        "github.com/grafana/grafana/pkg/metrics"
        "github.com/grafana/grafana/pkg/setting"
        "gopkg.in/macaron.v1"
)

func Logger() macaron.Handler <span class="cov0" title="0">{
        return func(res http.ResponseWriter, req *http.Request, c *macaron.Context) </span><span class="cov0" title="0">{
                start := time.Now()
                c.Data["perfmon.start"] = start

                rw := res.(macaron.ResponseWriter)
                c.Next()

                timeTakenMs := time.Since(start) / time.Millisecond

                if timer, ok := c.Data["perfmon.timer"]; ok </span><span class="cov0" title="0">{
                        timerTyped := timer.(metrics.Timer)
                        timerTyped.Update(timeTakenMs)
                }</span>

                <span class="cov0" title="0">status := rw.Status()
                if status == 200 || status == 304 </span><span class="cov0" title="0">{
                        if !setting.RouterLogging </span><span class="cov0" title="0">{
                                return
                        }</span>
                }

                <span class="cov0" title="0">if ctx, ok := c.Data["ctx"]; ok </span><span class="cov0" title="0">{
                        ctxTyped := ctx.(*Context)
                        if status == 500 </span><span class="cov0" title="0">{
                                ctxTyped.Logger.Error("Request Completed", "method", req.Method, "path", req.URL.Path, "status", status, "remote_addr", c.RemoteAddr(), "time_ms", timeTakenMs, "size", rw.Size())
                        }</span><span class="cov0" title="0"> else {
                                ctxTyped.Logger.Info("Request Completed", "method", req.Method, "path", req.URL.Path, "status", status, "remote_addr", c.RemoteAddr(), "time_ms", timeTakenMs, "size", rw.Size())
                        }</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file77" style="display: none">package middleware

import (
        "strconv"
        "strings"

        "gopkg.in/macaron.v1"

        "github.com/grafana/grafana/pkg/bus"
        "github.com/grafana/grafana/pkg/components/apikeygen"
        "github.com/grafana/grafana/pkg/log"
        l "github.com/grafana/grafana/pkg/login"
        "github.com/grafana/grafana/pkg/metrics"
        m "github.com/grafana/grafana/pkg/models"
        "github.com/grafana/grafana/pkg/setting"
        "github.com/grafana/grafana/pkg/util"
)

type Context struct {
        *macaron.Context
        *m.SignedInUser

        Session SessionStore

        IsSignedIn     bool
        IsRenderCall   bool
        AllowAnonymous bool
        Logger         log.Logger
}

func GetContextHandler() macaron.Handler <span class="cov8" title="1">{
        return func(c *macaron.Context) </span><span class="cov8" title="1">{
                ctx := &amp;Context{
                        Context:        c,
                        SignedInUser:   &amp;m.SignedInUser{},
                        Session:        GetSession(),
                        IsSignedIn:     false,
                        AllowAnonymous: false,
                        Logger:         log.New("context"),
                }

                // the order in which these are tested are important
                // look for api key in Authorization header first
                // then init session and look for userId in session
                // then look for api key in session (special case for render calls via api)
                // then test if anonymous access is enabled
                if initContextWithRenderAuth(ctx) ||
                        initContextWithApiKey(ctx) ||
                        initContextWithBasicAuth(ctx) ||
                        initContextWithAuthProxy(ctx) ||
                        initContextWithUserSessionCookie(ctx) ||
                        initContextWithAnonymousUser(ctx) </span><span class="cov8" title="1">{
                }</span>

                <span class="cov8" title="1">ctx.Logger = log.New("context", "userId", ctx.UserId, "orgId", ctx.OrgId, "uname", ctx.Login)
                ctx.Data["ctx"] = ctx

                c.Map(ctx)</span>
        }
}

func initContextWithAnonymousUser(ctx *Context) bool <span class="cov8" title="1">{
        if !setting.AnonymousEnabled </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">orgQuery := m.GetOrgByNameQuery{Name: setting.AnonymousOrgName}
        if err := bus.Dispatch(&amp;orgQuery); err != nil </span><span class="cov8" title="1">{
                log.Error(3, "Anonymous access organization error: '%s': %s", setting.AnonymousOrgName, err)
                return false
        }</span><span class="cov8" title="1"> else {
                ctx.IsSignedIn = false
                ctx.AllowAnonymous = true
                ctx.SignedInUser = &amp;m.SignedInUser{}
                ctx.OrgRole = m.RoleType(setting.AnonymousOrgRole)
                ctx.OrgId = orgQuery.Result.Id
                ctx.OrgName = orgQuery.Result.Name
                return true
        }</span>
}

func initContextWithUserSessionCookie(ctx *Context) bool <span class="cov8" title="1">{
        // initialize session
        if err := ctx.Session.Start(ctx); err != nil </span><span class="cov0" title="0">{
                ctx.Logger.Error("Failed to start session", "error", err)
                return false
        }</span>

        <span class="cov8" title="1">var userId int64
        if userId = getRequestUserId(ctx); userId == 0 </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">query := m.GetSignedInUserQuery{UserId: userId}
        if err := bus.Dispatch(&amp;query); err != nil </span><span class="cov0" title="0">{
                ctx.Logger.Error("Failed to get user with id", "userId", userId)
                return false
        }</span><span class="cov8" title="1"> else {
                ctx.SignedInUser = query.Result
                ctx.IsSignedIn = true
                return true
        }</span>
}

func initContextWithApiKey(ctx *Context) bool <span class="cov8" title="1">{
        var keyString string
        if keyString = getApiKey(ctx); keyString == "" </span><span class="cov8" title="1">{
                return false
        }</span>

        // base64 decode key
        <span class="cov8" title="1">decoded, err := apikeygen.Decode(keyString)
        if err != nil </span><span class="cov8" title="1">{
                ctx.JsonApiErr(401, "Invalid API key", err)
                return true
        }</span>
        // fetch key
        <span class="cov8" title="1">keyQuery := m.GetApiKeyByNameQuery{KeyName: decoded.Name, OrgId: decoded.OrgId}
        if err := bus.Dispatch(&amp;keyQuery); err != nil </span><span class="cov0" title="0">{
                ctx.JsonApiErr(401, "Invalid API key", err)
                return true
        }</span><span class="cov8" title="1"> else {
                apikey := keyQuery.Result

                // validate api key
                if !apikeygen.IsValid(decoded, apikey.Key) </span><span class="cov8" title="1">{
                        ctx.JsonApiErr(401, "Invalid API key", err)
                        return true
                }</span>

                <span class="cov8" title="1">ctx.IsSignedIn = true
                ctx.SignedInUser = &amp;m.SignedInUser{}
                ctx.OrgRole = apikey.Role
                ctx.ApiKeyId = apikey.Id
                ctx.OrgId = apikey.OrgId
                return true</span>
        }
}

func initContextWithBasicAuth(ctx *Context) bool <span class="cov8" title="1">{

        if !setting.BasicAuthEnabled </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">header := ctx.Req.Header.Get("Authorization")
        if header == "" </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">username, password, err := util.DecodeBasicAuthHeader(header)
        if err != nil </span><span class="cov0" title="0">{
                ctx.JsonApiErr(401, "Invalid Basic Auth Header", err)
                return true
        }</span>

        <span class="cov8" title="1">loginQuery := m.GetUserByLoginQuery{LoginOrEmail: username}
        if err := bus.Dispatch(&amp;loginQuery); err != nil </span><span class="cov0" title="0">{
                ctx.JsonApiErr(401, "Basic auth failed", err)
                return true
        }</span>

        <span class="cov8" title="1">user := loginQuery.Result

        loginUserQuery := l.LoginUserQuery{Username: username, Password: password, User: user}
        if err := bus.Dispatch(&amp;loginUserQuery); err != nil </span><span class="cov0" title="0">{
                ctx.JsonApiErr(401, "Invalid username or password", err)
                return true
        }</span>

        <span class="cov8" title="1">query := m.GetSignedInUserQuery{UserId: user.Id}
        if err := bus.Dispatch(&amp;query); err != nil </span><span class="cov0" title="0">{
                ctx.JsonApiErr(401, "Authentication error", err)
                return true
        }</span><span class="cov8" title="1"> else {
                ctx.SignedInUser = query.Result
                ctx.IsSignedIn = true
                return true
        }</span>
}

// Handle handles and logs error by given status.
func (ctx *Context) Handle(status int, title string, err error) <span class="cov8" title="1">{
        if err != nil </span><span class="cov8" title="1">{
                ctx.Logger.Error(title, "error", err)
                if setting.Env != setting.PROD </span><span class="cov8" title="1">{
                        ctx.Data["ErrorMsg"] = err
                }</span>
        }

        <span class="cov8" title="1">ctx.Data["Title"] = title
        ctx.Data["AppSubUrl"] = setting.AppSubUrl
        ctx.HTML(status, strconv.Itoa(status))</span>
}

func (ctx *Context) JsonOK(message string) <span class="cov0" title="0">{
        resp := make(map[string]interface{})
        resp["message"] = message
        ctx.JSON(200, resp)
}</span>

func (ctx *Context) IsApiRequest() bool <span class="cov8" title="1">{
        return strings.HasPrefix(ctx.Req.URL.Path, "/api")
}</span>

func (ctx *Context) JsonApiErr(status int, message string, err error) <span class="cov8" title="1">{
        resp := make(map[string]interface{})

        if err != nil </span><span class="cov8" title="1">{
                ctx.Logger.Error(message, "error", err)
                if setting.Env != setting.PROD </span><span class="cov8" title="1">{
                        resp["error"] = err.Error()
                }</span>
        }

        <span class="cov8" title="1">switch status </span>{
        case 404:<span class="cov0" title="0">
                resp["message"] = "Not Found"</span>
        case 500:<span class="cov0" title="0">
                resp["message"] = "Internal Server Error"</span>
        }

        <span class="cov8" title="1">if message != "" </span><span class="cov8" title="1">{
                resp["message"] = message
        }</span>

        <span class="cov8" title="1">ctx.JSON(status, resp)</span>
}

func (ctx *Context) HasUserRole(role m.RoleType) bool <span class="cov0" title="0">{
        return ctx.OrgRole.Includes(role)
}</span>

func (ctx *Context) HasHelpFlag(flag m.HelpFlags1) bool <span class="cov0" title="0">{
        return ctx.HelpFlags1.HasFlag(flag)
}</span>

func (ctx *Context) TimeRequest(timer metrics.Timer) <span class="cov0" title="0">{
        ctx.Data["perfmon.timer"] = timer
}</span>
</pre>
		
		<pre class="file" id="file78" style="display: none">package middleware

import (
        "net/http"
        "strconv"

        "github.com/grafana/grafana/pkg/bus"
        "github.com/grafana/grafana/pkg/models"

        "gopkg.in/macaron.v1"
)

func OrgRedirect() macaron.Handler <span class="cov8" title="1">{
        return func(res http.ResponseWriter, req *http.Request, c *macaron.Context) </span><span class="cov8" title="1">{
                orgIdValue := req.URL.Query().Get("orgId")
                orgId, err := strconv.ParseInt(orgIdValue, 10, 32)

                if err != nil || orgId == 0 </span><span class="cov8" title="1">{
                        return
                }</span>

                <span class="cov8" title="1">ctx, ok := c.Data["ctx"].(*Context)
                if !ok || !ctx.IsSignedIn </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov8" title="1">if orgId == ctx.OrgId </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov8" title="1">cmd := models.SetUsingOrgCommand{UserId: ctx.UserId, OrgId: orgId}
                if err := bus.Dispatch(&amp;cmd); err != nil </span><span class="cov8" title="1">{
                        if ctx.IsApiRequest() </span><span class="cov0" title="0">{
                                ctx.JsonApiErr(404, "Not found", nil)
                        }</span><span class="cov8" title="1"> else {
                                ctx.Error(404, "Not found")
                        }</span>

                        <span class="cov8" title="1">return</span>
                }

                <span class="cov8" title="1">c.Redirect(c.Req.URL.String(), 302)</span>
        }
}
</pre>
		
		<pre class="file" id="file79" style="display: none">package middleware

import (
        "net/http"

        "gopkg.in/macaron.v1"
)

func MeasureRequestTime() macaron.Handler <span class="cov0" title="0">{
        return func(res http.ResponseWriter, req *http.Request, c *Context) </span><span class="cov0" title="0">{
        }</span>
}
</pre>
		
		<pre class="file" id="file80" style="display: none">package middleware

import (
        "fmt"

        "github.com/grafana/grafana/pkg/bus"
        m "github.com/grafana/grafana/pkg/models"
        "github.com/grafana/grafana/pkg/setting"
        "gopkg.in/macaron.v1"
)

func Quota(target string) macaron.Handler <span class="cov8" title="1">{
        return func(c *Context) </span><span class="cov8" title="1">{
                limitReached, err := QuotaReached(c, target)
                if err != nil </span><span class="cov0" title="0">{
                        c.JsonApiErr(500, "failed to get quota", err)
                        return
                }</span>
                <span class="cov8" title="1">if limitReached </span><span class="cov8" title="1">{
                        c.JsonApiErr(403, fmt.Sprintf("%s Quota reached", target), nil)
                        return
                }</span>
        }
}

func QuotaReached(c *Context, target string) (bool, error) <span class="cov8" title="1">{
        if !setting.Quota.Enabled </span><span class="cov8" title="1">{
                return false, nil
        }</span>

        // get the list of scopes that this target is valid for. Org, User, Global
        <span class="cov8" title="1">scopes, err := m.GetQuotaScopes(target)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov8" title="1">for _, scope := range scopes </span><span class="cov8" title="1">{
                c.Logger.Debug("Checking quota", "target", target, "scope", scope)

                switch scope.Name </span>{
                case "global":<span class="cov8" title="1">
                        if scope.DefaultLimit &lt; 0 </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">if scope.DefaultLimit == 0 </span><span class="cov0" title="0">{
                                return true, nil
                        }</span>
                        <span class="cov8" title="1">if target == "session" </span><span class="cov8" title="1">{
                                usedSessions := getSessionCount()
                                if int64(usedSessions) &gt; scope.DefaultLimit </span><span class="cov8" title="1">{
                                        c.Logger.Debug("Sessions limit reached", "active", usedSessions, "limit", scope.DefaultLimit)
                                        return true, nil
                                }</span>
                                <span class="cov8" title="1">continue</span>
                        }
                        <span class="cov8" title="1">query := m.GetGlobalQuotaByTargetQuery{Target: scope.Target}
                        if err := bus.Dispatch(&amp;query); err != nil </span><span class="cov0" title="0">{
                                return true, err
                        }</span>
                        <span class="cov8" title="1">if query.Result.Used &gt;= scope.DefaultLimit </span><span class="cov8" title="1">{
                                return true, nil
                        }</span>
                case "org":<span class="cov8" title="1">
                        if !c.IsSignedIn </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">query := m.GetOrgQuotaByTargetQuery{OrgId: c.OrgId, Target: scope.Target, Default: scope.DefaultLimit}
                        if err := bus.Dispatch(&amp;query); err != nil </span><span class="cov0" title="0">{
                                return true, err
                        }</span>
                        <span class="cov8" title="1">if query.Result.Limit &lt; 0 </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">if query.Result.Limit == 0 </span><span class="cov0" title="0">{
                                return true, nil
                        }</span>

                        <span class="cov8" title="1">if query.Result.Used &gt;= query.Result.Limit </span><span class="cov8" title="1">{
                                return true, nil
                        }</span>
                case "user":<span class="cov8" title="1">
                        if !c.IsSignedIn || c.UserId == 0 </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">query := m.GetUserQuotaByTargetQuery{UserId: c.UserId, Target: scope.Target, Default: scope.DefaultLimit}
                        if err := bus.Dispatch(&amp;query); err != nil </span><span class="cov0" title="0">{
                                return true, err
                        }</span>
                        <span class="cov8" title="1">if query.Result.Limit &lt; 0 </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">if query.Result.Limit == 0 </span><span class="cov0" title="0">{
                                return true, nil
                        }</span>

                        <span class="cov8" title="1">if query.Result.Used &gt;= query.Result.Limit </span><span class="cov8" title="1">{
                                return true, nil
                        }</span>
                }
        }

        <span class="cov8" title="1">return false, nil</span>
}
</pre>
		
		<pre class="file" id="file81" style="display: none">// Copyright 2013 Martini Authors
// Copyright 2014 The Macaron Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"): you may
// not use this file except in compliance with the License. You may obtain
// a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations
// under the License.

package middleware

import (
        "bytes"
        "fmt"
        "io/ioutil"
        "runtime"

        "gopkg.in/macaron.v1"

        "github.com/grafana/grafana/pkg/log"
        "github.com/grafana/grafana/pkg/setting"
)

var (
        dunno     = []byte("???")
        centerDot = []byte("·")
        dot       = []byte(".")
        slash     = []byte("/")
)

// stack returns a nicely formated stack frame, skipping skip frames
func stack(skip int) []byte <span class="cov0" title="0">{
        buf := new(bytes.Buffer) // the returned data
        // As we loop, we open files and read them. These variables record the currently
        // loaded file.
        var lines [][]byte
        var lastFile string
        for i := skip; ; i++ </span><span class="cov0" title="0">{ // Skip the expected number of frames
                pc, file, line, ok := runtime.Caller(i)
                if !ok </span><span class="cov0" title="0">{
                        break</span>
                }
                // Print this much at least.  If we can't find the source, it won't show.
                <span class="cov0" title="0">fmt.Fprintf(buf, "%s:%d (0x%x)\n", file, line, pc)
                if file != lastFile </span><span class="cov0" title="0">{
                        data, err := ioutil.ReadFile(file)
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">lines = bytes.Split(data, []byte{'\n'})
                        lastFile = file</span>
                }
                <span class="cov0" title="0">fmt.Fprintf(buf, "\t%s: %s\n", function(pc), source(lines, line))</span>
        }
        <span class="cov0" title="0">return buf.Bytes()</span>
}

// source returns a space-trimmed slice of the n'th line.
func source(lines [][]byte, n int) []byte <span class="cov0" title="0">{
        n-- // in stack trace, lines are 1-indexed but our array is 0-indexed
        if n &lt; 0 || n &gt;= len(lines) </span><span class="cov0" title="0">{
                return dunno
        }</span>
        <span class="cov0" title="0">return bytes.TrimSpace(lines[n])</span>
}

// function returns, if possible, the name of the function containing the PC.
func function(pc uintptr) []byte <span class="cov0" title="0">{
        fn := runtime.FuncForPC(pc)
        if fn == nil </span><span class="cov0" title="0">{
                return dunno
        }</span>
        <span class="cov0" title="0">name := []byte(fn.Name())
        // The name includes the path name to the package, which is unnecessary
        // since the file name is already included.  Plus, it has center dots.
        // That is, we see
        //        runtime/debug.*T·ptrmethod
        // and want
        //        *T.ptrmethod
        // Also the package path might contains dot (e.g. code.google.com/...),
        // so first eliminate the path prefix
        if lastslash := bytes.LastIndex(name, slash); lastslash &gt;= 0 </span><span class="cov0" title="0">{
                name = name[lastslash+1:]
        }</span>
        <span class="cov0" title="0">if period := bytes.Index(name, dot); period &gt;= 0 </span><span class="cov0" title="0">{
                name = name[period+1:]
        }</span>
        <span class="cov0" title="0">name = bytes.Replace(name, centerDot, dot, -1)
        return name</span>
}

// Recovery returns a middleware that recovers from any panics and writes a 500 if there was one.
// While Martini is in development mode, Recovery will also output the panic as HTML.
func Recovery() macaron.Handler <span class="cov0" title="0">{
        return func(c *macaron.Context) </span><span class="cov0" title="0">{
                defer func() </span><span class="cov0" title="0">{
                        if err := recover(); err != nil </span><span class="cov0" title="0">{
                                stack := stack(3)

                                panicLogger := log.Root
                                // try to get request logger
                                if ctx, ok := c.Data["ctx"]; ok </span><span class="cov0" title="0">{
                                        ctxTyped := ctx.(*Context)
                                        panicLogger = ctxTyped.Logger
                                }</span>

                                <span class="cov0" title="0">panicLogger.Error("Request error", "error", err, "stack", string(stack))

                                c.Data["Title"] = "Server Error"
                                c.Data["AppSubUrl"] = setting.AppSubUrl

                                if theErr, ok := err.(error); ok </span><span class="cov0" title="0">{
                                        c.Data["Title"] = theErr.Error()
                                }</span>

                                <span class="cov0" title="0">if setting.Env == setting.DEV </span><span class="cov0" title="0">{
                                        c.Data["ErrorMsg"] = string(stack)
                                }</span>

                                <span class="cov0" title="0">c.HTML(500, "500")</span>

                                // // Lookup the current responsewriter
                                // val := c.GetVal(inject.InterfaceOf((*http.ResponseWriter)(nil)))
                                // res := val.Interface().(http.ResponseWriter)
                                //
                                // // respond with panic message while in development mode
                                // var body []byte
                                // if setting.Env == setting.DEV {
                                //         res.Header().Set("Content-Type", "text/html")
                                //         body = []byte(fmt.Sprintf(panicHtml, err, err, stack))
                                // }
                                //
                                // res.WriteHeader(http.StatusInternalServerError)
                                // if nil != body {
                                //         res.Write(body)
                                // }
                        }
                }()

                <span class="cov0" title="0">c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file82" style="display: none">package middleware

import (
        "sync"

        m "github.com/grafana/grafana/pkg/models"
        "github.com/grafana/grafana/pkg/util"
)

var renderKeysLock sync.Mutex
var renderKeys map[string]*m.SignedInUser = make(map[string]*m.SignedInUser)

func initContextWithRenderAuth(ctx *Context) bool <span class="cov8" title="1">{
        key := ctx.GetCookie("renderKey")
        if key == "" </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov0" title="0">renderKeysLock.Lock()
        defer renderKeysLock.Unlock()

        if renderUser, exists := renderKeys[key]; !exists </span><span class="cov0" title="0">{
                ctx.JsonApiErr(401, "Invalid Render Key", nil)
                return true
        }</span><span class="cov0" title="0"> else {

                ctx.IsSignedIn = true
                ctx.SignedInUser = renderUser
                ctx.IsRenderCall = true
                return true
        }</span>
}

type renderContextFunc func(key string) (string, error)

func AddRenderAuthKey(orgId int64) string <span class="cov0" title="0">{
        renderKeysLock.Lock()

        key := util.GetRandomString(32)

        renderKeys[key] = &amp;m.SignedInUser{
                OrgId:   orgId,
                OrgRole: m.ROLE_VIEWER,
        }

        renderKeysLock.Unlock()

        return key
}</span>

func RemoveRenderAuthKey(key string) <span class="cov0" title="0">{
        renderKeysLock.Lock()
        delete(renderKeys, key)
        renderKeysLock.Unlock()
}</span>
</pre>
		
		<pre class="file" id="file83" style="display: none">package middleware

import (
        "net/http"
        "strings"

        "github.com/grafana/grafana/pkg/metrics"
        "gopkg.in/macaron.v1"
)

func RequestMetrics() macaron.Handler <span class="cov0" title="0">{
        return func(res http.ResponseWriter, req *http.Request, c *macaron.Context) </span><span class="cov0" title="0">{
                rw := res.(macaron.ResponseWriter)
                c.Next()

                status := rw.Status()

                if strings.HasPrefix(req.RequestURI, "/api/datasources/proxy") </span><span class="cov0" title="0">{
                        countProxyRequests(status)
                }</span><span class="cov0" title="0"> else if strings.HasPrefix(req.RequestURI, "/api/") </span><span class="cov0" title="0">{
                        countApiRequests(status)
                }</span><span class="cov0" title="0"> else {
                        countPageRequests(status)
                }</span>
        }
}

func countApiRequests(status int) <span class="cov0" title="0">{
        switch status </span>{
        case 200:<span class="cov0" title="0">
                metrics.M_Api_Status_200.Inc(1)</span>
        case 404:<span class="cov0" title="0">
                metrics.M_Api_Status_404.Inc(1)</span>
        case 500:<span class="cov0" title="0">
                metrics.M_Api_Status_500.Inc(1)</span>
        default:<span class="cov0" title="0">
                metrics.M_Api_Status_Unknown.Inc(1)</span>
        }
}

func countPageRequests(status int) <span class="cov0" title="0">{
        switch status </span>{
        case 200:<span class="cov0" title="0">
                metrics.M_Page_Status_200.Inc(1)</span>
        case 404:<span class="cov0" title="0">
                metrics.M_Page_Status_404.Inc(1)</span>
        case 500:<span class="cov0" title="0">
                metrics.M_Page_Status_500.Inc(1)</span>
        default:<span class="cov0" title="0">
                metrics.M_Page_Status_Unknown.Inc(1)</span>
        }
}

func countProxyRequests(status int) <span class="cov0" title="0">{
        switch status </span>{
        case 200:<span class="cov0" title="0">
                metrics.M_Proxy_Status_200.Inc(1)</span>
        case 404:<span class="cov0" title="0">
                metrics.M_Proxy_Status_404.Inc(1)</span>
        case 500:<span class="cov0" title="0">
                metrics.M_Proxy_Status_500.Inc(1)</span>
        default:<span class="cov0" title="0">
                metrics.M_Proxy_Status_Unknown.Inc(1)</span>
        }
}
</pre>
		
		<pre class="file" id="file84" style="display: none">package middleware

import (
        "time"

        "github.com/go-macaron/session"
        _ "github.com/go-macaron/session/memcache"
        _ "github.com/go-macaron/session/mysql"
        _ "github.com/go-macaron/session/postgres"
        _ "github.com/go-macaron/session/redis"
        "gopkg.in/macaron.v1"
)

const (
        SESS_KEY_USERID       = "uid"
        SESS_KEY_OAUTH_STATE  = "state"
        SESS_KEY_APIKEY       = "apikey_id" // used for render requests with api keys
        SESS_KEY_LASTLDAPSYNC = "last_ldap_sync"
)

var sessionManager *session.Manager
var sessionOptions *session.Options
var startSessionGC func()
var getSessionCount func() int

func init() <span class="cov8" title="1">{
        startSessionGC = func() </span><span class="cov0" title="0">{
                sessionManager.GC()
                time.AfterFunc(time.Duration(sessionOptions.Gclifetime)*time.Second, startSessionGC)
        }</span>
        <span class="cov8" title="1">getSessionCount = func() int </span><span class="cov0" title="0">{
                return sessionManager.Count()
        }</span>
}

func prepareOptions(opt *session.Options) *session.Options <span class="cov8" title="1">{
        if len(opt.Provider) == 0 </span><span class="cov8" title="1">{
                opt.Provider = "memory"
        }</span>
        <span class="cov8" title="1">if len(opt.ProviderConfig) == 0 </span><span class="cov8" title="1">{
                opt.ProviderConfig = "data/sessions"
        }</span>
        <span class="cov8" title="1">if len(opt.CookieName) == 0 </span><span class="cov8" title="1">{
                opt.CookieName = "grafana_sess"
        }</span>
        <span class="cov8" title="1">if len(opt.CookiePath) == 0 </span><span class="cov8" title="1">{
                opt.CookiePath = "/"
        }</span>
        <span class="cov8" title="1">if opt.Gclifetime == 0 </span><span class="cov8" title="1">{
                opt.Gclifetime = 3600
        }</span>
        <span class="cov8" title="1">if opt.Maxlifetime == 0 </span><span class="cov8" title="1">{
                opt.Maxlifetime = opt.Gclifetime
        }</span>
        <span class="cov8" title="1">if opt.IDLength == 0 </span><span class="cov8" title="1">{
                opt.IDLength = 16
        }</span>

        <span class="cov8" title="1">return opt</span>
}

func Sessioner(options *session.Options) macaron.Handler <span class="cov8" title="1">{
        var err error
        sessionOptions = prepareOptions(options)
        sessionManager, err = session.NewManager(options.Provider, *options)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov8" title="1">go startSessionGC()

        return func(ctx *Context) </span><span class="cov8" title="1">{
                ctx.Next()

                if err = ctx.Session.Release(); err != nil </span><span class="cov0" title="0">{
                        panic("session(release): " + err.Error())</span>
                }
        }
}

func GetSession() SessionStore <span class="cov8" title="1">{
        return &amp;SessionWrapper{manager: sessionManager}
}</span>

type SessionStore interface {
        // Set sets value to given key in session.
        Set(interface{}, interface{}) error
        // Get gets value by given key in session.
        Get(interface{}) interface{}
        // ID returns current session ID.
        ID() string
        // Release releases session resource and save data to provider.
        Release() error
        // Destory deletes a session.
        Destory(*Context) error
        // init
        Start(*Context) error
}

type SessionWrapper struct {
        session session.RawStore
        manager *session.Manager
}

func (s *SessionWrapper) Start(c *Context) error <span class="cov8" title="1">{
        var err error
        s.session, err = s.manager.Start(c.Context)
        return err
}</span>

func (s *SessionWrapper) Set(k interface{}, v interface{}) error <span class="cov8" title="1">{
        if s.session != nil </span><span class="cov8" title="1">{
                return s.session.Set(k, v)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (s *SessionWrapper) Get(k interface{}) interface{} <span class="cov8" title="1">{
        if s.session != nil </span><span class="cov8" title="1">{
                return s.session.Get(k)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (s *SessionWrapper) ID() string <span class="cov8" title="1">{
        if s.session != nil </span><span class="cov8" title="1">{
                return s.session.ID()
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (s *SessionWrapper) Release() error <span class="cov8" title="1">{
        if s.session != nil </span><span class="cov8" title="1">{
                return s.session.Release()
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (s *SessionWrapper) Destory(c *Context) error <span class="cov8" title="1">{
        if s.session != nil </span><span class="cov8" title="1">{
                if err := s.manager.Destory(c.Context); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">s.session = nil</span>
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file85" style="display: none">package middleware

import (
        "strings"

        "github.com/go-macaron/gzip"
        "gopkg.in/macaron.v1"
)

func Gziper() macaron.Handler <span class="cov0" title="0">{
        macaronGziper := gzip.Gziper()

        return func(ctx *macaron.Context) </span><span class="cov0" title="0">{
                requestPath := ctx.Req.URL.RequestURI()
                // ignore datasource proxy requests
                if strings.HasPrefix(requestPath, "/api/datasources/proxy") </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov0" title="0">if strings.HasPrefix(requestPath, "/api/plugin-proxy/") </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov0" title="0">ctx.Invoke(macaronGziper)</span>
        }
}
</pre>
		
		<pre class="file" id="file86" style="display: none">package middleware

import (
        "strings"

        "github.com/grafana/grafana/pkg/setting"
        "gopkg.in/macaron.v1"
)

func ValidateHostHeader(domain string) macaron.Handler <span class="cov0" title="0">{
        return func(c *Context) </span><span class="cov0" title="0">{
                // ignore local render calls
                if c.IsRenderCall </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov0" title="0">h := c.Req.Host
                if i := strings.Index(h, ":"); i &gt;= 0 </span><span class="cov0" title="0">{
                        h = h[:i]
                }</span>

                <span class="cov0" title="0">if !strings.EqualFold(h, domain) </span><span class="cov0" title="0">{
                        c.Redirect(strings.TrimSuffix(setting.AppUrl, "/")+c.Req.RequestURI, 301)
                        return
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file87" style="display: none">package models

import (
        "time"

        "fmt"

        "github.com/grafana/grafana/pkg/components/simplejson"
)

type AlertStateType string
type AlertSeverityType string
type NoDataOption string
type ExecutionErrorOption string

const (
        AlertStateNoData   AlertStateType = "no_data"
        AlertStatePaused   AlertStateType = "paused"
        AlertStateAlerting AlertStateType = "alerting"
        AlertStateOK       AlertStateType = "ok"
        AlertStatePending  AlertStateType = "pending"
)

const (
        NoDataSetOK       NoDataOption = "ok"
        NoDataSetNoData   NoDataOption = "no_data"
        NoDataKeepState   NoDataOption = "keep_state"
        NoDataSetAlerting NoDataOption = "alerting"
)

const (
        ExecutionErrorSetAlerting ExecutionErrorOption = "alerting"
        ExecutionErrorKeepState   ExecutionErrorOption = "keep_state"
)

var (
        ErrCannotChangeStateOnPausedAlert error = fmt.Errorf("Cannot change state on pause alert")
        ErrRequiresNewState               error = fmt.Errorf("update alert state requires a new state.")
)

func (s AlertStateType) IsValid() bool <span class="cov0" title="0">{
        return s == AlertStateOK || s == AlertStateNoData || s == AlertStatePaused || s == AlertStatePending
}</span>

func (s NoDataOption) IsValid() bool <span class="cov0" title="0">{
        return s == NoDataSetNoData || s == NoDataSetAlerting || s == NoDataKeepState || s == NoDataSetOK
}</span>

func (s NoDataOption) ToAlertState() AlertStateType <span class="cov0" title="0">{
        return AlertStateType(s)
}</span>

func (s ExecutionErrorOption) IsValid() bool <span class="cov0" title="0">{
        return s == ExecutionErrorSetAlerting || s == ExecutionErrorKeepState
}</span>

func (s ExecutionErrorOption) ToAlertState() AlertStateType <span class="cov0" title="0">{
        return AlertStateType(s)
}</span>

type Alert struct {
        Id             int64
        Version        int64
        OrgId          int64
        DashboardId    int64
        PanelId        int64
        Name           string
        Message        string
        Severity       string
        State          AlertStateType
        Handler        int64
        Silenced       bool
        ExecutionError string
        Frequency      int64

        EvalData     *simplejson.Json
        NewStateDate time.Time
        StateChanges int

        Created time.Time
        Updated time.Time

        Settings *simplejson.Json
}

func (alert *Alert) ValidToSave() bool <span class="cov0" title="0">{
        return alert.DashboardId != 0 &amp;&amp; alert.OrgId != 0 &amp;&amp; alert.PanelId != 0
}</span>

func (alert *Alert) ShouldUpdateState(newState AlertStateType) bool <span class="cov0" title="0">{
        return alert.State != newState
}</span>

func (this *Alert) ContainsUpdates(other *Alert) bool <span class="cov8" title="1">{
        result := false
        result = result || this.Name != other.Name
        result = result || this.Message != other.Message

        if this.Settings != nil &amp;&amp; other.Settings != nil </span><span class="cov8" title="1">{
                json1, err1 := this.Settings.Encode()
                json2, err2 := other.Settings.Encode()

                if err1 != nil || err2 != nil </span><span class="cov0" title="0">{
                        return false
                }</span>

                <span class="cov8" title="1">result = result || string(json1) != string(json2)</span>
        }

        //don't compare .State! That would be insane.
        <span class="cov8" title="1">return result</span>
}

type AlertingClusterInfo struct {
        ServerId       string
        ClusterSize    int
        UptimePosition int
}

type HeartBeat struct {
        Id       int64
        ServerId string
        Updated  time.Time
        Created  time.Time
}

type HeartBeatCommand struct {
        ServerId string
        Result   AlertingClusterInfo
}

type SaveAlertsCommand struct {
        DashboardId int64
        UserId      int64
        OrgId       int64

        Alerts []*Alert
}

type PauseAlertCommand struct {
        OrgId       int64
        AlertIds    []int64
        ResultCount int64
        Paused      bool
}

type PauseAllAlertCommand struct {
        ResultCount int64
        Paused      bool
}

type SetAlertStateCommand struct {
        AlertId  int64
        OrgId    int64
        State    AlertStateType
        Error    string
        EvalData *simplejson.Json

        Timestamp time.Time
}

type DeleteAlertCommand struct {
        AlertId int64
}

//Queries
type GetAlertsQuery struct {
        OrgId       int64
        State       []string
        DashboardId int64
        PanelId     int64
        Limit       int64

        Result []*Alert
}

type GetAllAlertsQuery struct {
        Result []*Alert
}

type GetAlertByIdQuery struct {
        Id int64

        Result *Alert
}

type GetAlertStatesForDashboardQuery struct {
        OrgId       int64
        DashboardId int64

        Result []*AlertStateInfoDTO
}

type AlertStateInfoDTO struct {
        Id           int64          `json:"id"`
        DashboardId  int64          `json:"dashboardId"`
        PanelId      int64          `json:"panelId"`
        State        AlertStateType `json:"state"`
        NewStateDate time.Time      `json:"newStateDate"`
}
</pre>
		
		<pre class="file" id="file88" style="display: none">package models

import (
        "errors"
        "strings"
        "time"

        "github.com/gosimple/slug"
        "github.com/grafana/grafana/pkg/components/simplejson"
)

// Typed errors
var (
        ErrDashboardNotFound           = errors.New("Dashboard not found")
        ErrDashboardSnapshotNotFound   = errors.New("Dashboard snapshot not found")
        ErrDashboardWithSameNameExists = errors.New("A dashboard with the same name already exists")
        ErrDashboardVersionMismatch    = errors.New("The dashboard has been changed by someone else")
        ErrDashboardTitleEmpty         = errors.New("Dashboard title cannot be empty")
)

type UpdatePluginDashboardError struct {
        PluginId string
}

func (d UpdatePluginDashboardError) Error() string <span class="cov0" title="0">{
        return "Dashboard belong to plugin"
}</span>

var (
        DashTypeJson     = "file"
        DashTypeDB       = "db"
        DashTypeScript   = "script"
        DashTypeSnapshot = "snapshot"
)

// Dashboard model
type Dashboard struct {
        Id       int64
        Slug     string
        OrgId    int64
        GnetId   int64
        Version  int
        PluginId string

        Created time.Time
        Updated time.Time

        UpdatedBy int64
        CreatedBy int64

        Title string
        Data  *simplejson.Json
}

// NewDashboard creates a new dashboard
func NewDashboard(title string) *Dashboard <span class="cov8" title="1">{
        dash := &amp;Dashboard{}
        dash.Data = simplejson.New()
        dash.Data.Set("title", title)
        dash.Title = title
        dash.Created = time.Now()
        dash.Updated = time.Now()
        dash.UpdateSlug()
        return dash
}</span>

// GetTags turns the tags in data json into go string array
func (dash *Dashboard) GetTags() []string <span class="cov8" title="1">{
        return dash.Data.Get("tags").MustStringArray()
}</span>

func NewDashboardFromJson(data *simplejson.Json) *Dashboard <span class="cov8" title="1">{
        dash := &amp;Dashboard{}
        dash.Data = data
        dash.Title = dash.Data.Get("title").MustString()
        dash.UpdateSlug()

        if id, err := dash.Data.Get("id").Float64(); err == nil </span><span class="cov0" title="0">{
                dash.Id = int64(id)

                if version, err := dash.Data.Get("version").Float64(); err == nil </span><span class="cov0" title="0">{
                        dash.Version = int(version)
                        dash.Updated = time.Now()
                }</span>
        }<span class="cov8" title="1"> else {
                dash.Data.Set("version", 0)
                dash.Created = time.Now()
                dash.Updated = time.Now()
        }</span>

        <span class="cov8" title="1">if gnetId, err := dash.Data.Get("gnetId").Float64(); err == nil </span><span class="cov0" title="0">{
                dash.GnetId = int64(gnetId)
        }</span>

        <span class="cov8" title="1">return dash</span>
}

// GetDashboardModel turns the command into the savable model
func (cmd *SaveDashboardCommand) GetDashboardModel() *Dashboard <span class="cov0" title="0">{
        dash := NewDashboardFromJson(cmd.Dashboard)

        if dash.Data.Get("version").MustInt(0) == 0 </span><span class="cov0" title="0">{
                dash.CreatedBy = cmd.UserId
        }</span>

        <span class="cov0" title="0">dash.UpdatedBy = cmd.UserId
        dash.OrgId = cmd.OrgId
        dash.PluginId = cmd.PluginId
        dash.UpdateSlug()
        return dash</span>
}

// GetString a
func (dash *Dashboard) GetString(prop string, defaultValue string) string <span class="cov0" title="0">{
        return dash.Data.Get(prop).MustString(defaultValue)
}</span>

// UpdateSlug updates the slug
func (dash *Dashboard) UpdateSlug() <span class="cov8" title="1">{
        title := strings.ToLower(dash.Data.Get("title").MustString())
        dash.Slug = slug.Make(title)
}</span>

//
// COMMANDS
//

type SaveDashboardCommand struct {
        Dashboard *simplejson.Json `json:"dashboard" binding:"Required"`
        UserId    int64            `json:"userId"`
        OrgId     int64            `json:"-"`
        Overwrite bool             `json:"overwrite"`
        PluginId  string           `json:"-"`

        Result *Dashboard
}

type DeleteDashboardCommand struct {
        Slug  string
        OrgId int64
}

//
// QUERIES
//

type GetDashboardQuery struct {
        Slug  string
        OrgId int64

        Result *Dashboard
}

type DashboardTagCloudItem struct {
        Term  string `json:"term"`
        Count int    `json:"count"`
}

type GetDashboardTagsQuery struct {
        OrgId  int64
        Result []*DashboardTagCloudItem
}

type GetDashboardsQuery struct {
        DashboardIds []int64
        Result       []*Dashboard
}

type GetDashboardsByPluginIdQuery struct {
        OrgId    int64
        PluginId string
        Result   []*Dashboard
}

type GetDashboardSlugByIdQuery struct {
        Id     int64
        Result string
}
</pre>
		
		<pre class="file" id="file89" style="display: none">package models

import (
        "errors"
        "time"

        "github.com/grafana/grafana/pkg/components/securejsondata"
        "github.com/grafana/grafana/pkg/components/simplejson"
)

const (
        DS_GRAPHITE      = "graphite"
        DS_INFLUXDB      = "influxdb"
        DS_INFLUXDB_08   = "influxdb_08"
        DS_ES            = "elasticsearch"
        DS_OPENTSDB      = "opentsdb"
        DS_CLOUDWATCH    = "cloudwatch"
        DS_KAIROSDB      = "kairosdb"
        DS_PROMETHEUS    = "prometheus"
        DS_ACCESS_DIRECT = "direct"
        DS_ACCESS_PROXY  = "proxy"
)

// Typed errors
var (
        ErrDataSourceNotFound   = errors.New("Data source not found")
        ErrDataSourceNameExists = errors.New("Data source with same name already exists")
)

type DsAccess string

type DataSource struct {
        Id      int64
        OrgId   int64
        Version int

        Name              string
        Type              string
        Access            DsAccess
        Url               string
        Password          string
        User              string
        Database          string
        BasicAuth         bool
        BasicAuthUser     string
        BasicAuthPassword string
        WithCredentials   bool
        IsDefault         bool
        JsonData          *simplejson.Json
        SecureJsonData    securejsondata.SecureJsonData

        Created time.Time
        Updated time.Time
}

var knownDatasourcePlugins map[string]bool = map[string]bool{
        DS_ES:          true,
        DS_GRAPHITE:    true,
        DS_INFLUXDB:    true,
        DS_INFLUXDB_08: true,
        DS_KAIROSDB:    true,
        DS_CLOUDWATCH:  true,
        DS_PROMETHEUS:  true,
        DS_OPENTSDB:    true,
        "opennms":      true,
        "druid":        true,
        "dalmatinerdb": true,
        "gnocci":       true,
        "zabbix":       true,
}

func IsKnownDataSourcePlugin(dsType string) bool <span class="cov0" title="0">{
        _, exists := knownDatasourcePlugins[dsType]
        return exists
}</span>

// ----------------------
// COMMANDS

// Also acts as api DTO
type AddDataSourceCommand struct {
        Name              string            `json:"name" binding:"Required"`
        Type              string            `json:"type" binding:"Required"`
        Access            DsAccess          `json:"access" binding:"Required"`
        Url               string            `json:"url"`
        Password          string            `json:"password"`
        Database          string            `json:"database"`
        User              string            `json:"user"`
        BasicAuth         bool              `json:"basicAuth"`
        BasicAuthUser     string            `json:"basicAuthUser"`
        BasicAuthPassword string            `json:"basicAuthPassword"`
        WithCredentials   bool              `json:"withCredentials"`
        IsDefault         bool              `json:"isDefault"`
        JsonData          *simplejson.Json  `json:"jsonData"`
        SecureJsonData    map[string]string `json:"secureJsonData"`

        OrgId int64 `json:"-"`

        Result *DataSource
}

// Also acts as api DTO
type UpdateDataSourceCommand struct {
        Name              string            `json:"name" binding:"Required"`
        Type              string            `json:"type" binding:"Required"`
        Access            DsAccess          `json:"access" binding:"Required"`
        Url               string            `json:"url"`
        Password          string            `json:"password"`
        User              string            `json:"user"`
        Database          string            `json:"database"`
        BasicAuth         bool              `json:"basicAuth"`
        BasicAuthUser     string            `json:"basicAuthUser"`
        BasicAuthPassword string            `json:"basicAuthPassword"`
        WithCredentials   bool              `json:"withCredentials"`
        IsDefault         bool              `json:"isDefault"`
        JsonData          *simplejson.Json  `json:"jsonData"`
        SecureJsonData    map[string]string `json:"secureJsonData"`

        OrgId int64 `json:"-"`
        Id    int64 `json:"-"`
}

type DeleteDataSourceByIdCommand struct {
        Id    int64
        OrgId int64
}

type DeleteDataSourceByNameCommand struct {
        Name  string
        OrgId int64
}

// ---------------------
// QUERIES

type GetDataSourcesQuery struct {
        OrgId  int64
        Result []*DataSource
}

type GetDataSourceByIdQuery struct {
        Id     int64
        OrgId  int64
        Result *DataSource
}

type GetDataSourceByNameQuery struct {
        Name   string
        OrgId  int64
        Result *DataSource
}

// ---------------------
// EVENTS
type DataSourceCreatedEvent struct {
}
</pre>
		
		<pre class="file" id="file90" style="display: none">package models

import (
        "crypto/tls"
        "crypto/x509"
        "net"
        "net/http"
        "sync"
        "time"
)

type proxyTransportCache struct {
        cache map[int64]cachedTransport
        sync.Mutex
}

type cachedTransport struct {
        updated time.Time

        *http.Transport
}

var ptc = proxyTransportCache{
        cache: make(map[int64]cachedTransport),
}

func (ds *DataSource) GetHttpClient() (*http.Client, error) <span class="cov0" title="0">{
        transport, err := ds.GetHttpTransport()

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;http.Client{
                Timeout:   time.Duration(30 * time.Second),
                Transport: transport,
        }, nil</span>
}

func (ds *DataSource) GetHttpTransport() (*http.Transport, error) <span class="cov8" title="1">{
        ptc.Lock()
        defer ptc.Unlock()

        if t, present := ptc.cache[ds.Id]; present &amp;&amp; ds.Updated.Equal(t.updated) </span><span class="cov8" title="1">{
                return t.Transport, nil
        }</span>

        <span class="cov8" title="1">transport := &amp;http.Transport{
                TLSClientConfig: &amp;tls.Config{
                        InsecureSkipVerify: true,
                },
                Proxy: http.ProxyFromEnvironment,
                Dial: (&amp;net.Dialer{
                        Timeout:   30 * time.Second,
                        KeepAlive: 30 * time.Second,
                }).Dial,
                TLSHandshakeTimeout:   10 * time.Second,
                ExpectContinueTimeout: 1 * time.Second,
                MaxIdleConns:          100,
                IdleConnTimeout:       90 * time.Second,
        }

        var tlsAuth, tlsAuthWithCACert bool
        if ds.JsonData != nil </span><span class="cov8" title="1">{
                tlsAuth = ds.JsonData.Get("tlsAuth").MustBool(false)
                tlsAuthWithCACert = ds.JsonData.Get("tlsAuthWithCACert").MustBool(false)
        }</span>

        <span class="cov8" title="1">if tlsAuth </span><span class="cov8" title="1">{
                transport.TLSClientConfig.InsecureSkipVerify = false

                decrypted := ds.SecureJsonData.Decrypt()

                if tlsAuthWithCACert &amp;&amp; len(decrypted["tlsCACert"]) &gt; 0 </span><span class="cov8" title="1">{
                        caPool := x509.NewCertPool()
                        ok := caPool.AppendCertsFromPEM([]byte(decrypted["tlsCACert"]))
                        if ok </span><span class="cov8" title="1">{
                                transport.TLSClientConfig.RootCAs = caPool
                        }</span>
                }

                <span class="cov8" title="1">cert, err := tls.X509KeyPair([]byte(decrypted["tlsClientCert"]), []byte(decrypted["tlsClientKey"]))
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">transport.TLSClientConfig.Certificates = []tls.Certificate{cert}</span>
        }

        <span class="cov8" title="1">ptc.cache[ds.Id] = cachedTransport{
                Transport: transport,
                updated:   ds.Updated,
        }

        return transport, nil</span>
}
</pre>
		
		<pre class="file" id="file91" style="display: none">package models

type HelpFlags1 uint64

const (
        HelpFlagGettingStartedPanelDismissed HelpFlags1 = 1 &lt;&lt; iota
        HelpFlagDashboardHelp1
)

func (f HelpFlags1) HasFlag(flag HelpFlags1) bool <span class="cov0" title="0">{ return f&amp;flag != 0 }</span>
func (f *HelpFlags1) AddFlag(flag HelpFlags1)     <span class="cov0" title="0">{ *f |= flag }</span>
func (f *HelpFlags1) ClearFlag(flag HelpFlags1)   <span class="cov0" title="0">{ *f &amp;= ^flag }</span>
func (f *HelpFlags1) ToggleFlag(flag HelpFlags1)  <span class="cov0" title="0">{ *f ^= flag }</span>

type SetUserHelpFlagCommand struct {
        HelpFlags1 HelpFlags1
        UserId     int64
}
</pre>
		
		<pre class="file" id="file92" style="display: none">package models

import (
        "encoding/json"
        "errors"
        "fmt"
        "time"
)

// Typed errors
var (
        ErrInvalidRoleType     = errors.New("Invalid role type")
        ErrLastOrgAdmin        = errors.New("Cannot remove last organization admin")
        ErrOrgUserNotFound     = errors.New("Cannot find the organization user")
        ErrOrgUserAlreadyAdded = errors.New("User is already added to organization")
)

type RoleType string

const (
        ROLE_VIEWER           RoleType = "Viewer"
        ROLE_EDITOR           RoleType = "Editor"
        ROLE_READ_ONLY_EDITOR RoleType = "Read Only Editor"
        ROLE_ADMIN            RoleType = "Admin"
)

func (r RoleType) IsValid() bool <span class="cov0" title="0">{
        return r == ROLE_VIEWER || r == ROLE_ADMIN || r == ROLE_EDITOR || r == ROLE_READ_ONLY_EDITOR
}</span>

func (r RoleType) Includes(other RoleType) bool <span class="cov0" title="0">{
        if r == ROLE_ADMIN </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">if r == ROLE_EDITOR || r == ROLE_READ_ONLY_EDITOR </span><span class="cov0" title="0">{
                return other != ROLE_ADMIN
        }</span>

        <span class="cov0" title="0">return r == other</span>
}

func (r *RoleType) UnmarshalJSON(data []byte) error <span class="cov0" title="0">{
        var str string
        err := json.Unmarshal(data, &amp;str)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">*r = RoleType(str)

        if (*r).IsValid() == false </span><span class="cov0" title="0">{
                if (*r) != "" </span><span class="cov0" title="0">{
                        return errors.New(fmt.Sprintf("JSON validation error: invalid role value: %s", *r))
                }</span>

                <span class="cov0" title="0">*r = ROLE_VIEWER</span>
        }

        <span class="cov0" title="0">return nil</span>
}

type OrgUser struct {
        Id      int64
        OrgId   int64
        UserId  int64
        Role    RoleType
        Created time.Time
        Updated time.Time
}

// ---------------------
// COMMANDS

type RemoveOrgUserCommand struct {
        UserId int64
        OrgId  int64
}

type AddOrgUserCommand struct {
        LoginOrEmail string   `json:"loginOrEmail" binding:"Required"`
        Role         RoleType `json:"role" binding:"Required"`

        OrgId  int64 `json:"-"`
        UserId int64 `json:"-"`
}

type UpdateOrgUserCommand struct {
        Role RoleType `json:"role" binding:"Required"`

        OrgId  int64 `json:"-"`
        UserId int64 `json:"-"`
}

// ----------------------
// QUERIES

type GetOrgUsersQuery struct {
        OrgId  int64
        Result []*OrgUserDTO
}

// ----------------------
// Projections and DTOs

type OrgUserDTO struct {
        OrgId  int64  `json:"orgId"`
        UserId int64  `json:"userId"`
        Email  string `json:"email"`
        Login  string `json:"login"`
        Role   string `json:"role"`
}
</pre>
		
		<pre class="file" id="file93" style="display: none">package models

import (
        "errors"
)

// Typed errors
var (
        ErrPlaylistNotFound           = errors.New("Playlist not found")
        ErrPlaylistWithSameNameExists = errors.New("A playlist with the same name already exists")
)

// Playlist model
type Playlist struct {
        Id       int64  `json:"id"`
        Name     string `json:"name"`
        Interval string `json:"interval"`
        OrgId    int64  `json:"-"`
}

type PlaylistDTO struct {
        Id       int64             `json:"id"`
        Name     string            `json:"name"`
        Interval string            `json:"interval"`
        OrgId    int64             `json:"-"`
        Items    []PlaylistItemDTO `json:"items"`
}

type PlaylistItemDTO struct {
        Id         int64  `json:"id"`
        PlaylistId int64  `json:"playlistid"`
        Type       string `json:"type"`
        Title      string `json:"title"`
        Value      string `json:"value"`
        Order      int    `json:"order"`
}

type PlaylistDashboard struct {
        Id    int64  `json:"id"`
        Slug  string `json:"slug"`
        Title string `json:"title"`
}

type PlaylistItem struct {
        Id         int64
        PlaylistId int64
        Type       string
        Value      string
        Order      int
        Title      string
}

func (this PlaylistDashboard) TableName() string <span class="cov0" title="0">{
        return "dashboard"
}</span>

type Playlists []*Playlist
type PlaylistDashboards []*PlaylistDashboard

//
// COMMANDS
//

type UpdatePlaylistCommand struct {
        OrgId    int64             `json:"-"`
        Id       int64             `json:"id" binding:"Required"`
        Name     string            `json:"name" binding:"Required"`
        Interval string            `json:"interval"`
        Items    []PlaylistItemDTO `json:"items"`

        Result *PlaylistDTO
}

type CreatePlaylistCommand struct {
        Name     string            `json:"name" binding:"Required"`
        Interval string            `json:"interval"`
        Items    []PlaylistItemDTO `json:"items"`

        OrgId  int64 `json:"-"`
        Result *Playlist
}

type DeletePlaylistCommand struct {
        Id    int64
        OrgId int64
}

//
// QUERIES
//

type GetPlaylistsQuery struct {
        Name  string
        Limit int
        OrgId int64

        Result Playlists
}

type GetPlaylistByIdQuery struct {
        Id     int64
        Result *Playlist
}

type GetPlaylistItemsByIdQuery struct {
        PlaylistId int64
        Result     *[]PlaylistItem
}
</pre>
		
		<pre class="file" id="file94" style="display: none">package models

import (
        "errors"
        "time"

        "github.com/grafana/grafana/pkg/components/securejsondata"
)

var (
        ErrPluginSettingNotFound = errors.New("Plugin setting not found")
)

type PluginSetting struct {
        Id             int64
        PluginId       string
        OrgId          int64
        Enabled        bool
        Pinned         bool
        JsonData       map[string]interface{}
        SecureJsonData securejsondata.SecureJsonData
        PluginVersion  string

        Created time.Time
        Updated time.Time
}

// ----------------------
// COMMANDS

// Also acts as api DTO
type UpdatePluginSettingCmd struct {
        Enabled        bool                   `json:"enabled"`
        Pinned         bool                   `json:"pinned"`
        JsonData       map[string]interface{} `json:"jsonData"`
        SecureJsonData map[string]string      `json:"secureJsonData"`
        PluginVersion  string                 `json:"version"`

        PluginId string `json:"-"`
        OrgId    int64  `json:"-"`
}

// specific command, will only update version
type UpdatePluginSettingVersionCmd struct {
        PluginVersion string
        PluginId      string `json:"-"`
        OrgId         int64  `json:"-"`
}

func (cmd *UpdatePluginSettingCmd) GetEncryptedJsonData() securejsondata.SecureJsonData <span class="cov0" title="0">{
        return securejsondata.GetEncryptedJsonData(cmd.SecureJsonData)
}</span>

// ---------------------
// QUERIES
type GetPluginSettingsQuery struct {
        OrgId  int64
        Result []*PluginSettingInfoDTO
}

type PluginSettingInfoDTO struct {
        OrgId         int64
        PluginId      string
        Enabled       bool
        Pinned        bool
        PluginVersion string
}

type GetPluginSettingByIdQuery struct {
        PluginId string
        OrgId    int64
        Result   *PluginSetting
}

type PluginStateChangedEvent struct {
        PluginId string
        OrgId    int64
        Enabled  bool
}
</pre>
		
		<pre class="file" id="file95" style="display: none">package models

import (
        "errors"
        "github.com/grafana/grafana/pkg/setting"
        "time"
)

var ErrInvalidQuotaTarget = errors.New("Invalid quota target")

type Quota struct {
        Id      int64
        OrgId   int64
        UserId  int64
        Target  string
        Limit   int64
        Created time.Time
        Updated time.Time
}

type QuotaScope struct {
        Name         string
        Target       string
        DefaultLimit int64
}

type OrgQuotaDTO struct {
        OrgId  int64  `json:"org_id"`
        Target string `json:"target"`
        Limit  int64  `json:"limit"`
        Used   int64  `json:"used"`
}

type UserQuotaDTO struct {
        UserId int64  `json:"user_id"`
        Target string `json:"target"`
        Limit  int64  `json:"limit"`
        Used   int64  `json:"used"`
}

type GlobalQuotaDTO struct {
        Target string `json:"target"`
        Limit  int64  `json:"limit"`
        Used   int64  `json:"used"`
}

type GetOrgQuotaByTargetQuery struct {
        Target  string
        OrgId   int64
        Default int64
        Result  *OrgQuotaDTO
}

type GetOrgQuotasQuery struct {
        OrgId  int64
        Result []*OrgQuotaDTO
}

type GetUserQuotaByTargetQuery struct {
        Target  string
        UserId  int64
        Default int64
        Result  *UserQuotaDTO
}

type GetUserQuotasQuery struct {
        UserId int64
        Result []*UserQuotaDTO
}

type GetGlobalQuotaByTargetQuery struct {
        Target  string
        Default int64
        Result  *GlobalQuotaDTO
}

type UpdateOrgQuotaCmd struct {
        Target string `json:"target"`
        Limit  int64  `json:"limit"`
        OrgId  int64  `json:"-"`
}

type UpdateUserQuotaCmd struct {
        Target string `json:"target"`
        Limit  int64  `json:"limit"`
        UserId int64  `json:"-"`
}

func GetQuotaScopes(target string) ([]QuotaScope, error) <span class="cov0" title="0">{
        scopes := make([]QuotaScope, 0)
        switch target </span>{
        case "user":<span class="cov0" title="0">
                scopes = append(scopes,
                        QuotaScope{Name: "global", Target: target, DefaultLimit: setting.Quota.Global.User},
                        QuotaScope{Name: "org", Target: "org_user", DefaultLimit: setting.Quota.Org.User},
                )
                return scopes, nil</span>
        case "org":<span class="cov0" title="0">
                scopes = append(scopes,
                        QuotaScope{Name: "global", Target: target, DefaultLimit: setting.Quota.Global.Org},
                        QuotaScope{Name: "user", Target: "org_user", DefaultLimit: setting.Quota.User.Org},
                )
                return scopes, nil</span>
        case "dashboard":<span class="cov0" title="0">
                scopes = append(scopes,
                        QuotaScope{Name: "global", Target: target, DefaultLimit: setting.Quota.Global.Dashboard},
                        QuotaScope{Name: "org", Target: target, DefaultLimit: setting.Quota.Org.Dashboard},
                )
                return scopes, nil</span>
        case "data_source":<span class="cov0" title="0">
                scopes = append(scopes,
                        QuotaScope{Name: "global", Target: target, DefaultLimit: setting.Quota.Global.DataSource},
                        QuotaScope{Name: "org", Target: target, DefaultLimit: setting.Quota.Org.DataSource},
                )
                return scopes, nil</span>
        case "api_key":<span class="cov0" title="0">
                scopes = append(scopes,
                        QuotaScope{Name: "global", Target: target, DefaultLimit: setting.Quota.Global.ApiKey},
                        QuotaScope{Name: "org", Target: target, DefaultLimit: setting.Quota.Org.ApiKey},
                )
                return scopes, nil</span>
        case "session":<span class="cov0" title="0">
                scopes = append(scopes,
                        QuotaScope{Name: "global", Target: target, DefaultLimit: setting.Quota.Global.Session},
                )
                return scopes, nil</span>
        default:<span class="cov0" title="0">
                return scopes, ErrInvalidQuotaTarget</span>
        }
}
</pre>
		
		<pre class="file" id="file96" style="display: none">package models

import (
        "errors"
        "time"
)

// Typed errors
var (
        ErrUserNotFound = errors.New("User not found")
)

type Password string

func (p Password) IsWeak() bool <span class="cov0" title="0">{
        return len(p) &lt;= 4
}</span>

type User struct {
        Id            int64
        Version       int
        Email         string
        Name          string
        Login         string
        Password      string
        Salt          string
        Rands         string
        Company       string
        EmailVerified bool
        Theme         string
        HelpFlags1    HelpFlags1

        IsAdmin bool
        OrgId   int64

        Created time.Time
        Updated time.Time
}

func (u *User) NameOrFallback() string <span class="cov0" title="0">{
        if u.Name != "" </span><span class="cov0" title="0">{
                return u.Name
        }</span><span class="cov0" title="0"> else if u.Login != "" </span><span class="cov0" title="0">{
                return u.Login
        }</span><span class="cov0" title="0"> else {
                return u.Email
        }</span>
}

// ---------------------
// COMMANDS

type CreateUserCommand struct {
        Email          string
        Login          string
        Name           string
        Company        string
        OrgName        string
        Password       string
        EmailVerified  bool
        IsAdmin        bool
        SkipOrgSetup   bool
        DefaultOrgRole string

        Result User
}

type UpdateUserCommand struct {
        Name  string `json:"name"`
        Email string `json:"email"`
        Login string `json:"login"`
        Theme string `json:"theme"`

        UserId int64 `json:"-"`
}

type ChangeUserPasswordCommand struct {
        OldPassword string `json:"oldPassword"`
        NewPassword string `json:"newPassword"`

        UserId int64 `json:"-"`
}

type UpdateUserPermissionsCommand struct {
        IsGrafanaAdmin bool
        UserId         int64 `json:"-"`
}

type DeleteUserCommand struct {
        UserId int64
}

type SetUsingOrgCommand struct {
        UserId int64
        OrgId  int64
}

// ----------------------
// QUERIES

type GetUserByLoginQuery struct {
        LoginOrEmail string
        Result       *User
}

type GetUserByEmailQuery struct {
        Email  string
        Result *User
}

type GetUserByIdQuery struct {
        Id     int64
        Result *User
}

type GetSignedInUserQuery struct {
        UserId int64
        Login  string
        Email  string
        Result *SignedInUser
}

type GetUserProfileQuery struct {
        UserId int64
        Result UserProfileDTO
}

type SearchUsersQuery struct {
        Query string
        Page  int
        Limit int

        Result SearchUserQueryResult
}

type SearchUserQueryResult struct {
        TotalCount int64               `json:"totalCount"`
        Users      []*UserSearchHitDTO `json:"users"`
        Page       int                 `json:"page"`
        PerPage    int                 `json:"perPage"`
}

type GetUserOrgListQuery struct {
        UserId int64
        Result []*UserOrgDTO
}

// ------------------------
// DTO &amp; Projections

type SignedInUser struct {
        UserId         int64
        OrgId          int64
        OrgName        string
        OrgRole        RoleType
        Login          string
        Name           string
        Email          string
        ApiKeyId       int64
        IsGrafanaAdmin bool
        HelpFlags1     HelpFlags1
}

type UserProfileDTO struct {
        Email          string `json:"email"`
        Name           string `json:"name"`
        Login          string `json:"login"`
        Theme          string `json:"theme"`
        OrgId          int64  `json:"orgId"`
        IsGrafanaAdmin bool   `json:"isGrafanaAdmin"`
}

type UserSearchHitDTO struct {
        Id      int64  `json:"id"`
        Name    string `json:"name"`
        Login   string `json:"login"`
        Email   string `json:"email"`
        IsAdmin bool   `json:"isAdmin"`
}

type UserIdDTO struct {
        Id      int64  `json:"id"`
        Message string `json:"message"`
}
</pre>
		
		<pre class="file" id="file97" style="display: none">package plugins

import (
        "encoding/json"
        "strings"

        "github.com/gosimple/slug"
        "github.com/grafana/grafana/pkg/models"
        "github.com/grafana/grafana/pkg/setting"
)

type AppPluginCss struct {
        Light string `json:"light"`
        Dark  string `json:"dark"`
}

type AppPlugin struct {
        FrontendPluginBase
        Routes []*AppPluginRoute `json:"routes"`

        FoundChildPlugins []*PluginInclude `json:"-"`
        Pinned            bool             `json:"-"`
}

type AppPluginRoute struct {
        Path            string                 `json:"path"`
        Method          string                 `json:"method"`
        ReqGrafanaAdmin bool                   `json:"reqGrafanaAdmin"`
        ReqRole         models.RoleType        `json:"reqRole"`
        Url             string                 `json:"url"`
        Headers         []AppPluginRouteHeader `json:"headers"`
}

type AppPluginRouteHeader struct {
        Name    string `json:"name"`
        Content string `json:"content"`
}

func (app *AppPlugin) Load(decoder *json.Decoder, pluginDir string) error <span class="cov8" title="1">{
        if err := decoder.Decode(&amp;app); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if err := app.registerPlugin(pluginDir); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">Apps[app.Id] = app
        return nil</span>
}

func (app *AppPlugin) initApp() <span class="cov8" title="1">{
        app.initFrontendPlugin()

        // check if we have child panels
        for _, panel := range Panels </span><span class="cov8" title="1">{
                if strings.HasPrefix(panel.PluginDir, app.PluginDir) </span><span class="cov0" title="0">{
                        panel.setPathsBasedOnApp(app)
                        app.FoundChildPlugins = append(app.FoundChildPlugins, &amp;PluginInclude{
                                Name: panel.Name,
                                Id:   panel.Id,
                                Type: panel.Type,
                        })
                }</span>
        }

        // check if we have child datasources
        <span class="cov8" title="1">for _, ds := range DataSources </span><span class="cov8" title="1">{
                if strings.HasPrefix(ds.PluginDir, app.PluginDir) </span><span class="cov8" title="1">{
                        ds.setPathsBasedOnApp(app)
                        app.FoundChildPlugins = append(app.FoundChildPlugins, &amp;PluginInclude{
                                Name: ds.Name,
                                Id:   ds.Id,
                                Type: ds.Type,
                        })
                }</span>
        }

        // slugify pages
        <span class="cov8" title="1">for _, include := range app.Includes </span><span class="cov8" title="1">{
                if include.Slug == "" </span><span class="cov8" title="1">{
                        include.Slug = slug.Make(include.Name)
                }</span>
                <span class="cov8" title="1">if include.Type == "page" &amp;&amp; include.DefaultNav </span><span class="cov0" title="0">{
                        app.DefaultNavUrl = setting.AppSubUrl + "/plugins/" + app.Id + "/page/" + include.Slug
                }</span>
                <span class="cov8" title="1">if include.Type == "dashboard" &amp;&amp; include.DefaultNav </span><span class="cov0" title="0">{
                        app.DefaultNavUrl = setting.AppSubUrl + "/dashboard/db/" + include.Slug
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file98" style="display: none">package plugins

import (
        "encoding/json"
        "fmt"
        "regexp"

        "github.com/grafana/grafana/pkg/bus"
        "github.com/grafana/grafana/pkg/components/simplejson"
        m "github.com/grafana/grafana/pkg/models"
)

type ImportDashboardCommand struct {
        Dashboard *simplejson.Json
        Path      string
        Inputs    []ImportDashboardInput
        Overwrite bool

        OrgId    int64
        UserId   int64
        PluginId string
        Result   *PluginDashboardInfoDTO
}

type ImportDashboardInput struct {
        Type     string `json:"type"`
        PluginId string `json:"pluginId"`
        Name     string `json:"name"`
        Value    string `json:"value"`
}

type DashboardInputMissingError struct {
        VariableName string
}

func (e DashboardInputMissingError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("Dashbord input variable: %v missing from import command", e.VariableName)
}</span>

func init() <span class="cov8" title="1">{
        bus.AddHandler("plugins", ImportDashboard)
}</span>

func ImportDashboard(cmd *ImportDashboardCommand) error <span class="cov8" title="1">{
        var dashboard *m.Dashboard
        var err error

        if cmd.PluginId != "" </span><span class="cov8" title="1">{
                if dashboard, err = loadPluginDashboard(cmd.PluginId, cmd.Path); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }<span class="cov0" title="0"> else {
                dashboard = m.NewDashboardFromJson(cmd.Dashboard)
        }</span>

        <span class="cov8" title="1">evaluator := &amp;DashTemplateEvaluator{
                template: dashboard.Data,
                inputs:   cmd.Inputs,
        }

        generatedDash, err := evaluator.Eval()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">saveCmd := m.SaveDashboardCommand{
                Dashboard: generatedDash,
                OrgId:     cmd.OrgId,
                UserId:    cmd.UserId,
                Overwrite: cmd.Overwrite,
                PluginId:  cmd.PluginId,
        }

        if err := bus.Dispatch(&amp;saveCmd); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">cmd.Result = &amp;PluginDashboardInfoDTO{
                PluginId:         cmd.PluginId,
                Title:            dashboard.Title,
                Path:             cmd.Path,
                Revision:         dashboard.Data.Get("revision").MustInt64(1),
                ImportedUri:      "db/" + saveCmd.Result.Slug,
                ImportedRevision: dashboard.Data.Get("revision").MustInt64(1),
                Imported:         true,
        }

        return nil</span>
}

type DashTemplateEvaluator struct {
        template  *simplejson.Json
        inputs    []ImportDashboardInput
        variables map[string]string
        result    *simplejson.Json
        varRegex  *regexp.Regexp
}

func (this *DashTemplateEvaluator) findInput(varName string, varType string) *ImportDashboardInput <span class="cov8" title="1">{

        for _, input := range this.inputs </span><span class="cov8" title="1">{
                if varType == input.Type &amp;&amp; (input.Name == varName || input.Name == "*") </span><span class="cov8" title="1">{
                        return &amp;input
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (this *DashTemplateEvaluator) Eval() (*simplejson.Json, error) <span class="cov8" title="1">{
        this.result = simplejson.New()
        this.variables = make(map[string]string)
        this.varRegex, _ = regexp.Compile(`(\$\{.+\})`)

        // check that we have all inputs we need
        for _, inputDef := range this.template.Get("__inputs").MustArray() </span><span class="cov8" title="1">{
                inputDefJson := simplejson.NewFromAny(inputDef)
                inputName := inputDefJson.Get("name").MustString()
                inputType := inputDefJson.Get("type").MustString()
                input := this.findInput(inputName, inputType)

                if input == nil </span><span class="cov0" title="0">{
                        return nil, &amp;DashboardInputMissingError{VariableName: inputName}
                }</span>

                <span class="cov8" title="1">this.variables["${"+inputName+"}"] = input.Value</span>
        }

        <span class="cov8" title="1">return simplejson.NewFromAny(this.evalObject(this.template)), nil</span>
}

func (this *DashTemplateEvaluator) evalValue(source *simplejson.Json) interface{} <span class="cov8" title="1">{

        sourceValue := source.Interface()

        switch v := sourceValue.(type) </span>{
        case string:<span class="cov8" title="1">
                interpolated := this.varRegex.ReplaceAllStringFunc(v, func(match string) string </span><span class="cov8" title="1">{
                        if replacement, exists := this.variables[match]; exists </span><span class="cov8" title="1">{
                                return replacement
                        }</span><span class="cov0" title="0"> else {
                                return match
                        }</span>
                })
                <span class="cov8" title="1">return interpolated</span>
        case bool:<span class="cov8" title="1">
                return v</span>
        case json.Number:<span class="cov8" title="1">
                return v</span>
        case map[string]interface{}:<span class="cov8" title="1">
                return this.evalObject(source)</span>
        case []interface{}:<span class="cov8" title="1">
                array := make([]interface{}, 0)
                for _, item := range v </span><span class="cov8" title="1">{
                        array = append(array, this.evalValue(simplejson.NewFromAny(item)))
                }</span>
                <span class="cov8" title="1">return array</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (this *DashTemplateEvaluator) evalObject(source *simplejson.Json) interface{} <span class="cov8" title="1">{
        result := make(map[string]interface{})

        for key, value := range source.MustMap() </span><span class="cov8" title="1">{
                if key == "__inputs" </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">result[key] = this.evalValue(simplejson.NewFromAny(value))</span>
        }

        <span class="cov8" title="1">return result</span>
}
</pre>
		
		<pre class="file" id="file99" style="display: none">package plugins

import (
        "os"
        "path/filepath"

        "github.com/grafana/grafana/pkg/bus"
        "github.com/grafana/grafana/pkg/components/simplejson"
        m "github.com/grafana/grafana/pkg/models"
)

type PluginDashboardInfoDTO struct {
        PluginId         string `json:"pluginId"`
        Title            string `json:"title"`
        Imported         bool   `json:"imported"`
        ImportedUri      string `json:"importedUri"`
        Slug             string `json:"slug"`
        ImportedRevision int64  `json:"importedRevision"`
        Revision         int64  `json:"revision"`
        Description      string `json:"description"`
        Path             string `json:"path"`
        Removed          bool   `json:"removed"`
}

func GetPluginDashboards(orgId int64, pluginId string) ([]*PluginDashboardInfoDTO, error) <span class="cov8" title="1">{
        plugin, exists := Plugins[pluginId]

        if !exists </span><span class="cov0" title="0">{
                return nil, PluginNotFoundError{pluginId}
        }</span>

        <span class="cov8" title="1">result := make([]*PluginDashboardInfoDTO, 0)

        // load current dashboards
        query := m.GetDashboardsByPluginIdQuery{OrgId: orgId, PluginId: pluginId}
        if err := bus.Dispatch(&amp;query); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">existingMatches := make(map[int64]bool)

        for _, include := range plugin.Includes </span><span class="cov8" title="1">{
                if include.Type != PluginTypeDashboard </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">res := &amp;PluginDashboardInfoDTO{}
                var dashboard *m.Dashboard
                var err error

                if dashboard, err = loadPluginDashboard(plugin.Id, include.Path); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">res.Path = include.Path
                res.PluginId = plugin.Id
                res.Title = dashboard.Title
                res.Revision = dashboard.Data.Get("revision").MustInt64(1)

                // find existing dashboard
                for _, existingDash := range query.Result </span><span class="cov8" title="1">{
                        if existingDash.Slug == dashboard.Slug </span><span class="cov8" title="1">{
                                res.Imported = true
                                res.ImportedUri = "db/" + existingDash.Slug
                                res.ImportedRevision = existingDash.Data.Get("revision").MustInt64(1)
                                existingMatches[existingDash.Id] = true
                        }</span>
                }

                <span class="cov8" title="1">result = append(result, res)</span>
        }

        // find deleted dashboards
        <span class="cov8" title="1">for _, dash := range query.Result </span><span class="cov8" title="1">{
                if _, exists := existingMatches[dash.Id]; !exists </span><span class="cov0" title="0">{
                        result = append(result, &amp;PluginDashboardInfoDTO{
                                Slug:    dash.Slug,
                                Removed: true,
                        })
                }</span>
        }

        <span class="cov8" title="1">return result, nil</span>
}

func loadPluginDashboard(pluginId, path string) (*m.Dashboard, error) <span class="cov8" title="1">{
        plugin, exists := Plugins[pluginId]

        if !exists </span><span class="cov0" title="0">{
                return nil, PluginNotFoundError{pluginId}
        }</span>

        <span class="cov8" title="1">dashboardFilePath := filepath.Join(plugin.PluginDir, path)
        reader, err := os.Open(dashboardFilePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">defer reader.Close()

        data, err := simplejson.NewFromReader(reader)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return m.NewDashboardFromJson(data), nil</span>
}
</pre>
		
		<pre class="file" id="file100" style="display: none">package plugins

import (
        "time"

        "github.com/grafana/grafana/pkg/bus"
        m "github.com/grafana/grafana/pkg/models"
)

func init() <span class="cov8" title="1">{
        bus.AddEventListener(handlePluginStateChanged)
}</span>

func updateAppDashboards() <span class="cov8" title="1">{
        time.Sleep(time.Second * 5)

        plog.Debug("Looking for App Dashboard Updates")

        query := m.GetPluginSettingsQuery{OrgId: 0}

        if err := bus.Dispatch(&amp;query); err != nil </span><span class="cov0" title="0">{
                plog.Error("Failed to get all plugin settings", "error", err)
                return
        }</span>

        <span class="cov0" title="0">for _, pluginSetting := range query.Result </span><span class="cov0" title="0">{
                // ignore disabled plugins
                if !pluginSetting.Enabled </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">if pluginDef, exist := Plugins[pluginSetting.PluginId]; exist </span><span class="cov0" title="0">{
                        if pluginDef.Info.Version != pluginSetting.PluginVersion </span><span class="cov0" title="0">{
                                syncPluginDashboards(pluginDef, pluginSetting.OrgId)
                        }</span>
                }
        }
}

func autoUpdateAppDashboard(pluginDashInfo *PluginDashboardInfoDTO, orgId int64) error <span class="cov0" title="0">{
        if dash, err := loadPluginDashboard(pluginDashInfo.PluginId, pluginDashInfo.Path); err != nil </span><span class="cov0" title="0">{
                return err
        }</span><span class="cov0" title="0"> else {
                plog.Info("Auto updating App dashboard", "dashboard", dash.Title, "newRev", pluginDashInfo.Revision, "oldRev", pluginDashInfo.ImportedRevision)
                updateCmd := ImportDashboardCommand{
                        OrgId:     orgId,
                        PluginId:  pluginDashInfo.PluginId,
                        Overwrite: true,
                        Dashboard: dash.Data,
                        UserId:    0,
                        Path:      pluginDashInfo.Path,
                }

                if err := bus.Dispatch(&amp;updateCmd); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func syncPluginDashboards(pluginDef *PluginBase, orgId int64) <span class="cov0" title="0">{
        plog.Info("Syncing plugin dashboards to DB", "pluginId", pluginDef.Id)

        // Get plugin dashboards
        dashboards, err := GetPluginDashboards(orgId, pluginDef.Id)

        if err != nil </span><span class="cov0" title="0">{
                plog.Error("Failed to load app dashboards", "error", err)
                return
        }</span>

        // Update dashboards with updated revisions
        <span class="cov0" title="0">for _, dash := range dashboards </span><span class="cov0" title="0">{
                // remove removed ones
                if dash.Removed </span><span class="cov0" title="0">{
                        plog.Info("Deleting plugin dashboard", "pluginId", pluginDef.Id, "dashboard", dash.Slug)

                        deleteCmd := m.DeleteDashboardCommand{OrgId: orgId, Slug: dash.Slug}
                        if err := bus.Dispatch(&amp;deleteCmd); err != nil </span><span class="cov0" title="0">{
                                plog.Error("Failed to auto update app dashboard", "pluginId", pluginDef.Id, "error", err)
                                return
                        }</span>

                        <span class="cov0" title="0">continue</span>
                }

                // update updated ones
                <span class="cov0" title="0">if dash.ImportedRevision != dash.Revision </span><span class="cov0" title="0">{
                        if err := autoUpdateAppDashboard(dash, orgId); err != nil </span><span class="cov0" title="0">{
                                plog.Error("Failed to auto update app dashboard", "pluginId", pluginDef.Id, "error", err)
                                return
                        }</span>
                }
        }

        // update version in plugin_setting table to mark that we have processed the update
        <span class="cov0" title="0">query := m.GetPluginSettingByIdQuery{PluginId: pluginDef.Id, OrgId: orgId}
        if err := bus.Dispatch(&amp;query); err != nil </span><span class="cov0" title="0">{
                plog.Error("Failed to read plugin setting by id", "error", err)
                return
        }</span>

        <span class="cov0" title="0">appSetting := query.Result
        cmd := m.UpdatePluginSettingVersionCmd{
                OrgId:         appSetting.OrgId,
                PluginId:      appSetting.PluginId,
                PluginVersion: pluginDef.Info.Version,
        }

        if err := bus.Dispatch(&amp;cmd); err != nil </span><span class="cov0" title="0">{
                plog.Error("Failed to update plugin setting version", "error", err)
        }</span>
}

func handlePluginStateChanged(event *m.PluginStateChangedEvent) error <span class="cov0" title="0">{
        plog.Info("Plugin state changed", "pluginId", event.PluginId, "enabled", event.Enabled)

        if event.Enabled </span><span class="cov0" title="0">{
                syncPluginDashboards(Plugins[event.PluginId], event.OrgId)
        }</span><span class="cov0" title="0"> else {
                query := m.GetDashboardsByPluginIdQuery{PluginId: event.PluginId, OrgId: event.OrgId}

                if err := bus.Dispatch(&amp;query); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span><span class="cov0" title="0"> else {
                        for _, dash := range query.Result </span><span class="cov0" title="0">{
                                deleteCmd := m.DeleteDashboardCommand{OrgId: dash.OrgId, Slug: dash.Slug}

                                plog.Info("Deleting plugin dashboard", "pluginId", event.PluginId, "dashboard", dash.Slug)

                                if err := bus.Dispatch(&amp;deleteCmd); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file101" style="display: none">package plugins

import "encoding/json"

type DataSourcePlugin struct {
        FrontendPluginBase
        Annotations bool   `json:"annotations"`
        Metrics     bool   `json:"metrics"`
        Alerting    bool   `json:"alerting"`
        BuiltIn     bool   `json:"builtIn"`
        Mixed       bool   `json:"mixed"`
        App         string `json:"app"`
}

func (p *DataSourcePlugin) Load(decoder *json.Decoder, pluginDir string) error <span class="cov8" title="1">{
        if err := decoder.Decode(&amp;p); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if err := p.registerPlugin(pluginDir); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">DataSources[p.Id] = p
        return nil</span>
}
</pre>
		
		<pre class="file" id="file102" style="display: none">package plugins

import (
        "net/url"
        "path"
        "strings"

        "github.com/grafana/grafana/pkg/setting"
        "github.com/grafana/grafana/pkg/util"
)

type FrontendPluginBase struct {
        PluginBase
}

func (fp *FrontendPluginBase) initFrontendPlugin() <span class="cov8" title="1">{
        if isExternalPlugin(fp.PluginDir) </span><span class="cov8" title="1">{
                StaticRoutes = append(StaticRoutes, &amp;PluginStaticRoute{
                        Directory: fp.PluginDir,
                        PluginId:  fp.Id,
                })
        }</span>

        <span class="cov8" title="1">fp.handleModuleDefaults()

        fp.Info.Logos.Small = getPluginLogoUrl(fp.Type, fp.Info.Logos.Small, fp.BaseUrl)
        fp.Info.Logos.Large = getPluginLogoUrl(fp.Type, fp.Info.Logos.Large, fp.BaseUrl)

        for i := 0; i &lt; len(fp.Info.Screenshots); i++ </span><span class="cov8" title="1">{
                fp.Info.Screenshots[i].Path = evalRelativePluginUrlPath(fp.Info.Screenshots[i].Path, fp.BaseUrl)
        }</span>
}

func getPluginLogoUrl(pluginType, path, baseUrl string) string <span class="cov8" title="1">{
        if path == "" </span><span class="cov8" title="1">{
                return "public/img/icn-" + pluginType + ".svg"
        }</span>

        <span class="cov8" title="1">return evalRelativePluginUrlPath(path, baseUrl)</span>
}

func (fp *FrontendPluginBase) setPathsBasedOnApp(app *AppPlugin) <span class="cov8" title="1">{
        appSubPath := strings.Replace(fp.PluginDir, app.PluginDir, "", 1)
        fp.IncludedInAppId = app.Id
        fp.BaseUrl = app.BaseUrl

        if isExternalPlugin(app.PluginDir) </span><span class="cov0" title="0">{
                fp.Module = util.JoinUrlFragments("plugins/"+app.Id, appSubPath) + "/module"
        }</span><span class="cov8" title="1"> else {
                fp.Module = util.JoinUrlFragments("app/plugins/app/"+app.Id, appSubPath) + "/module"
        }</span>
}

func (fp *FrontendPluginBase) handleModuleDefaults() <span class="cov8" title="1">{

        if isExternalPlugin(fp.PluginDir) </span><span class="cov8" title="1">{
                fp.Module = path.Join("plugins", fp.Id, "module")
                fp.BaseUrl = path.Join("public/plugins", fp.Id)
                return
        }</span>

        <span class="cov8" title="1">fp.IsCorePlugin = true
        fp.Module = path.Join("app/plugins", fp.Type, fp.Id, "module")
        fp.BaseUrl = path.Join("public/app/plugins", fp.Type, fp.Id)</span>
}

func isExternalPlugin(pluginDir string) bool <span class="cov8" title="1">{
        return !strings.Contains(pluginDir, setting.StaticRootPath)
}</span>

func evalRelativePluginUrlPath(pathStr string, baseUrl string) string <span class="cov8" title="1">{
        if pathStr == "" </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov8" title="1">u, _ := url.Parse(pathStr)
        if u.IsAbs() </span><span class="cov0" title="0">{
                return pathStr
        }</span>
        <span class="cov8" title="1">return path.Join(baseUrl, pathStr)</span>
}
</pre>
		
		<pre class="file" id="file103" style="display: none">package plugins

import (
        "encoding/json"
        "errors"
        "fmt"
        "strings"

        m "github.com/grafana/grafana/pkg/models"
        "github.com/grafana/grafana/pkg/setting"
)

var (
        PluginTypeApp        = "app"
        PluginTypeDatasource = "datasource"
        PluginTypePanel      = "panel"
        PluginTypeDashboard  = "dashboard"
)

type PluginNotFoundError struct {
        PluginId string
}

func (e PluginNotFoundError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("Plugin with id %s not found", e.PluginId)
}</span>

type PluginLoader interface {
        Load(decoder *json.Decoder, pluginDir string) error
}

type PluginBase struct {
        Type         string             `json:"type"`
        Name         string             `json:"name"`
        Id           string             `json:"id"`
        Info         PluginInfo         `json:"info"`
        Dependencies PluginDependencies `json:"dependencies"`
        Includes     []*PluginInclude   `json:"includes"`
        Module       string             `json:"module"`
        BaseUrl      string             `json:"baseUrl"`
        HideFromList bool               `json:"hideFromList"`

        IncludedInAppId string `json:"-"`
        PluginDir       string `json:"-"`
        DefaultNavUrl   string `json:"-"`
        IsCorePlugin    bool   `json:"-"`

        GrafanaNetVersion   string `json:"-"`
        GrafanaNetHasUpdate bool   `json:"-"`

        // cache for readme file contents
        Readme []byte `json:"-"`
}

func (pb *PluginBase) registerPlugin(pluginDir string) error <span class="cov8" title="1">{
        if _, exists := Plugins[pb.Id]; exists </span><span class="cov0" title="0">{
                return errors.New("Plugin with same id already exists")
        }</span>

        <span class="cov8" title="1">if !strings.HasPrefix(pluginDir, setting.StaticRootPath) </span><span class="cov8" title="1">{
                plog.Info("Registering plugin", "name", pb.Name)
        }</span>

        <span class="cov8" title="1">if len(pb.Dependencies.Plugins) == 0 </span><span class="cov8" title="1">{
                pb.Dependencies.Plugins = []PluginDependencyItem{}
        }</span>

        <span class="cov8" title="1">if pb.Dependencies.GrafanaVersion == "" </span><span class="cov8" title="1">{
                pb.Dependencies.GrafanaVersion = "*"
        }</span>

        <span class="cov8" title="1">for _, include := range pb.Includes </span><span class="cov8" title="1">{
                if include.Role == "" </span><span class="cov8" title="1">{
                        include.Role = m.RoleType(m.ROLE_VIEWER)
                }</span>
        }

        <span class="cov8" title="1">pb.PluginDir = pluginDir
        Plugins[pb.Id] = pb
        return nil</span>
}

type PluginDependencies struct {
        GrafanaVersion string                 `json:"grafanaVersion"`
        Plugins        []PluginDependencyItem `json:"plugins"`
}

type PluginInclude struct {
        Name       string     `json:"name"`
        Path       string     `json:"path"`
        Type       string     `json:"type"`
        Component  string     `json:"component"`
        Role       m.RoleType `json:"role"`
        AddToNav   bool       `json:"addToNav"`
        DefaultNav bool       `json:"defaultNav"`
        Slug       string     `json:"slug"`

        Id string `json:"-"`
}

type PluginDependencyItem struct {
        Type    string `json:"type"`
        Id      string `json:"id"`
        Name    string `json:"name"`
        Version string `json:"version"`
}

type PluginInfo struct {
        Author      PluginInfoLink      `json:"author"`
        Description string              `json:"description"`
        Links       []PluginInfoLink    `json:"links"`
        Logos       PluginLogos         `json:"logos"`
        Screenshots []PluginScreenshots `json:"screenshots"`
        Version     string              `json:"version"`
        Updated     string              `json:"updated"`
}

type PluginInfoLink struct {
        Name string `json:"name"`
        Url  string `json:"url"`
}

type PluginLogos struct {
        Small string `json:"small"`
        Large string `json:"large"`
}

type PluginScreenshots struct {
        Path string `json:"path"`
        Name string `json:"name"`
}

type PluginStaticRoute struct {
        Directory string
        PluginId  string
}

type EnabledPlugins struct {
        Panels      []*PanelPlugin
        DataSources map[string]*DataSourcePlugin
        Apps        []*AppPlugin
}

func NewEnabledPlugins() EnabledPlugins <span class="cov0" title="0">{
        return EnabledPlugins{
                Panels:      make([]*PanelPlugin, 0),
                DataSources: make(map[string]*DataSourcePlugin),
                Apps:        make([]*AppPlugin, 0),
        }
}</span>
</pre>
		
		<pre class="file" id="file104" style="display: none">package plugins

import "encoding/json"

type PanelPlugin struct {
        FrontendPluginBase
}

func (p *PanelPlugin) Load(decoder *json.Decoder, pluginDir string) error <span class="cov8" title="1">{
        if err := decoder.Decode(&amp;p); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if err := p.registerPlugin(pluginDir); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">Panels[p.Id] = p
        return nil</span>
}
</pre>
		
		<pre class="file" id="file105" style="display: none">package plugins

import (
        "encoding/json"
        "errors"
        "io/ioutil"
        "os"
        "path"
        "path/filepath"
        "reflect"
        "strings"

        "github.com/grafana/grafana/pkg/log"
        "github.com/grafana/grafana/pkg/setting"
        "github.com/grafana/grafana/pkg/util"
)

var (
        DataSources  map[string]*DataSourcePlugin
        Panels       map[string]*PanelPlugin
        StaticRoutes []*PluginStaticRoute
        Apps         map[string]*AppPlugin
        Plugins      map[string]*PluginBase
        PluginTypes  map[string]interface{}

        GrafanaLatestVersion string
        GrafanaHasUpdate     bool
        plog                 log.Logger
)

type PluginScanner struct {
        pluginPath string
        errors     []error
}

func Init() error <span class="cov8" title="1">{
        plog = log.New("plugins")

        DataSources = make(map[string]*DataSourcePlugin)
        StaticRoutes = make([]*PluginStaticRoute, 0)
        Panels = make(map[string]*PanelPlugin)
        Apps = make(map[string]*AppPlugin)
        Plugins = make(map[string]*PluginBase)
        PluginTypes = map[string]interface{}{
                "panel":      PanelPlugin{},
                "datasource": DataSourcePlugin{},
                "app":        AppPlugin{},
        }

        plog.Info("Starting plugin search")
        scan(path.Join(setting.StaticRootPath, "app/plugins"))

        // check if plugins dir exists
        if _, err := os.Stat(setting.PluginsPath); os.IsNotExist(err) </span><span class="cov8" title="1">{
                plog.Warn("Plugin dir does not exist", "dir", setting.PluginsPath)
                if err = os.MkdirAll(setting.PluginsPath, os.ModePerm); err != nil </span><span class="cov8" title="1">{
                        plog.Warn("Failed to create plugin dir", "dir", setting.PluginsPath, "error", err)
                }</span><span class="cov0" title="0"> else {
                        plog.Info("Plugin dir created", "dir", setting.PluginsPath)
                        scan(setting.PluginsPath)
                }</span>
        }<span class="cov0" title="0"> else {
                scan(setting.PluginsPath)
        }</span>

        // check plugin paths defined in config
        <span class="cov8" title="1">checkPluginPaths()

        for _, panel := range Panels </span><span class="cov8" title="1">{
                panel.initFrontendPlugin()
        }</span>
        <span class="cov8" title="1">for _, panel := range DataSources </span><span class="cov8" title="1">{
                panel.initFrontendPlugin()
        }</span>
        <span class="cov8" title="1">for _, app := range Apps </span><span class="cov8" title="1">{
                app.initApp()
        }</span>

        <span class="cov8" title="1">go StartPluginUpdateChecker()
        go updateAppDashboards()

        return nil</span>
}

func checkPluginPaths() error <span class="cov8" title="1">{
        for _, section := range setting.Cfg.Sections() </span><span class="cov8" title="1">{
                if strings.HasPrefix(section.Name(), "plugin.") </span><span class="cov8" title="1">{
                        path := section.Key("path").String()
                        if path != "" </span><span class="cov8" title="1">{
                                scan(path)
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

func scan(pluginDir string) error <span class="cov8" title="1">{
        scanner := &amp;PluginScanner{
                pluginPath: pluginDir,
        }

        if err := util.Walk(pluginDir, true, true, scanner.walker); err != nil </span><span class="cov8" title="1">{
                if pluginDir != "data/plugins" </span><span class="cov8" title="1">{
                        log.Warn("Could not scan dir \"%v\" error: %s", pluginDir, err)
                }</span>
                <span class="cov8" title="1">return err</span>
        }

        <span class="cov8" title="1">if len(scanner.errors) &gt; 0 </span><span class="cov0" title="0">{
                return errors.New("Some plugins failed to load")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (scanner *PluginScanner) walker(currentPath string, f os.FileInfo, err error) error <span class="cov8" title="1">{
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if f.Name() == "node_modules" </span><span class="cov0" title="0">{
                return util.WalkSkipDir
        }</span>

        <span class="cov8" title="1">if f.IsDir() </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">if f.Name() == "plugin.json" </span><span class="cov8" title="1">{
                err := scanner.loadPluginJson(currentPath)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error(3, "Plugins: Failed to load plugin json file: %v,  err: %v", currentPath, err)
                        scanner.errors = append(scanner.errors, err)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (scanner *PluginScanner) loadPluginJson(pluginJsonFilePath string) error <span class="cov8" title="1">{
        currentDir := filepath.Dir(pluginJsonFilePath)
        reader, err := os.Open(pluginJsonFilePath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">defer reader.Close()

        jsonParser := json.NewDecoder(reader)
        pluginCommon := PluginBase{}
        if err := jsonParser.Decode(&amp;pluginCommon); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if pluginCommon.Id == "" || pluginCommon.Type == "" </span><span class="cov0" title="0">{
                return errors.New("Did not find type and id property in plugin.json")
        }</span>

        <span class="cov8" title="1">var loader PluginLoader
        if pluginGoType, exists := PluginTypes[pluginCommon.Type]; !exists </span><span class="cov0" title="0">{
                return errors.New("Unknown plugin type " + pluginCommon.Type)
        }</span><span class="cov8" title="1"> else {
                loader = reflect.New(reflect.TypeOf(pluginGoType)).Interface().(PluginLoader)
        }</span>

        <span class="cov8" title="1">reader.Seek(0, 0)
        return loader.Load(jsonParser, currentDir)</span>
}

func GetPluginReadme(pluginId string) ([]byte, error) <span class="cov0" title="0">{
        plug, exists := Plugins[pluginId]
        if !exists </span><span class="cov0" title="0">{
                return nil, PluginNotFoundError{pluginId}
        }</span>

        <span class="cov0" title="0">if plug.Readme != nil </span><span class="cov0" title="0">{
                return plug.Readme, nil
        }</span>

        <span class="cov0" title="0">readmePath := filepath.Join(plug.PluginDir, "README.md")
        if _, err := os.Stat(readmePath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                readmePath = filepath.Join(plug.PluginDir, "readme.md")
        }</span>

        <span class="cov0" title="0">if _, err := os.Stat(readmePath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                plug.Readme = make([]byte, 0)
                return plug.Readme, nil
        }</span>

        <span class="cov0" title="0">if readmeBytes, err := ioutil.ReadFile(readmePath); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span><span class="cov0" title="0"> else {
                plug.Readme = readmeBytes
                return plug.Readme, nil
        }</span>
}
</pre>
		
		<pre class="file" id="file106" style="display: none">package plugins

import (
        "github.com/grafana/grafana/pkg/bus"
        m "github.com/grafana/grafana/pkg/models"
)

func GetPluginSettings(orgId int64) (map[string]*m.PluginSettingInfoDTO, error) <span class="cov0" title="0">{
        query := m.GetPluginSettingsQuery{OrgId: orgId}

        if err := bus.Dispatch(&amp;query); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">pluginMap := make(map[string]*m.PluginSettingInfoDTO)
        for _, plug := range query.Result </span><span class="cov0" title="0">{
                pluginMap[plug.PluginId] = plug
        }</span>

        <span class="cov0" title="0">for _, pluginDef := range Plugins </span><span class="cov0" title="0">{
                // ignore entries that exists
                if _, ok := pluginMap[pluginDef.Id]; ok </span><span class="cov0" title="0">{
                        continue</span>
                }

                // default to enabled true
                <span class="cov0" title="0">opt := &amp;m.PluginSettingInfoDTO{
                        PluginId: pluginDef.Id,
                        OrgId:    orgId,
                        Enabled:  true,
                }

                // apps are disabled by default
                if pluginDef.Type == PluginTypeApp </span><span class="cov0" title="0">{
                        opt.Enabled = false
                }</span>

                // if it's included in app check app settings
                <span class="cov0" title="0">if pluginDef.IncludedInAppId != "" </span><span class="cov0" title="0">{
                        // app componets are by default disabled
                        opt.Enabled = false

                        if appSettings, ok := pluginMap[pluginDef.IncludedInAppId]; ok </span><span class="cov0" title="0">{
                                opt.Enabled = appSettings.Enabled
                        }</span>
                }

                <span class="cov0" title="0">pluginMap[pluginDef.Id] = opt</span>
        }

        <span class="cov0" title="0">return pluginMap, nil</span>
}

func GetEnabledPlugins(orgId int64) (*EnabledPlugins, error) <span class="cov0" title="0">{
        enabledPlugins := NewEnabledPlugins()
        pluginSettingMap, err := GetPluginSettings(orgId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">isPluginEnabled := func(pluginId string) bool </span><span class="cov0" title="0">{
                _, ok := pluginSettingMap[pluginId]
                return ok
        }</span>

        <span class="cov0" title="0">for pluginId, app := range Apps </span><span class="cov0" title="0">{
                if b, ok := pluginSettingMap[pluginId]; ok </span><span class="cov0" title="0">{
                        app.Pinned = b.Pinned
                        enabledPlugins.Apps = append(enabledPlugins.Apps, app)
                }</span>
        }

        // add all plugins that are not part of an App.
        <span class="cov0" title="0">for dsId, ds := range DataSources </span><span class="cov0" title="0">{
                if isPluginEnabled(ds.Id) </span><span class="cov0" title="0">{
                        enabledPlugins.DataSources[dsId] = ds
                }</span>
        }

        <span class="cov0" title="0">for _, panel := range Panels </span><span class="cov0" title="0">{
                if isPluginEnabled(panel.Id) </span><span class="cov0" title="0">{
                        enabledPlugins.Panels = append(enabledPlugins.Panels, panel)
                }</span>
        }

        <span class="cov0" title="0">return &amp;enabledPlugins, nil</span>
}
</pre>
		
		<pre class="file" id="file107" style="display: none">package plugins

import (
        "encoding/json"
        "io/ioutil"
        "net/http"
        "strings"
        "time"

        "github.com/grafana/grafana/pkg/log"
        "github.com/grafana/grafana/pkg/setting"
        "github.com/hashicorp/go-version"
)

var (
        httpClient http.Client = http.Client{Timeout: time.Duration(10 * time.Second)}
)

type GrafanaNetPlugin struct {
        Slug    string `json:"slug"`
        Version string `json:"version"`
}

type GithubLatest struct {
        Stable  string `json:"stable"`
        Testing string `json:"testing"`
}

func StartPluginUpdateChecker() <span class="cov8" title="1">{
        if !setting.CheckForUpdates </span><span class="cov8" title="1">{
                return
        }</span>

        // do one check directly
        <span class="cov0" title="0">go checkForUpdates()

        ticker := time.NewTicker(time.Minute * 10)
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ticker.C:<span class="cov0" title="0">
                        checkForUpdates()</span>
                }
        }
}

func getAllExternalPluginSlugs() string <span class="cov0" title="0">{
        var result []string
        for _, plug := range Plugins </span><span class="cov0" title="0">{
                if plug.IsCorePlugin </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">result = append(result, plug.Id)</span>
        }

        <span class="cov0" title="0">return strings.Join(result, ",")</span>
}

func checkForUpdates() <span class="cov0" title="0">{
        log.Trace("Checking for updates")

        pluginSlugs := getAllExternalPluginSlugs()
        resp, err := httpClient.Get("https://grafana.net/api/plugins/versioncheck?slugIn=" + pluginSlugs + "&amp;grafanaVersion=" + setting.BuildVersion)

        if err != nil </span><span class="cov0" title="0">{
                log.Trace("Failed to get plugins repo from grafana.net, %v", err.Error())
                return
        }</span>

        <span class="cov0" title="0">defer resp.Body.Close()

        body, err := ioutil.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                log.Trace("Update check failed, reading response from grafana.net, %v", err.Error())
                return
        }</span>

        <span class="cov0" title="0">gNetPlugins := []GrafanaNetPlugin{}
        err = json.Unmarshal(body, &amp;gNetPlugins)
        if err != nil </span><span class="cov0" title="0">{
                log.Trace("Failed to unmarshal plugin repo, reading response from grafana.net, %v", err.Error())
                return
        }</span>

        <span class="cov0" title="0">for _, plug := range Plugins </span><span class="cov0" title="0">{
                for _, gplug := range gNetPlugins </span><span class="cov0" title="0">{
                        if gplug.Slug == plug.Id </span><span class="cov0" title="0">{
                                plug.GrafanaNetVersion = gplug.Version

                                plugVersion, err1 := version.NewVersion(plug.Info.Version)
                                gplugVersion, err2 := version.NewVersion(gplug.Version)

                                if err1 != nil || err2 != nil </span><span class="cov0" title="0">{
                                        plug.GrafanaNetHasUpdate = plug.Info.Version != plug.GrafanaNetVersion
                                }</span><span class="cov0" title="0"> else {
                                        plug.GrafanaNetHasUpdate = plugVersion.LessThan(gplugVersion)
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">resp2, err := httpClient.Get("https://raw.githubusercontent.com/grafana/grafana/master/latest.json")
        if err != nil </span><span class="cov0" title="0">{
                log.Trace("Failed to get latest.json repo from github: %v", err.Error())
                return
        }</span>

        <span class="cov0" title="0">defer resp2.Body.Close()
        body, err = ioutil.ReadAll(resp2.Body)
        if err != nil </span><span class="cov0" title="0">{
                log.Trace("Update check failed, reading response from github.com, %v", err.Error())
                return
        }</span>

        <span class="cov0" title="0">var githubLatest GithubLatest
        err = json.Unmarshal(body, &amp;githubLatest)
        if err != nil </span><span class="cov0" title="0">{
                log.Trace("Failed to unmarshal github latest, reading response from github: %v", err.Error())
                return
        }</span>

        <span class="cov0" title="0">if strings.Contains(setting.BuildVersion, "-") </span><span class="cov0" title="0">{
                GrafanaLatestVersion = githubLatest.Testing
                GrafanaHasUpdate = !strings.HasPrefix(setting.BuildVersion, githubLatest.Testing)
        }</span><span class="cov0" title="0"> else {
                GrafanaLatestVersion = githubLatest.Stable
                GrafanaHasUpdate = githubLatest.Stable != setting.BuildVersion
        }</span>

        <span class="cov0" title="0">currVersion, err1 := version.NewVersion(setting.BuildVersion)
        latestVersion, err2 := version.NewVersion(GrafanaLatestVersion)

        if err1 == nil &amp;&amp; err2 == nil </span><span class="cov0" title="0">{
                GrafanaHasUpdate = currVersion.LessThan(latestVersion)
        }</span>
}
</pre>
		
		<pre class="file" id="file108" style="display: none">package alerting

import (
        "github.com/grafana/grafana/pkg/bus"
        m "github.com/grafana/grafana/pkg/models"
)

type UpdateDashboardAlertsCommand struct {
        UserId    int64
        OrgId     int64
        Dashboard *m.Dashboard
}

type ValidateDashboardAlertsCommand struct {
        UserId    int64
        OrgId     int64
        Dashboard *m.Dashboard
}

func init() <span class="cov8" title="1">{
        bus.AddHandler("alerting", updateDashboardAlerts)
        bus.AddHandler("alerting", validateDashboardAlerts)
}</span>

func validateDashboardAlerts(cmd *ValidateDashboardAlertsCommand) error <span class="cov0" title="0">{
        extractor := NewDashAlertExtractor(cmd.Dashboard, cmd.OrgId)

        if _, err := extractor.GetAlerts(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func updateDashboardAlerts(cmd *UpdateDashboardAlertsCommand) error <span class="cov0" title="0">{
        saveAlerts := m.SaveAlertsCommand{
                OrgId:       cmd.OrgId,
                UserId:      cmd.UserId,
                DashboardId: cmd.Dashboard.Id,
        }

        extractor := NewDashAlertExtractor(cmd.Dashboard, cmd.OrgId)

        if alerts, err := extractor.GetAlerts(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span><span class="cov0" title="0"> else {
                saveAlerts.Alerts = alerts
        }</span>

        <span class="cov0" title="0">if err := bus.Dispatch(&amp;saveAlerts); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file109" style="display: none">package conditions

import (
        "encoding/json"

        "github.com/grafana/grafana/pkg/components/null"
        "github.com/grafana/grafana/pkg/components/simplejson"
        "github.com/grafana/grafana/pkg/services/alerting"
)

var (
        defaultTypes []string = []string{"gt", "lt"}
        rangedTypes  []string = []string{"within_range", "outside_range"}
)

type AlertEvaluator interface {
        Eval(reducedValue null.Float) bool
}

type NoValueEvaluator struct{}

func (e *NoValueEvaluator) Eval(reducedValue null.Float) bool <span class="cov8" title="1">{
        return reducedValue.Valid == false
}</span>

type ThresholdEvaluator struct {
        Type      string
        Threshold float64
}

func newThresholdEvaluator(typ string, model *simplejson.Json) (*ThresholdEvaluator, error) <span class="cov8" title="1">{
        params := model.Get("params").MustArray()
        if len(params) == 0 </span><span class="cov0" title="0">{
                return nil, alerting.ValidationError{Reason: "Evaluator missing threshold parameter"}
        }</span>

        <span class="cov8" title="1">firstParam, ok := params[0].(json.Number)
        if !ok </span><span class="cov0" title="0">{
                return nil, alerting.ValidationError{Reason: "Evaluator has invalid parameter"}
        }</span>

        <span class="cov8" title="1">defaultEval := &amp;ThresholdEvaluator{Type: typ}
        defaultEval.Threshold, _ = firstParam.Float64()
        return defaultEval, nil</span>
}

func (e *ThresholdEvaluator) Eval(reducedValue null.Float) bool <span class="cov8" title="1">{
        if reducedValue.Valid == false </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">switch e.Type </span>{
        case "gt":<span class="cov8" title="1">
                return reducedValue.Float64 &gt; e.Threshold</span>
        case "lt":<span class="cov8" title="1">
                return reducedValue.Float64 &lt; e.Threshold</span>
        }

        <span class="cov0" title="0">return false</span>
}

type RangedEvaluator struct {
        Type  string
        Lower float64
        Upper float64
}

func newRangedEvaluator(typ string, model *simplejson.Json) (*RangedEvaluator, error) <span class="cov8" title="1">{
        params := model.Get("params").MustArray()
        if len(params) == 0 </span><span class="cov0" title="0">{
                return nil, alerting.ValidationError{Reason: "Evaluator missing threshold parameter"}
        }</span>

        <span class="cov8" title="1">firstParam, ok := params[0].(json.Number)
        if !ok </span><span class="cov0" title="0">{
                return nil, alerting.ValidationError{Reason: "Evaluator has invalid parameter"}
        }</span>

        <span class="cov8" title="1">secondParam, ok := params[1].(json.Number)
        if !ok </span><span class="cov0" title="0">{
                return nil, alerting.ValidationError{Reason: "Evaluator has invalid second parameter"}
        }</span>

        <span class="cov8" title="1">rangedEval := &amp;RangedEvaluator{Type: typ}
        rangedEval.Lower, _ = firstParam.Float64()
        rangedEval.Upper, _ = secondParam.Float64()
        return rangedEval, nil</span>
}

func (e *RangedEvaluator) Eval(reducedValue null.Float) bool <span class="cov8" title="1">{
        if reducedValue.Valid == false </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">floatValue := reducedValue.Float64

        switch e.Type </span>{
        case "within_range":<span class="cov8" title="1">
                return (e.Lower &lt; floatValue &amp;&amp; e.Upper &gt; floatValue) || (e.Upper &lt; floatValue &amp;&amp; e.Lower &gt; floatValue)</span>
        case "outside_range":<span class="cov8" title="1">
                return (e.Upper &lt; floatValue &amp;&amp; e.Lower &lt; floatValue) || (e.Upper &gt; floatValue &amp;&amp; e.Lower &gt; floatValue)</span>
        }

        <span class="cov0" title="0">return false</span>
}

func NewAlertEvaluator(model *simplejson.Json) (AlertEvaluator, error) <span class="cov8" title="1">{
        typ := model.Get("type").MustString()
        if typ == "" </span><span class="cov0" title="0">{
                return nil, alerting.ValidationError{Reason: "Evaluator missing type property"}
        }</span>

        <span class="cov8" title="1">if inSlice(typ, defaultTypes) </span><span class="cov8" title="1">{
                return newThresholdEvaluator(typ, model)
        }</span>

        <span class="cov8" title="1">if inSlice(typ, rangedTypes) </span><span class="cov8" title="1">{
                return newRangedEvaluator(typ, model)
        }</span>

        <span class="cov8" title="1">if typ == "no_value" </span><span class="cov8" title="1">{
                return &amp;NoValueEvaluator{}, nil
        }</span>

        <span class="cov0" title="0">return nil, alerting.ValidationError{Reason: "Evaluator invalid evaluator type: " + typ}</span>
}

func inSlice(a string, list []string) bool <span class="cov8" title="1">{
        for _, b := range list </span><span class="cov8" title="1">{
                if b == a </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file110" style="display: none">package conditions

import (
        "fmt"
        "strings"
        "time"

        "github.com/grafana/grafana/pkg/bus"
        "github.com/grafana/grafana/pkg/components/null"
        "github.com/grafana/grafana/pkg/components/simplejson"
        m "github.com/grafana/grafana/pkg/models"
        "github.com/grafana/grafana/pkg/services/alerting"
        "github.com/grafana/grafana/pkg/tsdb"
)

func init() <span class="cov8" title="1">{
        alerting.RegisterCondition("query", func(model *simplejson.Json, index int) (alerting.Condition, error) </span><span class="cov0" title="0">{
                return NewQueryCondition(model, index)
        }</span>)
}

type QueryCondition struct {
        Index         int
        Query         AlertQuery
        Reducer       QueryReducer
        Evaluator     AlertEvaluator
        Operator      string
        HandleRequest tsdb.HandleRequestFunc
}

type AlertQuery struct {
        Model        *simplejson.Json
        DatasourceId int64
        From         string
        To           string
}

func (c *QueryCondition) Eval(context *alerting.EvalContext) (*alerting.ConditionResult, error) <span class="cov8" title="1">{
        timeRange := tsdb.NewTimeRange(c.Query.From, c.Query.To)

        seriesList, err := c.executeQuery(context, timeRange)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">emptySerieCount := 0
        evalMatchCount := 0
        var matches []*alerting.EvalMatch

        for _, series := range seriesList </span><span class="cov8" title="1">{
                reducedValue := c.Reducer.Reduce(series)
                evalMatch := c.Evaluator.Eval(reducedValue)

                if reducedValue.Valid == false </span><span class="cov8" title="1">{
                        emptySerieCount++
                }</span>

                <span class="cov8" title="1">if context.IsTestRun </span><span class="cov0" title="0">{
                        context.Logs = append(context.Logs, &amp;alerting.ResultLogEntry{
                                Message: fmt.Sprintf("Condition[%d]: Eval: %v, Metric: %s, Value: %s", c.Index, evalMatch, series.Name, reducedValue),
                        })
                }</span>

                <span class="cov8" title="1">if evalMatch </span><span class="cov8" title="1">{
                        evalMatchCount++

                        matches = append(matches, &amp;alerting.EvalMatch{
                                Metric: series.Name,
                                Value:  reducedValue,
                                Tags:   series.Tags,
                        })
                }</span>
        }

        // handle no series special case
        <span class="cov8" title="1">if len(seriesList) == 0 </span><span class="cov8" title="1">{
                // eval condition for null value
                evalMatch := c.Evaluator.Eval(null.FloatFromPtr(nil))

                if context.IsTestRun </span><span class="cov0" title="0">{
                        context.Logs = append(context.Logs, &amp;alerting.ResultLogEntry{
                                Message: fmt.Sprintf("Condition: Eval: %v, Query Returned No Series (reduced to null/no value)", evalMatch),
                        })
                }</span>

                <span class="cov8" title="1">if evalMatch </span><span class="cov8" title="1">{
                        evalMatchCount++
                        matches = append(matches, &amp;alerting.EvalMatch{Metric: "NoData", Value: null.FloatFromPtr(nil)})
                }</span>
        }

        <span class="cov8" title="1">return &amp;alerting.ConditionResult{
                Firing:      evalMatchCount &gt; 0,
                NoDataFound: emptySerieCount == len(seriesList),
                Operator:    c.Operator,
                EvalMatches: matches,
        }, nil</span>
}

func (c *QueryCondition) executeQuery(context *alerting.EvalContext, timeRange *tsdb.TimeRange) (tsdb.TimeSeriesSlice, error) <span class="cov8" title="1">{
        getDsInfo := &amp;m.GetDataSourceByIdQuery{
                Id:    c.Query.DatasourceId,
                OrgId: context.Rule.OrgId,
        }

        if err := bus.Dispatch(getDsInfo); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Could not find datasource")
        }</span>

        <span class="cov8" title="1">req := c.getRequestForAlertRule(getDsInfo.Result, timeRange)
        result := make(tsdb.TimeSeriesSlice, 0)

        resp, err := c.HandleRequest(context.Ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("tsdb.HandleRequest() error %v", err)
        }</span>

        <span class="cov8" title="1">for _, v := range resp.Results </span><span class="cov8" title="1">{
                if v.Error != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("tsdb.HandleRequest() response error %v", v)
                }</span>

                <span class="cov8" title="1">result = append(result, v.Series...)

                if context.IsTestRun </span><span class="cov0" title="0">{
                        context.Logs = append(context.Logs, &amp;alerting.ResultLogEntry{
                                Message: fmt.Sprintf("Condition[%d]: Query Result", c.Index),
                                Data:    v.Series,
                        })
                }</span>
        }

        <span class="cov8" title="1">return result, nil</span>
}

func (c *QueryCondition) getRequestForAlertRule(datasource *m.DataSource, timeRange *tsdb.TimeRange) *tsdb.Request <span class="cov8" title="1">{
        req := &amp;tsdb.Request{
                TimeRange: timeRange,
                Queries: []*tsdb.Query{
                        {
                                RefId:      "A",
                                Model:      c.Query.Model,
                                DataSource: datasource,
                        },
                },
        }

        return req
}</span>

func NewQueryCondition(model *simplejson.Json, index int) (*QueryCondition, error) <span class="cov8" title="1">{
        condition := QueryCondition{}
        condition.Index = index
        condition.HandleRequest = tsdb.HandleRequest

        queryJson := model.Get("query")

        condition.Query.Model = queryJson.Get("model")
        condition.Query.From = queryJson.Get("params").MustArray()[1].(string)
        condition.Query.To = queryJson.Get("params").MustArray()[2].(string)

        if err := validateFromValue(condition.Query.From); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if err := validateToValue(condition.Query.To); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">condition.Query.DatasourceId = queryJson.Get("datasourceId").MustInt64()

        reducerJson := model.Get("reducer")
        condition.Reducer = NewSimpleReducer(reducerJson.Get("type").MustString())

        evaluatorJson := model.Get("evaluator")
        evaluator, err := NewAlertEvaluator(evaluatorJson)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">condition.Evaluator = evaluator

        operatorJson := model.Get("operator")
        operator := operatorJson.Get("type").MustString("and")
        condition.Operator = operator

        return &amp;condition, nil</span>
}

func validateFromValue(from string) error <span class="cov8" title="1">{
        fromRaw := strings.Replace(from, "now-", "", 1)

        _, err := time.ParseDuration("-" + fromRaw)
        return err
}</span>

func validateToValue(to string) error <span class="cov8" title="1">{
        if to == "now" </span><span class="cov8" title="1">{
                return nil
        }</span><span class="cov0" title="0"> else if strings.HasPrefix(to, "now-") </span><span class="cov0" title="0">{
                withoutNow := strings.Replace(to, "now-", "", 1)

                _, err := time.ParseDuration("-" + withoutNow)
                if err == nil </span><span class="cov0" title="0">{
                        return nil
                }</span>
        }

        <span class="cov0" title="0">_, err := time.ParseDuration(to)
        return err</span>
}
</pre>
		
		<pre class="file" id="file111" style="display: none">package conditions

import (
        "math"

        "sort"

        "github.com/grafana/grafana/pkg/components/null"
        "github.com/grafana/grafana/pkg/tsdb"
)

type QueryReducer interface {
        Reduce(timeSeries *tsdb.TimeSeries) null.Float
}

type SimpleReducer struct {
        Type string
}

func (s *SimpleReducer) Reduce(series *tsdb.TimeSeries) null.Float <span class="cov8" title="1">{
        if len(series.Points) == 0 </span><span class="cov8" title="1">{
                return null.FloatFromPtr(nil)
        }</span>

        <span class="cov8" title="1">value := float64(0)
        allNull := true

        switch s.Type </span>{
        case "avg":<span class="cov8" title="1">
                validPointsCount := 0
                for _, point := range series.Points </span><span class="cov8" title="1">{
                        if point[0].Valid </span><span class="cov8" title="1">{
                                value += point[0].Float64
                                validPointsCount += 1
                                allNull = false
                        }</span>
                }
                <span class="cov8" title="1">if validPointsCount &gt; 0 </span><span class="cov8" title="1">{
                        value = value / float64(validPointsCount)
                }</span>
        case "sum":<span class="cov8" title="1">
                for _, point := range series.Points </span><span class="cov8" title="1">{
                        if point[0].Valid </span><span class="cov8" title="1">{
                                value += point[0].Float64
                                allNull = false
                        }</span>
                }
        case "min":<span class="cov8" title="1">
                value = math.MaxFloat64
                for _, point := range series.Points </span><span class="cov8" title="1">{
                        if point[0].Valid </span><span class="cov8" title="1">{
                                allNull = false
                                if value &gt; point[0].Float64 </span><span class="cov8" title="1">{
                                        value = point[0].Float64
                                }</span>
                        }
                }
        case "max":<span class="cov8" title="1">
                value = -math.MaxFloat64
                for _, point := range series.Points </span><span class="cov8" title="1">{
                        if point[0].Valid </span><span class="cov8" title="1">{
                                allNull = false
                                if value &lt; point[0].Float64 </span><span class="cov8" title="1">{
                                        value = point[0].Float64
                                }</span>
                        }
                }
        case "count":<span class="cov8" title="1">
                value = float64(len(series.Points))
                allNull = false</span>
        case "last":<span class="cov8" title="1">
                points := series.Points
                for i := len(points) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                        if points[i][0].Valid </span><span class="cov8" title="1">{
                                value = points[i][0].Float64
                                allNull = false
                                break</span>
                        }
                }
        case "median":<span class="cov8" title="1">
                var values []float64
                for _, v := range series.Points </span><span class="cov8" title="1">{
                        if v[0].Valid </span><span class="cov8" title="1">{
                                allNull = false
                                values = append(values, v[0].Float64)
                        }</span>
                }
                <span class="cov8" title="1">if len(values) &gt;= 1 </span><span class="cov8" title="1">{
                        sort.Float64s(values)
                        length := len(values)
                        if length%2 == 1 </span><span class="cov8" title="1">{
                                value = values[(length-1)/2]
                        }</span><span class="cov8" title="1"> else {
                                value = (values[(length/2)-1] + values[length/2]) / 2
                        }</span>
                }
        }

        <span class="cov8" title="1">if allNull </span><span class="cov8" title="1">{
                return null.FloatFromPtr(nil)
        }</span>

        <span class="cov8" title="1">return null.FloatFrom(value)</span>
}

func NewSimpleReducer(typ string) *SimpleReducer <span class="cov8" title="1">{
        return &amp;SimpleReducer{Type: typ}
}</span>
</pre>
		
		<pre class="file" id="file112" style="display: none">package alerting

import (
        "context"
        "time"

        "github.com/benbjohnson/clock"
        "github.com/grafana/grafana/pkg/log"
        "golang.org/x/sync/errgroup"
)

type Engine struct {
        execQueue     chan *Job
        clock         clock.Clock
        ticker        *Ticker
        scheduler     Scheduler
        evalHandler   EvalHandler
        ruleReader    RuleReader
        log           log.Logger
        resultHandler ResultHandler
}

func NewEngine() *Engine <span class="cov0" title="0">{
        e := &amp;Engine{
                ticker:        NewTicker(time.Now(), time.Second*0, clock.New()),
                execQueue:     make(chan *Job, 1000),
                scheduler:     NewScheduler(),
                evalHandler:   NewEvalHandler(),
                ruleReader:    NewRuleReader(),
                log:           log.New("alerting.engine"),
                resultHandler: NewResultHandler(),
        }

        return e
}</span>

func (e *Engine) Run(ctx context.Context) error <span class="cov0" title="0">{
        e.log.Info("Initializing Alerting")

        alertGroup, ctx := errgroup.WithContext(ctx)

        alertGroup.Go(func() error </span><span class="cov0" title="0">{ return e.alertingTicker(ctx) }</span>)
        <span class="cov0" title="0">alertGroup.Go(func() error </span><span class="cov0" title="0">{ return e.runJobDispatcher(ctx) }</span>)

        <span class="cov0" title="0">err := alertGroup.Wait()

        e.log.Info("Stopped Alerting", "reason", err)
        return err</span>
}

func (e *Engine) alertingTicker(grafanaCtx context.Context) error <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                if err := recover(); err != nil </span><span class="cov0" title="0">{
                        e.log.Error("Scheduler Panic: stopping alertingTicker", "error", err, "stack", log.Stack(1))
                }</span>
        }()

        <span class="cov0" title="0">tickIndex := 0

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-grafanaCtx.Done():<span class="cov0" title="0">
                        return grafanaCtx.Err()</span>
                case tick := &lt;-e.ticker.C:<span class="cov0" title="0">
                        // TEMP SOLUTION update rules ever tenth tick
                        if tickIndex%10 == 0 </span><span class="cov0" title="0">{
                                e.scheduler.Update(e.ruleReader.Fetch())
                        }</span>

                        <span class="cov0" title="0">e.scheduler.Tick(tick, e.execQueue)
                        tickIndex++</span>
                }
        }
}

func (e *Engine) runJobDispatcher(grafanaCtx context.Context) error <span class="cov0" title="0">{
        dispatcherGroup, alertCtx := errgroup.WithContext(grafanaCtx)

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-grafanaCtx.Done():<span class="cov0" title="0">
                        return dispatcherGroup.Wait()</span>
                case job := &lt;-e.execQueue:<span class="cov0" title="0">
                        dispatcherGroup.Go(func() error </span><span class="cov0" title="0">{ return e.processJob(alertCtx, job) }</span>)
                }
        }
}

var (
        unfinishedWorkTimeout time.Duration = time.Second * 5
        alertTimeout          time.Duration = time.Second * 30
)

func (e *Engine) processJob(grafanaCtx context.Context, job *Job) error <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                if err := recover(); err != nil </span><span class="cov0" title="0">{
                        e.log.Error("Alert Panic", "error", err, "stack", log.Stack(1))
                }</span>
        }()

        <span class="cov0" title="0">alertCtx, cancelFn := context.WithTimeout(context.TODO(), alertTimeout)

        job.Running = true
        evalContext := NewEvalContext(alertCtx, job.Rule)

        done := make(chan struct{})

        go func() </span><span class="cov0" title="0">{
                defer func() </span><span class="cov0" title="0">{
                        if err := recover(); err != nil </span><span class="cov0" title="0">{
                                e.log.Error("Alert Panic", "error", err, "stack", log.Stack(1))
                                close(done)
                        }</span>
                }()

                <span class="cov0" title="0">e.evalHandler.Eval(evalContext)
                e.resultHandler.Handle(evalContext)
                close(done)</span>
        }()

        <span class="cov0" title="0">var err error = nil
        select </span>{
        case &lt;-grafanaCtx.Done():<span class="cov0" title="0">
                select </span>{
                case &lt;-time.After(unfinishedWorkTimeout):<span class="cov0" title="0">
                        cancelFn()
                        err = grafanaCtx.Err()</span>
                case &lt;-done:</span><span class="cov0" title="0">
                }
        case &lt;-done:</span><span class="cov0" title="0">
        }

        <span class="cov0" title="0">e.log.Debug("Job Execution completed", "timeMs", evalContext.GetDurationMs(), "alertId", evalContext.Rule.Id, "name", evalContext.Rule.Name, "firing", evalContext.Firing)
        job.Running = false
        cancelFn()
        return err</span>
}
</pre>
		
		<pre class="file" id="file113" style="display: none">package alerting

import (
        "context"
        "fmt"
        "time"

        "github.com/grafana/grafana/pkg/bus"
        "github.com/grafana/grafana/pkg/log"
        m "github.com/grafana/grafana/pkg/models"
        "github.com/grafana/grafana/pkg/setting"
)

type EvalContext struct {
        Firing          bool
        IsTestRun       bool
        EvalMatches     []*EvalMatch
        Logs            []*ResultLogEntry
        Error           error
        ConditionEvals  string
        StartTime       time.Time
        EndTime         time.Time
        Rule            *Rule
        log             log.Logger
        dashboardSlug   string
        ImagePublicUrl  string
        ImageOnDiskPath string
        NoDataFound     bool
        PrevAlertState  m.AlertStateType

        Ctx context.Context
}

func NewEvalContext(alertCtx context.Context, rule *Rule) *EvalContext <span class="cov8" title="1">{
        return &amp;EvalContext{
                Ctx:            alertCtx,
                StartTime:      time.Now(),
                Rule:           rule,
                Logs:           make([]*ResultLogEntry, 0),
                EvalMatches:    make([]*EvalMatch, 0),
                log:            log.New("alerting.evalContext"),
                PrevAlertState: rule.State,
        }
}</span>

type StateDescription struct {
        Color string
        Text  string
        Data  string
}

func (c *EvalContext) GetStateModel() *StateDescription <span class="cov0" title="0">{
        switch c.Rule.State </span>{
        case m.AlertStateOK:<span class="cov0" title="0">
                return &amp;StateDescription{
                        Color: "#36a64f",
                        Text:  "OK",
                }</span>
        case m.AlertStateNoData:<span class="cov0" title="0">
                return &amp;StateDescription{
                        Color: "#888888",
                        Text:  "No Data",
                }</span>
        case m.AlertStateAlerting:<span class="cov0" title="0">
                return &amp;StateDescription{
                        Color: "#D63232",
                        Text:  "Alerting",
                }</span>
        default:<span class="cov0" title="0">
                panic("Unknown rule state " + c.Rule.State)</span>
        }
}

func (c *EvalContext) ShouldUpdateAlertState() bool <span class="cov8" title="1">{
        return c.Rule.State != c.PrevAlertState
}</span>

func (c *EvalContext) ShouldSendNotification() bool <span class="cov8" title="1">{
        if (c.PrevAlertState == m.AlertStatePending) &amp;&amp; (c.Rule.State == m.AlertStateOK) </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">return true</span>
}

func (a *EvalContext) GetDurationMs() float64 <span class="cov0" title="0">{
        return float64(a.EndTime.Nanosecond()-a.StartTime.Nanosecond()) / float64(1000000)
}</span>

func (c *EvalContext) GetNotificationTitle() string <span class="cov0" title="0">{
        return "[" + c.GetStateModel().Text + "] " + c.Rule.Name
}</span>

func (c *EvalContext) GetDashboardSlug() (string, error) <span class="cov0" title="0">{
        if c.dashboardSlug != "" </span><span class="cov0" title="0">{
                return c.dashboardSlug, nil
        }</span>

        <span class="cov0" title="0">slugQuery := &amp;m.GetDashboardSlugByIdQuery{Id: c.Rule.DashboardId}
        if err := bus.Dispatch(slugQuery); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">c.dashboardSlug = slugQuery.Result
        return c.dashboardSlug, nil</span>
}

func (c *EvalContext) GetRuleUrl() (string, error) <span class="cov0" title="0">{
        if c.IsTestRun </span><span class="cov0" title="0">{
                return setting.AppUrl, nil
        }</span>

        <span class="cov0" title="0">if slug, err := c.GetDashboardSlug(); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span><span class="cov0" title="0"> else {
                ruleUrl := fmt.Sprintf("%sdashboard/db/%s?fullscreen&amp;edit&amp;tab=alert&amp;panelId=%d&amp;orgId=%d", setting.AppUrl, slug, c.Rule.PanelId, c.Rule.OrgId)
                return ruleUrl, nil
        }</span>
}
</pre>
		
		<pre class="file" id="file114" style="display: none">package alerting

import (
        "strconv"
        "strings"
        "time"

        "github.com/grafana/grafana/pkg/log"
        "github.com/grafana/grafana/pkg/metrics"
        "github.com/grafana/grafana/pkg/models"
)

type DefaultEvalHandler struct {
        log             log.Logger
        alertJobTimeout time.Duration
}

func NewEvalHandler() *DefaultEvalHandler <span class="cov8" title="1">{
        return &amp;DefaultEvalHandler{
                log:             log.New("alerting.evalHandler"),
                alertJobTimeout: time.Second * 5,
        }
}</span>

func (e *DefaultEvalHandler) Eval(context *EvalContext) <span class="cov8" title="1">{
        firing := true
        noDataFound := true
        conditionEvals := ""

        for i := 0; i &lt; len(context.Rule.Conditions); i++ </span><span class="cov8" title="1">{
                condition := context.Rule.Conditions[i]
                cr, err := condition.Eval(context)
                if err != nil </span><span class="cov0" title="0">{
                        context.Error = err
                }</span>

                // break if condition could not be evaluated
                <span class="cov8" title="1">if context.Error != nil </span><span class="cov0" title="0">{
                        break</span>
                }

                // calculating Firing based on operator
                <span class="cov8" title="1">if cr.Operator == "or" </span><span class="cov8" title="1">{
                        firing = firing || cr.Firing
                        noDataFound = noDataFound || cr.NoDataFound
                }</span><span class="cov8" title="1"> else {
                        firing = firing &amp;&amp; cr.Firing
                        noDataFound = noDataFound &amp;&amp; cr.NoDataFound
                }</span>

                <span class="cov8" title="1">if i &gt; 0 </span><span class="cov8" title="1">{
                        conditionEvals = "[" + conditionEvals + " " + strings.ToUpper(cr.Operator) + " " + strconv.FormatBool(cr.Firing) + "]"
                }</span><span class="cov8" title="1"> else {
                        conditionEvals = strconv.FormatBool(firing)
                }</span>

                <span class="cov8" title="1">context.EvalMatches = append(context.EvalMatches, cr.EvalMatches...)</span>
        }

        <span class="cov8" title="1">context.ConditionEvals = conditionEvals + " = " + strconv.FormatBool(firing)
        context.Firing = firing
        context.NoDataFound = noDataFound
        context.EndTime = time.Now()
        context.Rule.State = e.getNewState(context)

        elapsedTime := context.EndTime.Sub(context.StartTime) / time.Millisecond
        metrics.M_Alerting_Execution_Time.Update(elapsedTime)</span>
}

// This should be move into evalContext once its been refactored.
func (handler *DefaultEvalHandler) getNewState(evalContext *EvalContext) models.AlertStateType <span class="cov8" title="1">{
        if evalContext.Error != nil </span><span class="cov8" title="1">{
                handler.log.Error("Alert Rule Result Error",
                        "ruleId", evalContext.Rule.Id,
                        "name", evalContext.Rule.Name,
                        "error", evalContext.Error,
                        "changing state to", evalContext.Rule.ExecutionErrorState.ToAlertState())

                if evalContext.Rule.ExecutionErrorState == models.ExecutionErrorKeepState </span><span class="cov8" title="1">{
                        return evalContext.PrevAlertState
                }</span><span class="cov8" title="1"> else {
                        return evalContext.Rule.ExecutionErrorState.ToAlertState()
                }</span>
        }<span class="cov8" title="1"> else if evalContext.Firing </span><span class="cov8" title="1">{
                return models.AlertStateAlerting
        }</span><span class="cov8" title="1"> else if evalContext.NoDataFound </span><span class="cov8" title="1">{
                handler.log.Info("Alert Rule returned no data",
                        "ruleId", evalContext.Rule.Id,
                        "name", evalContext.Rule.Name,
                        "changing state to", evalContext.Rule.NoDataState.ToAlertState())

                if evalContext.Rule.NoDataState == models.NoDataKeepState </span><span class="cov8" title="1">{
                        return evalContext.PrevAlertState
                }</span><span class="cov8" title="1"> else {
                        return evalContext.Rule.NoDataState.ToAlertState()
                }</span>
        }

        <span class="cov8" title="1">return models.AlertStateOK</span>
}
</pre>
		
		<pre class="file" id="file115" style="display: none">package alerting

import (
        "errors"

        "fmt"

        "github.com/grafana/grafana/pkg/bus"
        "github.com/grafana/grafana/pkg/components/simplejson"
        "github.com/grafana/grafana/pkg/log"
        m "github.com/grafana/grafana/pkg/models"
)

type DashAlertExtractor struct {
        Dash  *m.Dashboard
        OrgId int64
        log   log.Logger
}

func NewDashAlertExtractor(dash *m.Dashboard, orgId int64) *DashAlertExtractor <span class="cov8" title="1">{
        return &amp;DashAlertExtractor{
                Dash:  dash,
                OrgId: orgId,
                log:   log.New("alerting.extractor"),
        }
}</span>

func (e *DashAlertExtractor) lookupDatasourceId(dsName string) (*m.DataSource, error) <span class="cov8" title="1">{
        if dsName == "" </span><span class="cov8" title="1">{
                query := &amp;m.GetDataSourcesQuery{OrgId: e.OrgId}
                if err := bus.Dispatch(query); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span><span class="cov8" title="1"> else {
                        for _, ds := range query.Result </span><span class="cov8" title="1">{
                                if ds.IsDefault </span><span class="cov8" title="1">{
                                        return ds, nil
                                }</span>
                        }
                }
        }<span class="cov8" title="1"> else {
                query := &amp;m.GetDataSourceByNameQuery{Name: dsName, OrgId: e.OrgId}
                if err := bus.Dispatch(query); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span><span class="cov8" title="1"> else {
                        return query.Result, nil
                }</span>
        }

        <span class="cov0" title="0">return nil, errors.New("Could not find datasource id for " + dsName)</span>
}

func findPanelQueryByRefId(panel *simplejson.Json, refId string) *simplejson.Json <span class="cov8" title="1">{
        for _, targetsObj := range panel.Get("targets").MustArray() </span><span class="cov8" title="1">{
                target := simplejson.NewFromAny(targetsObj)

                if target.Get("refId").MustString() == refId </span><span class="cov8" title="1">{
                        return target
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func copyJson(in *simplejson.Json) (*simplejson.Json, error) <span class="cov8" title="1">{
        rawJson, err := in.MarshalJSON()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return simplejson.NewJson(rawJson)</span>
}

func (e *DashAlertExtractor) GetAlerts() ([]*m.Alert, error) <span class="cov8" title="1">{
        e.log.Debug("GetAlerts")

        dashboardJson, err := copyJson(e.Dash.Data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">alerts := make([]*m.Alert, 0)
        for _, rowObj := range dashboardJson.Get("rows").MustArray() </span><span class="cov8" title="1">{
                row := simplejson.NewFromAny(rowObj)

                for _, panelObj := range row.Get("panels").MustArray() </span><span class="cov8" title="1">{
                        panel := simplejson.NewFromAny(panelObj)
                        jsonAlert, hasAlert := panel.CheckGet("alert")

                        if !hasAlert </span><span class="cov8" title="1">{
                                continue</span>
                        }

                        // backward compatability check, can be removed later
                        <span class="cov8" title="1">enabled, hasEnabled := jsonAlert.CheckGet("enabled")
                        if hasEnabled &amp;&amp; enabled.MustBool() == false </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov8" title="1">frequency, err := getTimeDurationStringToSeconds(jsonAlert.Get("frequency").MustString())
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, ValidationError{Reason: "Could not parse frequency"}
                        }</span>

                        <span class="cov8" title="1">alert := &amp;m.Alert{
                                DashboardId: e.Dash.Id,
                                OrgId:       e.OrgId,
                                PanelId:     panel.Get("id").MustInt64(),
                                Id:          jsonAlert.Get("id").MustInt64(),
                                Name:        jsonAlert.Get("name").MustString(),
                                Handler:     jsonAlert.Get("handler").MustInt64(),
                                Message:     jsonAlert.Get("message").MustString(),
                                Frequency:   frequency,
                        }

                        for _, condition := range jsonAlert.Get("conditions").MustArray() </span><span class="cov8" title="1">{
                                jsonCondition := simplejson.NewFromAny(condition)

                                jsonQuery := jsonCondition.Get("query")
                                queryRefId := jsonQuery.Get("params").MustArray()[0].(string)
                                panelQuery := findPanelQueryByRefId(panel, queryRefId)

                                if panelQuery == nil </span><span class="cov0" title="0">{
                                        reason := fmt.Sprintf("Alert on PanelId: %v refers to query(%s) that cannot be found", alert.PanelId, queryRefId)
                                        return nil, ValidationError{Reason: reason}
                                }</span>

                                <span class="cov8" title="1">dsName := ""
                                if panelQuery.Get("datasource").MustString() != "" </span><span class="cov0" title="0">{
                                        dsName = panelQuery.Get("datasource").MustString()
                                }</span><span class="cov8" title="1"> else if panel.Get("datasource").MustString() != "" </span><span class="cov8" title="1">{
                                        dsName = panel.Get("datasource").MustString()
                                }</span>

                                <span class="cov8" title="1">if datasource, err := e.lookupDatasourceId(dsName); err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span><span class="cov8" title="1"> else {
                                        jsonQuery.SetPath([]string{"datasourceId"}, datasource.Id)
                                }</span>

                                <span class="cov8" title="1">if interval, err := panel.Get("interval").String(); err == nil </span><span class="cov8" title="1">{
                                        panelQuery.Set("interval", interval)
                                }</span>

                                <span class="cov8" title="1">jsonQuery.Set("model", panelQuery.Interface())</span>
                        }

                        <span class="cov8" title="1">alert.Settings = jsonAlert

                        // validate
                        _, err = NewRuleFromDBAlert(alert)
                        if err == nil &amp;&amp; alert.ValidToSave() </span><span class="cov8" title="1">{
                                alerts = append(alerts, alert)
                        }</span><span class="cov0" title="0"> else {
                                return nil, err
                        }</span>
                }
        }

        <span class="cov8" title="1">e.log.Debug("Extracted alerts from dashboard", "alertCount", len(alerts))
        return alerts, nil</span>
}
</pre>
		
		<pre class="file" id="file116" style="display: none">package alerting

import "time"

type EvalHandler interface {
        Eval(evalContext *EvalContext)
}

type Scheduler interface {
        Tick(time time.Time, execQueue chan *Job)
        Update(rules []*Rule)
}

type Notifier interface {
        Notify(evalContext *EvalContext) error
        GetType() string
        NeedsImage() bool
        PassesFilter(rule *Rule) bool

        GetNotifierId() int64
        GetIsDefault() bool
}

type NotifierSlice []Notifier

func (notifiers NotifierSlice) ShouldUploadImage() bool <span class="cov0" title="0">{
        for _, notifier := range notifiers </span><span class="cov0" title="0">{
                if notifier.NeedsImage() </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

type ConditionResult struct {
        Firing      bool
        NoDataFound bool
        Operator    string
        EvalMatches []*EvalMatch
}

type Condition interface {
        Eval(result *EvalContext) (*ConditionResult, error)
}
</pre>
		
		<pre class="file" id="file117" style="display: none">package alerting

import (
        "errors"
        "fmt"

        "golang.org/x/sync/errgroup"

        "github.com/grafana/grafana/pkg/bus"
        "github.com/grafana/grafana/pkg/components/imguploader"
        "github.com/grafana/grafana/pkg/components/renderer"
        "github.com/grafana/grafana/pkg/log"
        m "github.com/grafana/grafana/pkg/models"
)

type NotifierPlugin struct {
        Type            string          `json:"type"`
        Name            string          `json:"name"`
        Description     string          `json:"description"`
        OptionsTemplate string          `json:"optionsTemplate"`
        Factory         NotifierFactory `json:"-"`
}

type NotificationService interface {
        Send(context *EvalContext) error
}

func NewNotificationService() NotificationService <span class="cov0" title="0">{
        return newNotificationService()
}</span>

type notificationService struct {
        log log.Logger
}

func newNotificationService() *notificationService <span class="cov0" title="0">{
        return &amp;notificationService{
                log: log.New("alerting.notifier"),
        }
}</span>

func (n *notificationService) Send(context *EvalContext) error <span class="cov0" title="0">{
        notifiers, err := n.getNotifiers(context.Rule.OrgId, context.Rule.Notifications, context)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">n.log.Info("Sending notifications for", "ruleId", context.Rule.Id, "sent count", len(notifiers))

        if len(notifiers) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">if notifiers.ShouldUploadImage() </span><span class="cov0" title="0">{
                if err = n.uploadImage(context); err != nil </span><span class="cov0" title="0">{
                        n.log.Error("Failed to upload alert panel image.", "error", err)
                }</span>
        }

        <span class="cov0" title="0">return n.sendNotifications(context, notifiers)</span>
}

func (n *notificationService) sendNotifications(context *EvalContext, notifiers []Notifier) error <span class="cov0" title="0">{
        g, _ := errgroup.WithContext(context.Ctx)

        for _, notifier := range notifiers </span><span class="cov0" title="0">{
                not := notifier //avoid updating scope variable in go routine
                n.log.Info("Sending notification", "type", not.GetType(), "id", not.GetNotifierId(), "isDefault", not.GetIsDefault())
                g.Go(func() error </span><span class="cov0" title="0">{ return not.Notify(context) }</span>)
        }

        <span class="cov0" title="0">return g.Wait()</span>
}

func (n *notificationService) uploadImage(context *EvalContext) (err error) <span class="cov0" title="0">{
        uploader, err := imguploader.NewImageUploader()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">renderOpts := &amp;renderer.RenderOpts{
                Width:   "800",
                Height:  "400",
                Timeout: "30",
                OrgId:   context.Rule.OrgId,
        }

        if slug, err := context.GetDashboardSlug(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span><span class="cov0" title="0"> else {
                renderOpts.Path = fmt.Sprintf("dashboard-solo/db/%s?&amp;panelId=%d", slug, context.Rule.PanelId)
        }</span>

        <span class="cov0" title="0">if imagePath, err := renderer.RenderToPng(renderOpts); err != nil </span><span class="cov0" title="0">{
                return err
        }</span><span class="cov0" title="0"> else {
                context.ImageOnDiskPath = imagePath
        }</span>

        <span class="cov0" title="0">context.ImagePublicUrl, err = uploader.Upload(context.ImageOnDiskPath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">n.log.Info("uploaded", "url", context.ImagePublicUrl)
        return nil</span>
}

func (n *notificationService) getNotifiers(orgId int64, notificationIds []int64, context *EvalContext) (NotifierSlice, error) <span class="cov0" title="0">{
        query := &amp;m.GetAlertNotificationsToSendQuery{OrgId: orgId, Ids: notificationIds}

        if err := bus.Dispatch(query); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var result []Notifier
        for _, notification := range query.Result </span><span class="cov0" title="0">{
                if not, err := n.createNotifierFor(notification); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span><span class="cov0" title="0"> else {
                        if shouldUseNotification(not, context) </span><span class="cov0" title="0">{
                                result = append(result, not)
                        }</span>
                }
        }

        <span class="cov0" title="0">return result, nil</span>
}

func (n *notificationService) createNotifierFor(model *m.AlertNotification) (Notifier, error) <span class="cov0" title="0">{
        notifierPlugin, found := notifierFactories[model.Type]
        if !found </span><span class="cov0" title="0">{
                return nil, errors.New("Unsupported notification type")
        }</span>

        <span class="cov0" title="0">return notifierPlugin.Factory(model)</span>
}

func shouldUseNotification(notifier Notifier, context *EvalContext) bool <span class="cov8" title="1">{
        if !context.Firing </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">if context.Error != nil </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">return notifier.PassesFilter(context.Rule)</span>
}

type NotifierFactory func(notification *m.AlertNotification) (Notifier, error)

var notifierFactories map[string]*NotifierPlugin = make(map[string]*NotifierPlugin)

func RegisterNotifier(plugin *NotifierPlugin) <span class="cov0" title="0">{
        notifierFactories[plugin.Type] = plugin
}</span>

func GetNotifiers() []*NotifierPlugin <span class="cov0" title="0">{
        list := make([]*NotifierPlugin, 0)

        for _, value := range notifierFactories </span><span class="cov0" title="0">{
                list = append(list, value)
        }</span>

        <span class="cov0" title="0">return list</span>
}
</pre>
		
		<pre class="file" id="file118" style="display: none">package notifiers

import (
        "github.com/grafana/grafana/pkg/components/simplejson"
        "github.com/grafana/grafana/pkg/services/alerting"
)

type NotifierBase struct {
        Name        string
        Type        string
        Id          int64
        IsDeault    bool
        UploadImage bool
}

func NewNotifierBase(id int64, isDefault bool, name, notifierType string, model *simplejson.Json) NotifierBase <span class="cov8" title="1">{
        uploadImage := model.Get("uploadImage").MustBool(true)

        return NotifierBase{
                Id:          id,
                Name:        name,
                IsDeault:    isDefault,
                Type:        notifierType,
                UploadImage: uploadImage,
        }
}</span>

func (n *NotifierBase) PassesFilter(rule *alerting.Rule) bool <span class="cov0" title="0">{
        return true
}</span>

func (n *NotifierBase) GetType() string <span class="cov0" title="0">{
        return n.Type
}</span>

func (n *NotifierBase) NeedsImage() bool <span class="cov0" title="0">{
        return n.UploadImage
}</span>

func (n *NotifierBase) GetNotifierId() int64 <span class="cov0" title="0">{
        return n.Id
}</span>

func (n *NotifierBase) GetIsDefault() bool <span class="cov0" title="0">{
        return n.IsDeault
}</span>
</pre>
		
		<pre class="file" id="file119" style="display: none">package notifiers

import (
        "os"
        "strings"

        "github.com/grafana/grafana/pkg/bus"
        "github.com/grafana/grafana/pkg/log"
        "github.com/grafana/grafana/pkg/metrics"
        m "github.com/grafana/grafana/pkg/models"
        "github.com/grafana/grafana/pkg/services/alerting"
        "github.com/grafana/grafana/pkg/setting"
)

func init() <span class="cov8" title="1">{
        alerting.RegisterNotifier(&amp;alerting.NotifierPlugin{
                Type:        "email",
                Name:        "Email",
                Description: "Sends notifications using Grafana server configured STMP settings",
                Factory:     NewEmailNotifier,
                OptionsTemplate: `
      &lt;h3 class="page-heading"&gt;Email addresses&lt;/h3&gt;
      &lt;div class="gf-form"&gt;
         &lt;textarea rows="7" class="gf-form-input width-25" required ng-model="ctrl.model.settings.addresses"&gt;&lt;/textarea&gt;
      &lt;/div&gt;
      &lt;div class="gf-form"&gt;
      &lt;span&gt;You can enter multiple email addresses using a ";" separator&lt;/span&gt;
      &lt;/div&gt;
    `,
        })
}</span>

type EmailNotifier struct {
        NotifierBase
        Addresses []string
        log       log.Logger
}

func NewEmailNotifier(model *m.AlertNotification) (alerting.Notifier, error) <span class="cov8" title="1">{
        addressesString := model.Settings.Get("addresses").MustString()

        if addressesString == "" </span><span class="cov8" title="1">{
                return nil, alerting.ValidationError{Reason: "Could not find addresses in settings"}
        }</span>

        // split addresses with a few different ways
        <span class="cov8" title="1">addresses := strings.FieldsFunc(addressesString, func(r rune) bool </span><span class="cov8" title="1">{
                switch r </span>{
                case ',', ';', '\n':<span class="cov8" title="1">
                        return true</span>
                }
                <span class="cov8" title="1">return false</span>
        })

        <span class="cov8" title="1">return &amp;EmailNotifier{
                NotifierBase: NewNotifierBase(model.Id, model.IsDefault, model.Name, model.Type, model.Settings),
                Addresses:    addresses,
                log:          log.New("alerting.notifier.email"),
        }, nil</span>
}

func (this *EmailNotifier) Notify(evalContext *alerting.EvalContext) error <span class="cov0" title="0">{
        this.log.Info("Sending alert notification to", "addresses", this.Addresses)
        metrics.M_Alerting_Notification_Sent_Email.Inc(1)

        ruleUrl, err := evalContext.GetRuleUrl()
        if err != nil </span><span class="cov0" title="0">{
                this.log.Error("Failed get rule link", "error", err)
                return err
        }</span>

        <span class="cov0" title="0">cmd := &amp;m.SendEmailCommandSync{
                SendEmailCommand: m.SendEmailCommand{
                        Subject: evalContext.GetNotificationTitle(),
                        Data: map[string]interface{}{
                                "Title":        evalContext.GetNotificationTitle(),
                                "State":        evalContext.Rule.State,
                                "Name":         evalContext.Rule.Name,
                                "StateModel":   evalContext.GetStateModel(),
                                "Message":      evalContext.Rule.Message,
                                "RuleUrl":      ruleUrl,
                                "ImageLink":    "",
                                "EmbededImage": "",
                                "AlertPageUrl": setting.AppUrl + "alerting",
                                "EvalMatches":  evalContext.EvalMatches,
                        },
                        To:           this.Addresses,
                        Template:     "alert_notification.html",
                        EmbededFiles: []string{},
                },
        }

        if evalContext.ImagePublicUrl != "" </span><span class="cov0" title="0">{
                cmd.Data["ImageLink"] = evalContext.ImagePublicUrl
        }</span><span class="cov0" title="0"> else {
                file, err := os.Stat(evalContext.ImageOnDiskPath)
                if err == nil </span><span class="cov0" title="0">{
                        cmd.EmbededFiles = []string{evalContext.ImageOnDiskPath}
                        cmd.Data["EmbededImage"] = file.Name()
                }</span>
        }

        <span class="cov0" title="0">err = bus.DispatchCtx(evalContext.Ctx, cmd)

        if err != nil </span><span class="cov0" title="0">{
                this.log.Error("Failed to send alert notification email", "error", err)
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>

}
</pre>
		
		<pre class="file" id="file120" style="display: none">package notifiers

import (
        "encoding/json"
        "strconv"
        "strings"

        "fmt"

        "github.com/grafana/grafana/pkg/bus"
        "github.com/grafana/grafana/pkg/log"
        "github.com/grafana/grafana/pkg/models"
        "github.com/grafana/grafana/pkg/services/alerting"
)

func init() <span class="cov8" title="1">{
        alerting.RegisterNotifier(&amp;alerting.NotifierPlugin{
                Type:        "hipchat",
                Name:        "HipChat",
                Description: "Sends notifications uto a HipChat Room",
                Factory:     NewHipChatNotifier,
                OptionsTemplate: `
      &lt;h3 class="page-heading"&gt;HipChat settings&lt;/h3&gt;
                              &lt;div class="gf-form max-width-30"&gt;
                                &lt;span class="gf-form-label width-8"&gt;Hip Chat Url&lt;/span&gt;
                                &lt;input type="text" required class="gf-form-input max-width-30" ng-model="ctrl.model.settings.url" placeholder="HipChat URL (ex https://grafana.hipchat.com)"&gt;&lt;/input&gt;
                              &lt;/div&gt;
      &lt;div class="gf-form max-width-30"&gt;
        &lt;span class="gf-form-label width-8"&gt;API Key&lt;/span&gt;
        &lt;input type="text" required class="gf-form-input max-width-30" ng-model="ctrl.model.settings.apikey" placeholder="HipChat API Key"&gt;&lt;/input&gt;
      &lt;/div&gt;
      &lt;div class="gf-form max-width-30"&gt;
        &lt;span class="gf-form-label width-8"&gt;Room ID&lt;/span&gt;
        &lt;input type="text"
          class="gf-form-input max-width-30"
          ng-model="ctrl.model.settings.roomid"
          data-placement="right"&gt;
        &lt;/input&gt;
      &lt;/div&gt;
    `,
        })

}</span>

const (
        maxFieldCount int = 4
)

func NewHipChatNotifier(model *models.AlertNotification) (alerting.Notifier, error) <span class="cov8" title="1">{
        url := model.Settings.Get("url").MustString()
        if strings.HasSuffix(url, "/") </span><span class="cov0" title="0">{
                url = url[:len(url)-1]
        }</span>
        <span class="cov8" title="1">if url == "" </span><span class="cov8" title="1">{
                return nil, alerting.ValidationError{Reason: "Could not find url property in settings"}
        }</span>

        <span class="cov8" title="1">apikey := model.Settings.Get("apikey").MustString()
        roomId := model.Settings.Get("roomid").MustString()

        return &amp;HipChatNotifier{
                NotifierBase: NewNotifierBase(model.Id, model.IsDefault, model.Name, model.Type, model.Settings),
                Url:          url,
                ApiKey:       apikey,
                RoomId:       roomId,
                log:          log.New("alerting.notifier.hipchat"),
        }, nil</span>
}

type HipChatNotifier struct {
        NotifierBase
        Url    string
        ApiKey string
        RoomId string
        log    log.Logger
}

func (this *HipChatNotifier) Notify(evalContext *alerting.EvalContext) error <span class="cov0" title="0">{
        this.log.Info("Executing hipchat notification", "ruleId", evalContext.Rule.Id, "notification", this.Name)

        ruleUrl, err := evalContext.GetRuleUrl()
        if err != nil </span><span class="cov0" title="0">{
                this.log.Error("Failed get rule link", "error", err)
                return err
        }</span>

        <span class="cov0" title="0">message := evalContext.GetNotificationTitle() + " in state " + evalContext.GetStateModel().Text + "&lt;br&gt;&lt;a href=" + ruleUrl + "&gt;Check Dasboard&lt;/a&gt;"
        fields := make([]map[string]interface{}, 0)
        message += "&lt;br&gt;"
        for index, evt := range evalContext.EvalMatches </span><span class="cov0" title="0">{
                message += evt.Metric + " :: " + strconv.FormatFloat(evt.Value.Float64, 'f', -1, 64) + "&lt;br&gt;"
                fields = append(fields, map[string]interface{}{
                        "title": evt.Metric,
                        "value": evt.Value,
                        "short": true,
                })
                if index &gt; maxFieldCount </span><span class="cov0" title="0">{
                        break</span>
                }
        }

        <span class="cov0" title="0">if evalContext.Error != nil </span><span class="cov0" title="0">{
                fields = append(fields, map[string]interface{}{
                        "title": "Error message",
                        "value": evalContext.Error.Error(),
                        "short": false,
                })
        }</span>

        <span class="cov0" title="0">if evalContext.Rule.State != models.AlertStateOK </span><span class="cov0" title="0">{ //dont add message when going back to alert state ok.
                message += " " + evalContext.Rule.Message
        }</span>
        //HipChat has a set list of colors
        <span class="cov0" title="0">var color string
        switch evalContext.Rule.State </span>{
        case models.AlertStateOK:<span class="cov0" title="0">
                color = "green"</span>
        case models.AlertStateNoData:<span class="cov0" title="0">
                color = "grey"</span>
        case models.AlertStateAlerting:<span class="cov0" title="0">
                color = "red"</span>
        }

        // Add a card with link to the dashboard
        <span class="cov0" title="0">card := map[string]interface{}{
                "style":       "link",
                "url":         ruleUrl,
                "id":          "1",
                "title":       evalContext.GetNotificationTitle(),
                "description": evalContext.GetNotificationTitle() + " in state " + evalContext.GetStateModel().Text,
                "icon": map[string]interface{}{
                        "url": "http://grafana.org/assets/img/fav32.png",
                },
                "date": evalContext.EndTime.Unix(),
        }

        body := map[string]interface{}{
                "message":        message,
                "notify":         "true",
                "message_format": "html",
                "color":          color,
                "card":           card,
        }

        hipUrl := fmt.Sprintf("%s/v2/room/%s/notification?auth_token=%s", this.Url, this.RoomId, this.ApiKey)
        data, _ := json.Marshal(&amp;body)
        cmd := &amp;models.SendWebhookSync{Url: hipUrl, Body: string(data)}

        if err := bus.DispatchCtx(evalContext.Ctx, cmd); err != nil </span><span class="cov0" title="0">{
                this.log.Error("Failed to send hipchat notification", "error", err, "webhook", this.Name)
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file121" style="display: none">package notifiers

import (
        "fmt"
        "github.com/grafana/grafana/pkg/bus"
        "github.com/grafana/grafana/pkg/log"
        "github.com/grafana/grafana/pkg/metrics"
        m "github.com/grafana/grafana/pkg/models"
        "github.com/grafana/grafana/pkg/services/alerting"
        "net/url"
)

func init() <span class="cov8" title="1">{
        alerting.RegisterNotifier(&amp;alerting.NotifierPlugin{
                Type:        "LINE",
                Name:        "LINE",
                Description: "Send notifications to LINE notify",
                Factory:     NewLINENotifier,
                OptionsTemplate: `
    &lt;div class="gf-form-group"&gt;
      &lt;h3 class="page-heading"&gt;LINE notify settings&lt;/h3&gt;
      &lt;div class="gf-form"&gt;
        &lt;span class="gf-form-label width-14"&gt;Token&lt;/span&gt;
        &lt;input type="text" required class="gf-form-input max-width-22" ng-model="ctrl.model.settings.token" placeholder="LINE notify token key"&gt;&lt;/input&gt;
      &lt;/div&gt;
    &lt;/div&gt;
`,
        })
}</span>

const (
        lineNotifyUrl string = "https://notify-api.line.me/api/notify"
)

func NewLINENotifier(model *m.AlertNotification) (alerting.Notifier, error) <span class="cov8" title="1">{
        token := model.Settings.Get("token").MustString()
        if token == "" </span><span class="cov8" title="1">{
                return nil, alerting.ValidationError{Reason: "Could not find token in settings"}
        }</span>

        <span class="cov8" title="1">return &amp;LineNotifier{
                NotifierBase: NewNotifierBase(model.Id, model.IsDefault, model.Name, model.Type, model.Settings),
                Token:        token,
                log:          log.New("alerting.notifier.line"),
        }, nil</span>
}

type LineNotifier struct {
        NotifierBase
        Token string
        log   log.Logger
}

func (this *LineNotifier) Notify(evalContext *alerting.EvalContext) error <span class="cov0" title="0">{
        this.log.Info("Executing line notification", "ruleId", evalContext.Rule.Id, "notification", this.Name)
        metrics.M_Alerting_Notification_Sent_LINE.Inc(1)

        var err error
        switch evalContext.Rule.State </span>{
        case m.AlertStateAlerting:<span class="cov0" title="0">
                err = this.createAlert(evalContext)</span>
        }
        <span class="cov0" title="0">return err</span>
}

func (this *LineNotifier) createAlert(evalContext *alerting.EvalContext) error <span class="cov0" title="0">{
        this.log.Info("Creating Line notify", "ruleId", evalContext.Rule.Id, "notification", this.Name)
        ruleUrl, err := evalContext.GetRuleUrl()
        if err != nil </span><span class="cov0" title="0">{
                this.log.Error("Failed get rule link", "error", err)
                return err
        }</span>

        <span class="cov0" title="0">form := url.Values{}
        body := fmt.Sprintf("%s - %s\n%s", evalContext.Rule.Name, ruleUrl, evalContext.Rule.Message)
        form.Add("message", body)

        cmd := &amp;m.SendWebhookSync{
                Url:        lineNotifyUrl,
                HttpMethod: "POST",
                HttpHeader: map[string]string{
                        "Authorization": fmt.Sprintf("Bearer %s", this.Token),
                        "Content-Type":  "application/x-www-form-urlencoded",
                },
                Body: form.Encode(),
        }

        if err := bus.DispatchCtx(evalContext.Ctx, cmd); err != nil </span><span class="cov0" title="0">{
                this.log.Error("Failed to send notification to LINE", "error", err, "body", string(body))
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file122" style="display: none">package notifiers

import (
        "fmt"
        "strconv"

        "github.com/grafana/grafana/pkg/bus"
        "github.com/grafana/grafana/pkg/components/simplejson"
        "github.com/grafana/grafana/pkg/log"
        "github.com/grafana/grafana/pkg/metrics"
        m "github.com/grafana/grafana/pkg/models"
        "github.com/grafana/grafana/pkg/services/alerting"
)

func init() <span class="cov8" title="1">{
        alerting.RegisterNotifier(&amp;alerting.NotifierPlugin{
                Type:        "opsgenie",
                Name:        "OpsGenie",
                Description: "Sends notifications to OpsGenie",
                Factory:     NewOpsGenieNotifier,
                OptionsTemplate: `
      &lt;h3 class="page-heading"&gt;OpsGenie settings&lt;/h3&gt;
      &lt;div class="gf-form"&gt;
        &lt;span class="gf-form-label width-14"&gt;API Key&lt;/span&gt;
        &lt;input type="text" required class="gf-form-input max-width-22" ng-model="ctrl.model.settings.apiKey" placeholder="OpsGenie API Key"&gt;&lt;/input&gt;
      &lt;/div&gt;
      &lt;div class="gf-form"&gt;
        &lt;gf-form-switch
           class="gf-form"
           label="Auto close incidents"
           label-class="width-14"
           checked="ctrl.model.settings.autoClose"
           tooltip="Automatically close alerts in OpseGenie once the alert goes back to ok."&gt;
        &lt;/gf-form-switch&gt;
      &lt;/div&gt;
    `,
        })
}</span>

var (
        opsgenieCreateAlertURL string = "https://api.opsgenie.com/v1/json/alert"
        opsgenieCloseAlertURL  string = "https://api.opsgenie.com/v1/json/alert/close"
)

func NewOpsGenieNotifier(model *m.AlertNotification) (alerting.Notifier, error) <span class="cov8" title="1">{
        autoClose := model.Settings.Get("autoClose").MustBool(true)
        apiKey := model.Settings.Get("apiKey").MustString()
        if apiKey == "" </span><span class="cov8" title="1">{
                return nil, alerting.ValidationError{Reason: "Could not find api key property in settings"}
        }</span>

        <span class="cov8" title="1">return &amp;OpsGenieNotifier{
                NotifierBase: NewNotifierBase(model.Id, model.IsDefault, model.Name, model.Type, model.Settings),
                ApiKey:       apiKey,
                AutoClose:    autoClose,
                log:          log.New("alerting.notifier.opsgenie"),
        }, nil</span>
}

type OpsGenieNotifier struct {
        NotifierBase
        ApiKey    string
        AutoClose bool
        log       log.Logger
}

func (this *OpsGenieNotifier) Notify(evalContext *alerting.EvalContext) error <span class="cov0" title="0">{
        metrics.M_Alerting_Notification_Sent_OpsGenie.Inc(1)

        var err error
        switch evalContext.Rule.State </span>{
        case m.AlertStateOK:<span class="cov0" title="0">
                if this.AutoClose </span><span class="cov0" title="0">{
                        err = this.closeAlert(evalContext)
                }</span>
        case m.AlertStateAlerting:<span class="cov0" title="0">
                err = this.createAlert(evalContext)</span>
        }
        <span class="cov0" title="0">return err</span>
}

func (this *OpsGenieNotifier) createAlert(evalContext *alerting.EvalContext) error <span class="cov0" title="0">{
        this.log.Info("Creating OpsGenie alert", "ruleId", evalContext.Rule.Id, "notification", this.Name)

        ruleUrl, err := evalContext.GetRuleUrl()
        if err != nil </span><span class="cov0" title="0">{
                this.log.Error("Failed get rule link", "error", err)
                return err
        }</span>

        <span class="cov0" title="0">bodyJSON := simplejson.New()
        bodyJSON.Set("apiKey", this.ApiKey)
        bodyJSON.Set("message", evalContext.Rule.Name)
        bodyJSON.Set("source", "Grafana")
        bodyJSON.Set("alias", "alertId-"+strconv.FormatInt(evalContext.Rule.Id, 10))
        bodyJSON.Set("description", fmt.Sprintf("%s - %s\n%s", evalContext.Rule.Name, ruleUrl, evalContext.Rule.Message))

        details := simplejson.New()
        details.Set("url", ruleUrl)
        if evalContext.ImagePublicUrl != "" </span><span class="cov0" title="0">{
                details.Set("image", evalContext.ImagePublicUrl)
        }</span>

        <span class="cov0" title="0">bodyJSON.Set("details", details)
        body, _ := bodyJSON.MarshalJSON()

        cmd := &amp;m.SendWebhookSync{
                Url:        opsgenieCreateAlertURL,
                Body:       string(body),
                HttpMethod: "POST",
        }

        if err := bus.DispatchCtx(evalContext.Ctx, cmd); err != nil </span><span class="cov0" title="0">{
                this.log.Error("Failed to send notification to OpsGenie", "error", err, "body", string(body))
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (this *OpsGenieNotifier) closeAlert(evalContext *alerting.EvalContext) error <span class="cov0" title="0">{
        this.log.Info("Closing OpsGenie alert", "ruleId", evalContext.Rule.Id, "notification", this.Name)

        bodyJSON := simplejson.New()
        bodyJSON.Set("apiKey", this.ApiKey)
        bodyJSON.Set("alias", "alertId-"+strconv.FormatInt(evalContext.Rule.Id, 10))
        body, _ := bodyJSON.MarshalJSON()

        cmd := &amp;m.SendWebhookSync{
                Url:        opsgenieCloseAlertURL,
                Body:       string(body),
                HttpMethod: "POST",
        }

        if err := bus.DispatchCtx(evalContext.Ctx, cmd); err != nil </span><span class="cov0" title="0">{
                this.log.Error("Failed to send notification to OpsGenie", "error", err, "body", string(body))
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file123" style="display: none">package notifiers

import (
        "strconv"

        "github.com/grafana/grafana/pkg/bus"
        "github.com/grafana/grafana/pkg/components/simplejson"
        "github.com/grafana/grafana/pkg/log"
        "github.com/grafana/grafana/pkg/metrics"
        m "github.com/grafana/grafana/pkg/models"
        "github.com/grafana/grafana/pkg/services/alerting"
)

func init() <span class="cov8" title="1">{
        alerting.RegisterNotifier(&amp;alerting.NotifierPlugin{
                Type:        "pagerduty",
                Name:        "PagerDuty",
                Description: "Sends notifications to PagerDuty",
                Factory:     NewPagerdutyNotifier,
                OptionsTemplate: `
      &lt;h3 class="page-heading"&gt;PagerDuty settings&lt;/h3&gt;
      &lt;div class="gf-form"&gt;
        &lt;span class="gf-form-label width-14"&gt;Integration Key&lt;/span&gt;
        &lt;input type="text" required class="gf-form-input max-width-22" ng-model="ctrl.model.settings.integrationKey" placeholder="Pagerduty integeration Key"&gt;&lt;/input&gt;
      &lt;/div&gt;
      &lt;div class="gf-form"&gt;
        &lt;gf-form-switch
           class="gf-form"
           label="Auto resolve incidents"
           label-class="width-14"
           checked="ctrl.model.settings.autoResolve"
           tooltip="Resolve incidents in pagerduty once the alert goes back to ok."&gt;
        &lt;/gf-form-switch&gt;
      &lt;/div&gt;
    `,
        })
}</span>

var (
        pagerdutyEventApiUrl string = "https://events.pagerduty.com/generic/2010-04-15/create_event.json"
)

func NewPagerdutyNotifier(model *m.AlertNotification) (alerting.Notifier, error) <span class="cov8" title="1">{
        autoResolve := model.Settings.Get("autoResolve").MustBool(true)
        key := model.Settings.Get("integrationKey").MustString()
        if key == "" </span><span class="cov8" title="1">{
                return nil, alerting.ValidationError{Reason: "Could not find integration key property in settings"}
        }</span>

        <span class="cov8" title="1">return &amp;PagerdutyNotifier{
                NotifierBase: NewNotifierBase(model.Id, model.IsDefault, model.Name, model.Type, model.Settings),
                Key:          key,
                AutoResolve:  autoResolve,
                log:          log.New("alerting.notifier.pagerduty"),
        }, nil</span>
}

type PagerdutyNotifier struct {
        NotifierBase
        Key         string
        AutoResolve bool
        log         log.Logger
}

func (this *PagerdutyNotifier) Notify(evalContext *alerting.EvalContext) error <span class="cov0" title="0">{
        metrics.M_Alerting_Notification_Sent_PagerDuty.Inc(1)

        if evalContext.Rule.State == m.AlertStateOK &amp;&amp; !this.AutoResolve </span><span class="cov0" title="0">{
                this.log.Info("Not sending a trigger to Pagerduty", "state", evalContext.Rule.State, "auto resolve", this.AutoResolve)
                return nil
        }</span>

        <span class="cov0" title="0">eventType := "trigger"
        if evalContext.Rule.State == m.AlertStateOK </span><span class="cov0" title="0">{
                eventType = "resolve"
        }</span>

        <span class="cov0" title="0">this.log.Info("Notifying Pagerduty", "event_type", eventType)

        bodyJSON := simplejson.New()
        bodyJSON.Set("service_key", this.Key)
        bodyJSON.Set("description", evalContext.Rule.Name+" - "+evalContext.Rule.Message)
        bodyJSON.Set("client", "Grafana")
        bodyJSON.Set("event_type", eventType)
        bodyJSON.Set("incident_key", "alertId-"+strconv.FormatInt(evalContext.Rule.Id, 10))

        ruleUrl, err := evalContext.GetRuleUrl()
        if err != nil </span><span class="cov0" title="0">{
                this.log.Error("Failed get rule link", "error", err)
                return err
        }</span>
        <span class="cov0" title="0">bodyJSON.Set("client_url", ruleUrl)

        if evalContext.ImagePublicUrl != "" </span><span class="cov0" title="0">{
                contexts := make([]interface{}, 1)
                imageJSON := simplejson.New()
                imageJSON.Set("type", "image")
                imageJSON.Set("src", evalContext.ImagePublicUrl)
                contexts[0] = imageJSON
                bodyJSON.Set("contexts", contexts)
        }</span>

        <span class="cov0" title="0">body, _ := bodyJSON.MarshalJSON()

        cmd := &amp;m.SendWebhookSync{
                Url:        pagerdutyEventApiUrl,
                Body:       string(body),
                HttpMethod: "POST",
        }

        if err := bus.DispatchCtx(evalContext.Ctx, cmd); err != nil </span><span class="cov0" title="0">{
                this.log.Error("Failed to send notification to Pagerduty", "error", err, "body", string(body))
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file124" style="display: none">package notifiers

import (
        "github.com/grafana/grafana/pkg/bus"
        "github.com/grafana/grafana/pkg/components/simplejson"
        "github.com/grafana/grafana/pkg/log"
        "github.com/grafana/grafana/pkg/metrics"
        m "github.com/grafana/grafana/pkg/models"
        "github.com/grafana/grafana/pkg/services/alerting"
        "strconv"
        "strings"
)

func init() <span class="cov8" title="1">{
        alerting.RegisterNotifier(&amp;alerting.NotifierPlugin{
                Type:        "sensu",
                Name:        "Sensu",
                Description: "Sends HTTP POST request to a Sensu API",
                Factory:     NewSensuNotifier,
                OptionsTemplate: `
      &lt;h3 class="page-heading"&gt;Sensu settings&lt;/h3&gt;
      &lt;div class="gf-form"&gt;
        &lt;span class="gf-form-label width-10"&gt;Url&lt;/span&gt;
                                &lt;input type="text" required class="gf-form-input max-width-26" ng-model="ctrl.model.settings.url" placeholder="http://sensu-api.local:4567/results"&gt;&lt;/input&gt;
      &lt;/div&gt;
      &lt;div class="gf-form"&gt;
        &lt;span class="gf-form-label width-10"&gt;Username&lt;/span&gt;
        &lt;input type="text" class="gf-form-input max-width-14" ng-model="ctrl.model.settings.username"&gt;&lt;/input&gt;
      &lt;/div&gt;
      &lt;div class="gf-form"&gt;
        &lt;span class="gf-form-label width-10"&gt;Password&lt;/span&gt;
        &lt;input type="text" class="gf-form-input max-width-14" ng-model="ctrl.model.settings.password"&gt;&lt;/input&gt;
      &lt;/div&gt;
    `,
        })

}</span>

func NewSensuNotifier(model *m.AlertNotification) (alerting.Notifier, error) <span class="cov8" title="1">{
        url := model.Settings.Get("url").MustString()
        if url == "" </span><span class="cov8" title="1">{
                return nil, alerting.ValidationError{Reason: "Could not find url property in settings"}
        }</span>

        <span class="cov8" title="1">return &amp;SensuNotifier{
                NotifierBase: NewNotifierBase(model.Id, model.IsDefault, model.Name, model.Type, model.Settings),
                Url:          url,
                User:         model.Settings.Get("username").MustString(),
                Password:     model.Settings.Get("password").MustString(),
                log:          log.New("alerting.notifier.sensu"),
        }, nil</span>
}

type SensuNotifier struct {
        NotifierBase
        Url      string
        User     string
        Password string
        log      log.Logger
}

func (this *SensuNotifier) Notify(evalContext *alerting.EvalContext) error <span class="cov0" title="0">{
        this.log.Info("Sending sensu result")
        metrics.M_Alerting_Notification_Sent_Sensu.Inc(1)

        bodyJSON := simplejson.New()
        bodyJSON.Set("ruleId", evalContext.Rule.Id)
        // Sensu alerts cannot have spaces in them
        bodyJSON.Set("name", strings.Replace(evalContext.Rule.Name, " ", "_", -1))
        // Sensu alerts require a command
        // We set it to the grafana ruleID
        bodyJSON.Set("source", "grafana_rule_"+strconv.FormatInt(evalContext.Rule.Id, 10))
        // Finally, sensu expects an output
        // We set it to a default output
        bodyJSON.Set("output", "Grafana Metric Condition Met")
        bodyJSON.Set("evalMatches", evalContext.EvalMatches)

        if evalContext.Rule.State == "alerting" </span><span class="cov0" title="0">{
                bodyJSON.Set("status", 2)
        }</span><span class="cov0" title="0"> else if evalContext.Rule.State == "no_data" </span><span class="cov0" title="0">{
                bodyJSON.Set("status", 1)
        }</span><span class="cov0" title="0"> else {
                bodyJSON.Set("status", 0)
        }</span>

        <span class="cov0" title="0">ruleUrl, err := evalContext.GetRuleUrl()
        if err == nil </span><span class="cov0" title="0">{
                bodyJSON.Set("ruleUrl", ruleUrl)
        }</span>

        <span class="cov0" title="0">if evalContext.ImagePublicUrl != "" </span><span class="cov0" title="0">{
                bodyJSON.Set("imageUrl", evalContext.ImagePublicUrl)
        }</span>

        <span class="cov0" title="0">if evalContext.Rule.Message != "" </span><span class="cov0" title="0">{
                bodyJSON.Set("message", evalContext.Rule.Message)
        }</span>

        <span class="cov0" title="0">body, _ := bodyJSON.MarshalJSON()

        cmd := &amp;m.SendWebhookSync{
                Url:        this.Url,
                User:       this.User,
                Password:   this.Password,
                Body:       string(body),
                HttpMethod: "POST",
        }

        if err := bus.DispatchCtx(evalContext.Ctx, cmd); err != nil </span><span class="cov0" title="0">{
                this.log.Error("Failed to send sensu event", "error", err, "sensu", this.Name)
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file125" style="display: none">package notifiers

import (
        "encoding/json"
        "time"

        "github.com/grafana/grafana/pkg/bus"
        "github.com/grafana/grafana/pkg/log"
        "github.com/grafana/grafana/pkg/metrics"
        m "github.com/grafana/grafana/pkg/models"
        "github.com/grafana/grafana/pkg/services/alerting"
        "github.com/grafana/grafana/pkg/setting"
)

func init() <span class="cov8" title="1">{
        alerting.RegisterNotifier(&amp;alerting.NotifierPlugin{
                Type:        "slack",
                Name:        "Slack",
                Description: "Sends notifications using Grafana server configured STMP settings",
                Factory:     NewSlackNotifier,
                OptionsTemplate: `
      &lt;h3 class="page-heading"&gt;Slack settings&lt;/h3&gt;
      &lt;div class="gf-form max-width-30"&gt;
        &lt;span class="gf-form-label width-6"&gt;Url&lt;/span&gt;
        &lt;input type="text" required class="gf-form-input max-width-30" ng-model="ctrl.model.settings.url" placeholder="Slack incoming webhook url"&gt;&lt;/input&gt;
      &lt;/div&gt;
      &lt;div class="gf-form max-width-30"&gt;
        &lt;span class="gf-form-label width-6"&gt;Recipient&lt;/span&gt;
        &lt;input type="text"
          class="gf-form-input max-width-30"
          ng-model="ctrl.model.settings.recipient"
          data-placement="right"&gt;
        &lt;/input&gt;
        &lt;info-popover mode="right-absolute"&gt;
          Override default channel or user, use #channel-name or @username
        &lt;/info-popover&gt;
      &lt;/div&gt;
      &lt;div class="gf-form max-width-30"&gt;
        &lt;span class="gf-form-label width-6"&gt;Mention&lt;/span&gt;
        &lt;input type="text"
          class="gf-form-input max-width-30"
          ng-model="ctrl.model.settings.mention"
          data-placement="right"&gt;
        &lt;/input&gt;
        &lt;info-popover mode="right-absolute"&gt;
          Mention a user or a group using @ when notifying in a channel
        &lt;/info-popover&gt;
      &lt;/div&gt;
    `,
        })

}</span>

func NewSlackNotifier(model *m.AlertNotification) (alerting.Notifier, error) <span class="cov8" title="1">{
        url := model.Settings.Get("url").MustString()
        if url == "" </span><span class="cov8" title="1">{
                return nil, alerting.ValidationError{Reason: "Could not find url property in settings"}
        }</span>

        <span class="cov8" title="1">recipient := model.Settings.Get("recipient").MustString()
        mention := model.Settings.Get("mention").MustString()

        return &amp;SlackNotifier{
                NotifierBase: NewNotifierBase(model.Id, model.IsDefault, model.Name, model.Type, model.Settings),
                Url:          url,
                Recipient:    recipient,
                Mention:      mention,
                log:          log.New("alerting.notifier.slack"),
        }, nil</span>
}

type SlackNotifier struct {
        NotifierBase
        Url       string
        Recipient string
        Mention   string
        log       log.Logger
}

func (this *SlackNotifier) Notify(evalContext *alerting.EvalContext) error <span class="cov0" title="0">{
        this.log.Info("Executing slack notification", "ruleId", evalContext.Rule.Id, "notification", this.Name)
        metrics.M_Alerting_Notification_Sent_Slack.Inc(1)

        ruleUrl, err := evalContext.GetRuleUrl()
        if err != nil </span><span class="cov0" title="0">{
                this.log.Error("Failed get rule link", "error", err)
                return err
        }</span>

        <span class="cov0" title="0">fields := make([]map[string]interface{}, 0)
        fieldLimitCount := 4
        for index, evt := range evalContext.EvalMatches </span><span class="cov0" title="0">{
                fields = append(fields, map[string]interface{}{
                        "title": evt.Metric,
                        "value": evt.Value,
                        "short": true,
                })
                if index &gt; fieldLimitCount </span><span class="cov0" title="0">{
                        break</span>
                }
        }

        <span class="cov0" title="0">if evalContext.Error != nil </span><span class="cov0" title="0">{
                fields = append(fields, map[string]interface{}{
                        "title": "Error message",
                        "value": evalContext.Error.Error(),
                        "short": false,
                })
        }</span>

        <span class="cov0" title="0">message := this.Mention
        if evalContext.Rule.State != m.AlertStateOK </span><span class="cov0" title="0">{ //dont add message when going back to alert state ok.
                message += " " + evalContext.Rule.Message
        }</span>

        <span class="cov0" title="0">body := map[string]interface{}{
                "attachments": []map[string]interface{}{
                        {
                                "color":       evalContext.GetStateModel().Color,
                                "title":       evalContext.GetNotificationTitle(),
                                "title_link":  ruleUrl,
                                "text":        message,
                                "fields":      fields,
                                "image_url":   evalContext.ImagePublicUrl,
                                "footer":      "Grafana v" + setting.BuildVersion,
                                "footer_icon": "http://grafana.org/assets/img/fav32.png",
                                "ts":          time.Now().Unix(),
                        },
                },
                "parse": "full", // to linkify urls, users and channels in alert message.
        }

        //recipient override
        if this.Recipient != "" </span><span class="cov0" title="0">{
                body["channel"] = this.Recipient
        }</span>

        <span class="cov0" title="0">data, _ := json.Marshal(&amp;body)
        cmd := &amp;m.SendWebhookSync{Url: this.Url, Body: string(data)}

        if err := bus.DispatchCtx(evalContext.Ctx, cmd); err != nil </span><span class="cov0" title="0">{
                this.log.Error("Failed to send slack notification", "error", err, "webhook", this.Name)
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file126" style="display: none">package notifiers

import (
        "fmt"

        "github.com/grafana/grafana/pkg/bus"
        "github.com/grafana/grafana/pkg/components/simplejson"
        "github.com/grafana/grafana/pkg/log"
        "github.com/grafana/grafana/pkg/metrics"
        m "github.com/grafana/grafana/pkg/models"
        "github.com/grafana/grafana/pkg/services/alerting"
)

var (
        telegeramApiUrl string = "https://api.telegram.org/bot%s/%s"
)

func init() <span class="cov8" title="1">{
        alerting.RegisterNotifier(&amp;alerting.NotifierPlugin{
                Type:        "telegram",
                Name:        "Telegram",
                Description: "Sends notifications to Telegram",
                Factory:     NewTelegramNotifier,
                OptionsTemplate: `
      &lt;h3 class="page-heading"&gt;Telegram API settings&lt;/h3&gt;
      &lt;div class="gf-form"&gt;
        &lt;span class="gf-form-label width-9"&gt;BOT API Token&lt;/span&gt;
        &lt;input type="text" required
                                        class="gf-form-input"
                                        ng-model="ctrl.model.settings.bottoken"
                                        placeholder="Telegram BOT API Token"&gt;&lt;/input&gt;
      &lt;/div&gt;
      &lt;div class="gf-form"&gt;
        &lt;span class="gf-form-label width-9"&gt;Chat ID&lt;/span&gt;
        &lt;input type="text" required
                                        class="gf-form-input"
                                        ng-model="ctrl.model.settings.chatid"
                                        data-placement="right"&gt;
        &lt;/input&gt;
        &lt;info-popover mode="right-absolute"&gt;
                                        Integer Telegram Chat Identifier
        &lt;/info-popover&gt;
      &lt;/div&gt;
    `,
        })

}</span>

type TelegramNotifier struct {
        NotifierBase
        BotToken string
        ChatID   string
        log      log.Logger
}

func NewTelegramNotifier(model *m.AlertNotification) (alerting.Notifier, error) <span class="cov8" title="1">{
        if model.Settings == nil </span><span class="cov0" title="0">{
                return nil, alerting.ValidationError{Reason: "No Settings Supplied"}
        }</span>

        <span class="cov8" title="1">botToken := model.Settings.Get("bottoken").MustString()
        chatId := model.Settings.Get("chatid").MustString()

        if botToken == "" </span><span class="cov8" title="1">{
                return nil, alerting.ValidationError{Reason: "Could not find Bot Token in settings"}
        }</span>

        <span class="cov8" title="1">if chatId == "" </span><span class="cov0" title="0">{
                return nil, alerting.ValidationError{Reason: "Could not find Chat Id in settings"}
        }</span>

        <span class="cov8" title="1">return &amp;TelegramNotifier{
                NotifierBase: NewNotifierBase(model.Id, model.IsDefault, model.Name, model.Type, model.Settings),
                BotToken:     botToken,
                ChatID:       chatId,
                log:          log.New("alerting.notifier.telegram"),
        }, nil</span>
}

func (this *TelegramNotifier) Notify(evalContext *alerting.EvalContext) error <span class="cov0" title="0">{
        this.log.Info("Sending alert notification to", "bot_token", this.BotToken)
        this.log.Info("Sending alert notification to", "chat_id", this.ChatID)
        metrics.M_Alerting_Notification_Sent_Telegram.Inc(1)

        bodyJSON := simplejson.New()

        bodyJSON.Set("chat_id", this.ChatID)
        bodyJSON.Set("parse_mode", "html")

        message := fmt.Sprintf("%s\nState: %s\nMessage: %s\n", evalContext.GetNotificationTitle(), evalContext.Rule.Name, evalContext.Rule.Message)

        ruleUrl, err := evalContext.GetRuleUrl()
        if err == nil </span><span class="cov0" title="0">{
                message = message + fmt.Sprintf("URL: %s\n", ruleUrl)
        }</span>
        <span class="cov0" title="0">if evalContext.ImagePublicUrl != "" </span><span class="cov0" title="0">{
                message = message + fmt.Sprintf("Image: %s\n", evalContext.ImagePublicUrl)
        }</span>
        <span class="cov0" title="0">bodyJSON.Set("text", message)

        url := fmt.Sprintf(telegeramApiUrl, this.BotToken, "sendMessage")
        body, _ := bodyJSON.MarshalJSON()

        cmd := &amp;m.SendWebhookSync{
                Url:        url,
                Body:       string(body),
                HttpMethod: "POST",
        }

        if err := bus.DispatchCtx(evalContext.Ctx, cmd); err != nil </span><span class="cov0" title="0">{
                this.log.Error("Failed to send webhook", "error", err, "webhook", this.Name)
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file127" style="display: none">package notifiers

import (
        "encoding/json"
        "time"

        "github.com/grafana/grafana/pkg/bus"
        "github.com/grafana/grafana/pkg/log"
        "github.com/grafana/grafana/pkg/metrics"
        "github.com/grafana/grafana/pkg/models"
        "github.com/grafana/grafana/pkg/services/alerting"
        "github.com/grafana/grafana/pkg/setting"
)

// AlertStateCritical - Victorops uses "CRITICAL" string to indicate "Alerting" state
const AlertStateCritical = "CRITICAL"

func init() <span class="cov8" title="1">{
        alerting.RegisterNotifier(&amp;alerting.NotifierPlugin{
                Type:        "victorops",
                Name:        "VictorOps",
                Description: "Sends notifications to VictorOps",
                Factory:     NewVictoropsNotifier,
                OptionsTemplate: `
      &lt;h3 class="page-heading"&gt;VictorOps settings&lt;/h3&gt;
      &lt;div class="gf-form"&gt;
        &lt;span class="gf-form-label width-6"&gt;Url&lt;/span&gt;
        &lt;input type="text" required class="gf-form-input max-width-30" ng-model="ctrl.model.settings.url" placeholder="VictorOps url"&gt;&lt;/input&gt;
      &lt;/div&gt;
    `,
        })
}</span>

// NewVictoropsNotifier creates an instance of VictoropsNotifier that
// handles posting notifications to Victorops REST API
func NewVictoropsNotifier(model *models.AlertNotification) (alerting.Notifier, error) <span class="cov8" title="1">{
        url := model.Settings.Get("url").MustString()
        if url == "" </span><span class="cov8" title="1">{
                return nil, alerting.ValidationError{Reason: "Could not find victorops url property in settings"}
        }</span>

        <span class="cov8" title="1">return &amp;VictoropsNotifier{
                NotifierBase: NewNotifierBase(model.Id, model.IsDefault, model.Name, model.Type, model.Settings),
                URL:          url,
                log:          log.New("alerting.notifier.victorops"),
        }, nil</span>
}

// VictoropsNotifier defines URL property for Victorops REST API
// and handles notification process by formatting POST body according to
// Victorops specifications (http://victorops.force.com/knowledgebase/articles/Integration/Alert-Ingestion-API-Documentation/)
type VictoropsNotifier struct {
        NotifierBase
        URL string
        log log.Logger
}

// Notify sends notification to Victorops via POST to URL endpoint
func (this *VictoropsNotifier) Notify(evalContext *alerting.EvalContext) error <span class="cov0" title="0">{
        this.log.Info("Executing victorops notification", "ruleId", evalContext.Rule.Id, "notification", this.Name)
        metrics.M_Alerting_Notification_Sent_Victorops.Inc(1)

        ruleUrl, err := evalContext.GetRuleUrl()
        if err != nil </span><span class="cov0" title="0">{
                this.log.Error("Failed get rule link", "error", err)
                return err
        }</span>

        <span class="cov0" title="0">fields := make([]map[string]interface{}, 0)
        fieldLimitCount := 4
        for index, evt := range evalContext.EvalMatches </span><span class="cov0" title="0">{
                fields = append(fields, map[string]interface{}{
                        "title": evt.Metric,
                        "value": evt.Value,
                        "short": true,
                })
                if index &gt; fieldLimitCount </span><span class="cov0" title="0">{
                        break</span>
                }
        }

        <span class="cov0" title="0">if evalContext.Error != nil </span><span class="cov0" title="0">{
                fields = append(fields, map[string]interface{}{
                        "title": "Error message",
                        "value": evalContext.Error.Error(),
                        "short": false,
                })
        }</span>

        <span class="cov0" title="0">messageType := evalContext.Rule.State
        if evalContext.Rule.State == models.AlertStateAlerting </span><span class="cov0" title="0">{ // translate 'Alerting' to 'CRITICAL' (Victorops analog)
                messageType = AlertStateCritical
        }</span>

        <span class="cov0" title="0">body := map[string]interface{}{
                "message_type":     messageType,
                "entity_id":        evalContext.Rule.Name,
                "timestamp":        time.Now().Unix(),
                "state_start_time": evalContext.StartTime.Unix(),
                "state_message":    evalContext.Rule.Message + "\n" + ruleUrl,
                "monitoring_tool":  "Grafana v" + setting.BuildVersion,
        }

        data, _ := json.Marshal(&amp;body)
        cmd := &amp;models.SendWebhookSync{Url: this.URL, Body: string(data)}

        if err := bus.DispatchCtx(evalContext.Ctx, cmd); err != nil </span><span class="cov0" title="0">{
                this.log.Error("Failed to send victorops notification", "error", err, "webhook", this.Name)
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file128" style="display: none">package notifiers

import (
        "github.com/grafana/grafana/pkg/bus"
        "github.com/grafana/grafana/pkg/components/simplejson"
        "github.com/grafana/grafana/pkg/log"
        "github.com/grafana/grafana/pkg/metrics"
        m "github.com/grafana/grafana/pkg/models"
        "github.com/grafana/grafana/pkg/services/alerting"
)

func init() <span class="cov8" title="1">{
        alerting.RegisterNotifier(&amp;alerting.NotifierPlugin{
                Type:        "webhook",
                Name:        "webhook",
                Description: "Sends HTTP POST request to a URL",
                Factory:     NewWebHookNotifier,
                OptionsTemplate: `
      &lt;h3 class="page-heading"&gt;Webhook settings&lt;/h3&gt;
      &lt;div class="gf-form"&gt;
        &lt;span class="gf-form-label width-10"&gt;Url&lt;/span&gt;
        &lt;input type="text" required class="gf-form-input max-width-26" ng-model="ctrl.model.settings.url"&gt;&lt;/input&gt;
      &lt;/div&gt;
      &lt;div class="gf-form"&gt;
        &lt;span class="gf-form-label width-10"&gt;Http Method&lt;/span&gt;
        &lt;div class="gf-form-select-wrapper width-14"&gt;
          &lt;select class="gf-form-input" ng-model="ctrl.model.settings.httpMethod" ng-options="t for t in ['POST', 'PUT']"&gt;
          &lt;/select&gt;
        &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class="gf-form"&gt;
        &lt;span class="gf-form-label width-10"&gt;Username&lt;/span&gt;
        &lt;input type="text" class="gf-form-input max-width-14" ng-model="ctrl.model.settings.username"&gt;&lt;/input&gt;
      &lt;/div&gt;
      &lt;div class="gf-form"&gt;
        &lt;span class="gf-form-label width-10"&gt;Password&lt;/span&gt;
        &lt;input type="text" class="gf-form-input max-width-14" ng-model="ctrl.model.settings.password"&gt;&lt;/input&gt;
      &lt;/div&gt;
    `,
        })

}</span>

func NewWebHookNotifier(model *m.AlertNotification) (alerting.Notifier, error) <span class="cov8" title="1">{
        url := model.Settings.Get("url").MustString()
        if url == "" </span><span class="cov8" title="1">{
                return nil, alerting.ValidationError{Reason: "Could not find url property in settings"}
        }</span>

        <span class="cov8" title="1">return &amp;WebhookNotifier{
                NotifierBase: NewNotifierBase(model.Id, model.IsDefault, model.Name, model.Type, model.Settings),
                Url:          url,
                User:         model.Settings.Get("username").MustString(),
                Password:     model.Settings.Get("password").MustString(),
                HttpMethod:   model.Settings.Get("httpMethod").MustString("POST"),
                log:          log.New("alerting.notifier.webhook"),
        }, nil</span>
}

type WebhookNotifier struct {
        NotifierBase
        Url        string
        User       string
        Password   string
        HttpMethod string
        log        log.Logger
}

func (this *WebhookNotifier) Notify(evalContext *alerting.EvalContext) error <span class="cov0" title="0">{
        this.log.Info("Sending webhook")
        metrics.M_Alerting_Notification_Sent_Webhook.Inc(1)

        bodyJSON := simplejson.New()
        bodyJSON.Set("title", evalContext.GetNotificationTitle())
        bodyJSON.Set("ruleId", evalContext.Rule.Id)
        bodyJSON.Set("ruleName", evalContext.Rule.Name)
        bodyJSON.Set("state", evalContext.Rule.State)
        bodyJSON.Set("evalMatches", evalContext.EvalMatches)

        ruleUrl, err := evalContext.GetRuleUrl()
        if err == nil </span><span class="cov0" title="0">{
                bodyJSON.Set("ruleUrl", ruleUrl)
        }</span>

        <span class="cov0" title="0">if evalContext.ImagePublicUrl != "" </span><span class="cov0" title="0">{
                bodyJSON.Set("imageUrl", evalContext.ImagePublicUrl)
        }</span>

        <span class="cov0" title="0">if evalContext.Rule.Message != "" </span><span class="cov0" title="0">{
                bodyJSON.Set("message", evalContext.Rule.Message)
        }</span>

        <span class="cov0" title="0">body, _ := bodyJSON.MarshalJSON()

        cmd := &amp;m.SendWebhookSync{
                Url:        this.Url,
                User:       this.User,
                Password:   this.Password,
                Body:       string(body),
                HttpMethod: this.HttpMethod,
        }

        if err := bus.DispatchCtx(evalContext.Ctx, cmd); err != nil </span><span class="cov0" title="0">{
                this.log.Error("Failed to send webhook", "error", err, "webhook", this.Name)
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file129" style="display: none">package alerting

import (
        "sync"
        "time"

        "github.com/grafana/grafana/pkg/bus"
        "github.com/grafana/grafana/pkg/log"
        "github.com/grafana/grafana/pkg/metrics"
        m "github.com/grafana/grafana/pkg/models"
)

type RuleReader interface {
        Fetch() []*Rule
}

type DefaultRuleReader struct {
        sync.RWMutex
        serverID       string
        serverPosition int
        clusterSize    int
        log            log.Logger
}

func NewRuleReader() *DefaultRuleReader <span class="cov0" title="0">{
        ruleReader := &amp;DefaultRuleReader{
                log: log.New("alerting.ruleReader"),
        }

        go ruleReader.initReader()
        return ruleReader
}</span>

func (arr *DefaultRuleReader) initReader() <span class="cov0" title="0">{
        heartbeat := time.NewTicker(time.Second * 10)

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-heartbeat.C:<span class="cov0" title="0">
                        arr.heartbeat()</span>
                }
        }
}

func (arr *DefaultRuleReader) Fetch() []*Rule <span class="cov0" title="0">{
        cmd := &amp;m.GetAllAlertsQuery{}

        if err := bus.Dispatch(cmd); err != nil </span><span class="cov0" title="0">{
                arr.log.Error("Could not load alerts", "error", err)
                return []*Rule{}
        }</span>

        <span class="cov0" title="0">res := make([]*Rule, 0)
        for _, ruleDef := range cmd.Result </span><span class="cov0" title="0">{
                if model, err := NewRuleFromDBAlert(ruleDef); err != nil </span><span class="cov0" title="0">{
                        arr.log.Error("Could not build alert model for rule", "ruleId", ruleDef.Id, "error", err)
                }</span><span class="cov0" title="0"> else {
                        res = append(res, model)
                }</span>
        }

        <span class="cov0" title="0">metrics.M_Alerting_Active_Alerts.Update(int64(len(res)))
        return res</span>
}

func (arr *DefaultRuleReader) heartbeat() <span class="cov0" title="0">{
        arr.clusterSize = 1
        arr.serverPosition = 1
}</span>
</pre>
		
		<pre class="file" id="file130" style="display: none">package alerting

import (
        "time"

        "github.com/grafana/grafana/pkg/bus"
        "github.com/grafana/grafana/pkg/components/simplejson"
        "github.com/grafana/grafana/pkg/log"
        "github.com/grafana/grafana/pkg/metrics"
        m "github.com/grafana/grafana/pkg/models"
        "github.com/grafana/grafana/pkg/services/annotations"
)

type ResultHandler interface {
        Handle(evalContext *EvalContext) error
}

type DefaultResultHandler struct {
        notifier NotificationService
        log      log.Logger
}

func NewResultHandler() *DefaultResultHandler <span class="cov0" title="0">{
        return &amp;DefaultResultHandler{
                log:      log.New("alerting.resultHandler"),
                notifier: NewNotificationService(),
        }
}</span>

func (handler *DefaultResultHandler) Handle(evalContext *EvalContext) error <span class="cov0" title="0">{
        executionError := ""
        annotationData := simplejson.New()

        if evalContext.Firing </span><span class="cov0" title="0">{
                annotationData = simplejson.NewFromAny(evalContext.EvalMatches)
        }</span>

        <span class="cov0" title="0">if evalContext.Error != nil </span><span class="cov0" title="0">{
                executionError = evalContext.Error.Error()
                annotationData.Set("errorMessage", executionError)
        }</span>

        <span class="cov0" title="0">if evalContext.NoDataFound </span><span class="cov0" title="0">{
                annotationData.Set("no_data", true)
        }</span>

        <span class="cov0" title="0">countStateResult(evalContext.Rule.State)
        if evalContext.ShouldUpdateAlertState() </span><span class="cov0" title="0">{
                handler.log.Info("New state change", "alertId", evalContext.Rule.Id, "newState", evalContext.Rule.State, "prev state", evalContext.PrevAlertState)

                cmd := &amp;m.SetAlertStateCommand{
                        AlertId:  evalContext.Rule.Id,
                        OrgId:    evalContext.Rule.OrgId,
                        State:    evalContext.Rule.State,
                        Error:    executionError,
                        EvalData: annotationData,
                }

                if err := bus.Dispatch(cmd); err != nil </span><span class="cov0" title="0">{
                        if err == m.ErrCannotChangeStateOnPausedAlert </span><span class="cov0" title="0">{
                                handler.log.Error("Cannot change state on alert thats pause", "error", err)
                                return err
                        }</span>

                        <span class="cov0" title="0">if err == m.ErrRequiresNewState </span><span class="cov0" title="0">{
                                handler.log.Info("Alert already updated")
                                return nil
                        }</span>

                        <span class="cov0" title="0">handler.log.Error("Failed to save state", "error", err)</span>
                }

                // save annotation
                <span class="cov0" title="0">item := annotations.Item{
                        OrgId:       evalContext.Rule.OrgId,
                        DashboardId: evalContext.Rule.DashboardId,
                        PanelId:     evalContext.Rule.PanelId,
                        Type:        annotations.AlertType,
                        AlertId:     evalContext.Rule.Id,
                        Title:       evalContext.Rule.Name,
                        Text:        evalContext.GetStateModel().Text,
                        NewState:    string(evalContext.Rule.State),
                        PrevState:   string(evalContext.PrevAlertState),
                        Epoch:       time.Now().Unix(),
                        Data:        annotationData,
                }

                annotationRepo := annotations.GetRepository()
                if err := annotationRepo.Save(&amp;item); err != nil </span><span class="cov0" title="0">{
                        handler.log.Error("Failed to save annotation for new alert state", "error", err)
                }</span>

                <span class="cov0" title="0">if evalContext.ShouldSendNotification() </span><span class="cov0" title="0">{
                        handler.notifier.Send(evalContext)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func countStateResult(state m.AlertStateType) <span class="cov0" title="0">{
        switch state </span>{
        case m.AlertStatePending:<span class="cov0" title="0">
                metrics.M_Alerting_Result_State_Pending.Inc(1)</span>
        case m.AlertStateAlerting:<span class="cov0" title="0">
                metrics.M_Alerting_Result_State_Alerting.Inc(1)</span>
        case m.AlertStateOK:<span class="cov0" title="0">
                metrics.M_Alerting_Result_State_Ok.Inc(1)</span>
        case m.AlertStatePaused:<span class="cov0" title="0">
                metrics.M_Alerting_Result_State_Paused.Inc(1)</span>
        case m.AlertStateNoData:<span class="cov0" title="0">
                metrics.M_Alerting_Result_State_NoData.Inc(1)</span>
        }
}
</pre>
		
		<pre class="file" id="file131" style="display: none">package alerting

import (
        "fmt"
        "regexp"
        "strconv"

        "github.com/grafana/grafana/pkg/components/simplejson"

        m "github.com/grafana/grafana/pkg/models"
)

type Rule struct {
        Id                  int64
        OrgId               int64
        DashboardId         int64
        PanelId             int64
        Frequency           int64
        Name                string
        Message             string
        NoDataState         m.NoDataOption
        ExecutionErrorState m.ExecutionErrorOption
        State               m.AlertStateType
        Conditions          []Condition
        Notifications       []int64
}

type ValidationError struct {
        Reason      string
        Err         error
        Alertid     int64
        DashboardId int64
        PanelId     int64
}

func (e ValidationError) Error() string <span class="cov0" title="0">{
        extraInfo := ""
        if e.Alertid != 0 </span><span class="cov0" title="0">{
                extraInfo = fmt.Sprintf("%s AlertId: %v", extraInfo, e.Alertid)
        }</span>

        <span class="cov0" title="0">if e.PanelId != 0 </span><span class="cov0" title="0">{
                extraInfo = fmt.Sprintf("%s PanelId: %v ", extraInfo, e.PanelId)
        }</span>

        <span class="cov0" title="0">if e.DashboardId != 0 </span><span class="cov0" title="0">{
                extraInfo = fmt.Sprintf("%s DashboardId: %v", extraInfo, e.DashboardId)
        }</span>

        <span class="cov0" title="0">if e.Err != nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("%s %s%s", e.Err.Error(), e.Reason, extraInfo)
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf("Failed to extract alert.Reason: %s %s", e.Reason, extraInfo)</span>
}

var (
        ValueFormatRegex = regexp.MustCompile("^\\d+")
        UnitFormatRegex  = regexp.MustCompile("\\w{1}$")
)

var unitMultiplier = map[string]int{
        "s": 1,
        "m": 60,
        "h": 3600,
}

func getTimeDurationStringToSeconds(str string) (int64, error) <span class="cov8" title="1">{
        multiplier := 1

        matches := ValueFormatRegex.FindAllString(str, 1)

        if len(matches) &lt;= 0 </span><span class="cov8" title="1">{
                return 0, fmt.Errorf("Frequency could not be parsed")
        }</span>

        <span class="cov8" title="1">value, err := strconv.Atoi(matches[0])
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov8" title="1">unit := UnitFormatRegex.FindAllString(str, 1)[0]

        if val, ok := unitMultiplier[unit]; ok </span><span class="cov8" title="1">{
                multiplier = val
        }</span>

        <span class="cov8" title="1">return int64(value * multiplier), nil</span>
}

func NewRuleFromDBAlert(ruleDef *m.Alert) (*Rule, error) <span class="cov8" title="1">{
        model := &amp;Rule{}
        model.Id = ruleDef.Id
        model.OrgId = ruleDef.OrgId
        model.DashboardId = ruleDef.DashboardId
        model.PanelId = ruleDef.PanelId
        model.Name = ruleDef.Name
        model.Message = ruleDef.Message
        model.Frequency = ruleDef.Frequency
        model.State = ruleDef.State
        model.NoDataState = m.NoDataOption(ruleDef.Settings.Get("noDataState").MustString("no_data"))
        model.ExecutionErrorState = m.ExecutionErrorOption(ruleDef.Settings.Get("executionErrorState").MustString("alerting"))

        for _, v := range ruleDef.Settings.Get("notifications").MustArray() </span><span class="cov8" title="1">{
                jsonModel := simplejson.NewFromAny(v)
                if id, err := jsonModel.Get("id").Int64(); err != nil </span><span class="cov0" title="0">{
                        return nil, ValidationError{Reason: "Invalid notification schema", DashboardId: model.DashboardId, Alertid: model.Id, PanelId: model.PanelId}
                }</span><span class="cov8" title="1"> else {
                        model.Notifications = append(model.Notifications, id)
                }</span>
        }

        <span class="cov8" title="1">for index, condition := range ruleDef.Settings.Get("conditions").MustArray() </span><span class="cov8" title="1">{
                conditionModel := simplejson.NewFromAny(condition)
                conditionType := conditionModel.Get("type").MustString()
                if factory, exist := conditionFactories[conditionType]; !exist </span><span class="cov0" title="0">{
                        return nil, ValidationError{Reason: "Unknown alert condition: " + conditionType, DashboardId: model.DashboardId, Alertid: model.Id, PanelId: model.PanelId}
                }</span><span class="cov8" title="1"> else {
                        if queryCondition, err := factory(conditionModel, index); err != nil </span><span class="cov0" title="0">{
                                return nil, ValidationError{Err: err, DashboardId: model.DashboardId, Alertid: model.Id, PanelId: model.PanelId}
                        }</span><span class="cov8" title="1"> else {
                                model.Conditions = append(model.Conditions, queryCondition)
                        }</span>
                }
        }

        <span class="cov8" title="1">if len(model.Conditions) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Alert is missing conditions")
        }</span>

        <span class="cov8" title="1">return model, nil</span>
}

type ConditionFactory func(model *simplejson.Json, index int) (Condition, error)

var conditionFactories map[string]ConditionFactory = make(map[string]ConditionFactory)

func RegisterCondition(typeName string, factory ConditionFactory) <span class="cov8" title="1">{
        conditionFactories[typeName] = factory
}</span>
</pre>
		
		<pre class="file" id="file132" style="display: none">package alerting

import (
        "math"
        "time"

        "github.com/grafana/grafana/pkg/log"
        "github.com/grafana/grafana/pkg/models"
)

type SchedulerImpl struct {
        jobs map[int64]*Job
        log  log.Logger
}

func NewScheduler() Scheduler <span class="cov0" title="0">{
        return &amp;SchedulerImpl{
                jobs: make(map[int64]*Job, 0),
                log:  log.New("alerting.scheduler"),
        }
}</span>

func (s *SchedulerImpl) Update(rules []*Rule) <span class="cov0" title="0">{
        s.log.Debug("Scheduling update", "ruleCount", len(rules))

        jobs := make(map[int64]*Job, 0)

        for i, rule := range rules </span><span class="cov0" title="0">{
                var job *Job
                if s.jobs[rule.Id] != nil </span><span class="cov0" title="0">{
                        job = s.jobs[rule.Id]
                }</span><span class="cov0" title="0"> else {
                        job = &amp;Job{
                                Running: false,
                        }
                }</span>

                <span class="cov0" title="0">job.Rule = rule

                offset := ((rule.Frequency * 1000) / int64(len(rules))) * int64(i)
                job.Offset = int64(math.Floor(float64(offset) / 1000))
                if job.Offset == 0 </span><span class="cov0" title="0">{ //zero offset causes division with 0 panics.
                        job.Offset = 1
                }</span>
                <span class="cov0" title="0">jobs[rule.Id] = job</span>
        }

        <span class="cov0" title="0">s.jobs = jobs</span>
}

func (s *SchedulerImpl) Tick(tickTime time.Time, execQueue chan *Job) <span class="cov0" title="0">{
        now := tickTime.Unix()

        for _, job := range s.jobs </span><span class="cov0" title="0">{
                if job.Running || job.Rule.State == models.AlertStatePaused </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">if job.OffsetWait &amp;&amp; now%job.Offset == 0 </span><span class="cov0" title="0">{
                        job.OffsetWait = false
                        s.enque(job, execQueue)
                        continue</span>
                }

                <span class="cov0" title="0">if now%job.Rule.Frequency == 0 </span><span class="cov0" title="0">{
                        if job.Offset &gt; 0 </span><span class="cov0" title="0">{
                                job.OffsetWait = true
                        }</span><span class="cov0" title="0"> else {
                                s.enque(job, execQueue)
                        }</span>
                }
        }
}

func (s *SchedulerImpl) enque(job *Job, execQueue chan *Job) <span class="cov0" title="0">{
        s.log.Debug("Scheduler: Putting job on to exec queue", "name", job.Rule.Name, "id", job.Rule.Id)
        execQueue &lt;- job
}</span>
</pre>
		
		<pre class="file" id="file133" style="display: none">package alerting

import (
        "context"

        "github.com/grafana/grafana/pkg/bus"
        "github.com/grafana/grafana/pkg/components/null"
        "github.com/grafana/grafana/pkg/components/simplejson"
        "github.com/grafana/grafana/pkg/log"
        m "github.com/grafana/grafana/pkg/models"
)

type NotificationTestCommand struct {
        State    m.AlertStateType
        Name     string
        Type     string
        Settings *simplejson.Json
}

func init() <span class="cov8" title="1">{
        bus.AddHandler("alerting", handleNotificationTestCommand)

}</span>

func handleNotificationTestCommand(cmd *NotificationTestCommand) error <span class="cov0" title="0">{
        notifier := newNotificationService()

        model := &amp;m.AlertNotification{
                Name:     cmd.Name,
                Type:     cmd.Type,
                Settings: cmd.Settings,
        }

        notifiers, err := notifier.createNotifierFor(model)

        if err != nil </span><span class="cov0" title="0">{
                log.Error2("Failed to create notifier", "error", err.Error())
                return err
        }</span>

        <span class="cov0" title="0">return notifier.sendNotifications(createTestEvalContext(cmd), []Notifier{notifiers})</span>
}

func createTestEvalContext(cmd *NotificationTestCommand) *EvalContext <span class="cov0" title="0">{
        testRule := &amp;Rule{
                DashboardId: 1,
                PanelId:     1,
                Name:        "Test notification",
                Message:     "Someone is testing the alert notification within grafana.",
                State:       m.AlertStateAlerting,
        }

        ctx := NewEvalContext(context.TODO(), testRule)
        if cmd.Settings.Get("uploadImage").MustBool(true) </span><span class="cov0" title="0">{
                ctx.ImagePublicUrl = "http://grafana.org/assets/img/blog/mixed_styles.png"
        }</span>
        <span class="cov0" title="0">ctx.IsTestRun = true
        ctx.Firing = true
        ctx.Error = nil
        ctx.EvalMatches = evalMatchesBasedOnState()

        return ctx</span>
}

func evalMatchesBasedOnState() []*EvalMatch <span class="cov0" title="0">{
        matches := make([]*EvalMatch, 0)
        matches = append(matches, &amp;EvalMatch{
                Metric: "High value",
                Value:  null.FloatFrom(100),
        })

        matches = append(matches, &amp;EvalMatch{
                Metric: "Higher Value",
                Value:  null.FloatFrom(200),
        })

        return matches
}</span>
</pre>
		
		<pre class="file" id="file134" style="display: none">package alerting

import (
        "context"
        "fmt"

        "github.com/grafana/grafana/pkg/bus"
        "github.com/grafana/grafana/pkg/components/simplejson"
        m "github.com/grafana/grafana/pkg/models"
)

type AlertTestCommand struct {
        Dashboard *simplejson.Json
        PanelId   int64
        OrgId     int64

        Result *EvalContext
}

func init() <span class="cov8" title="1">{
        bus.AddHandler("alerting", handleAlertTestCommand)
}</span>

func handleAlertTestCommand(cmd *AlertTestCommand) error <span class="cov0" title="0">{

        dash := m.NewDashboardFromJson(cmd.Dashboard)

        extractor := NewDashAlertExtractor(dash, cmd.OrgId)
        alerts, err := extractor.GetAlerts()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">for _, alert := range alerts </span><span class="cov0" title="0">{
                if alert.PanelId == cmd.PanelId </span><span class="cov0" title="0">{
                        rule, err := NewRuleFromDBAlert(alert)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov0" title="0">cmd.Result = testAlertRule(rule)
                        return nil</span>
                }
        }

        <span class="cov0" title="0">return fmt.Errorf("Could not find alert with panel id %d", cmd.PanelId)</span>
}

func testAlertRule(rule *Rule) *EvalContext <span class="cov0" title="0">{
        handler := NewEvalHandler()

        context := NewEvalContext(context.TODO(), rule)
        context.IsTestRun = true

        handler.Eval(context)

        return context
}</span>
</pre>
		
		<pre class="file" id="file135" style="display: none">package alerting

import (
        "time"

        "github.com/benbjohnson/clock"
)

// ticker is a ticker to power the alerting scheduler. it's like a time.Ticker, except:
// * it doesn't drop ticks for slow receivers, rather, it queues up.  so that callers are in control to instrument what's going on.
// * it automatically ticks every second, which is the right thing in our current design
// * it ticks on second marks or very shortly after. this provides a predictable load pattern
//   (this shouldn't cause too much load contention issues because the next steps in the pipeline just process at their own pace)
// * the timestamps are used to mark "last datapoint to query for" and as such, are a configurable amount of seconds in the past
// * because we want to allow:
//   - a clean "resume where we left off" and "don't yield ticks we already did"
//   - adjusting offset over time to compensate for storage backing up or getting fast and providing lower latency
//   you specify a lastProcessed timestamp as well as an offset at creation, or runtime
type Ticker struct {
        C         chan time.Time
        clock     clock.Clock
        last      time.Time
        offset    time.Duration
        newOffset chan time.Duration
}

// NewTicker returns a ticker that ticks on second marks or very shortly after, and never drops ticks
func NewTicker(last time.Time, initialOffset time.Duration, c clock.Clock) *Ticker <span class="cov8" title="1">{
        t := &amp;Ticker{
                C:         make(chan time.Time),
                clock:     c,
                last:      last,
                offset:    initialOffset,
                newOffset: make(chan time.Duration),
        }
        go t.run()
        return t
}</span>

func (t *Ticker) updateOffset(offset time.Duration) <span class="cov8" title="1">{
        t.newOffset &lt;- offset
}</span>

func (t *Ticker) run() <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                next := t.last.Add(time.Duration(1) * time.Second)
                diff := t.clock.Now().Add(-t.offset).Sub(next)
                if diff &gt;= 0 </span><span class="cov8" title="1">{
                        t.C &lt;- next
                        t.last = next
                        continue</span>
                }
                // tick is too young. try again when ...
                <span class="cov8" title="1">select </span>{
                case &lt;-t.clock.After(-diff):</span><span class="cov8" title="1"> // ...it'll definitely be old enough
                case offset := &lt;-t.newOffset:<span class="cov8" title="1"> // ...it might be old enough
                        t.offset = offset</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file136" style="display: none">package notifications

import (
        "crypto/sha1"
        "encoding/hex"
        "fmt"
        "time"

        "github.com/Unknwon/com"
        m "github.com/grafana/grafana/pkg/models"
        "github.com/grafana/grafana/pkg/setting"
)

const timeLimitCodeLength = 12 + 6 + 40

// create a time limit code
// code format: 12 length date time string + 6 minutes string + 40 sha1 encoded string
func createTimeLimitCode(data string, minutes int, startInf interface{}) string <span class="cov8" title="1">{
        format := "200601021504"

        var start, end time.Time
        var startStr, endStr string

        if startInf == nil </span><span class="cov8" title="1">{
                // Use now time create code
                start = time.Now()
                startStr = start.Format(format)
        }</span><span class="cov8" title="1"> else {
                // use start string create code
                startStr = startInf.(string)
                start, _ = time.ParseInLocation(format, startStr, time.Local)
                startStr = start.Format(format)
        }</span>

        <span class="cov8" title="1">end = start.Add(time.Minute * time.Duration(minutes))
        endStr = end.Format(format)

        // create sha1 encode string
        sh := sha1.New()
        sh.Write([]byte(data + setting.SecretKey + startStr + endStr + com.ToStr(minutes)))
        encoded := hex.EncodeToString(sh.Sum(nil))

        code := fmt.Sprintf("%s%06d%s", startStr, minutes, encoded)
        return code</span>
}

// verify time limit code
func validateUserEmailCode(user *m.User, code string) bool <span class="cov8" title="1">{
        if len(code) &lt;= 18 </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">minutes := setting.EmailCodeValidMinutes
        code = code[:timeLimitCodeLength]

        // split code
        start := code[:12]
        lives := code[12:18]
        if d, err := com.StrTo(lives).Int(); err == nil </span><span class="cov8" title="1">{
                minutes = d
        }</span>

        // right active code
        <span class="cov8" title="1">data := com.ToStr(user.Id) + user.Email + user.Login + user.Password + user.Rands
        retCode := createTimeLimitCode(data, minutes, start)
        fmt.Printf("code : %s\ncode2: %s", retCode, code)
        if retCode == code &amp;&amp; minutes &gt; 0 </span><span class="cov8" title="1">{
                // check time is expired or not
                before, _ := time.ParseInLocation("200601021504", start, time.Local)
                now := time.Now()
                if before.Add(time.Minute*time.Duration(minutes)).Unix() &gt; now.Unix() </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

func getLoginForEmailCode(code string) string <span class="cov8" title="1">{
        if len(code) &lt;= timeLimitCodeLength </span><span class="cov0" title="0">{
                return ""
        }</span>

        // use tail hex username query user
        <span class="cov8" title="1">hexStr := code[timeLimitCodeLength:]
        b, _ := hex.DecodeString(hexStr)
        return string(b)</span>
}

func createUserEmailCode(u *m.User, startInf interface{}) string <span class="cov8" title="1">{
        minutes := setting.EmailCodeValidMinutes
        data := com.ToStr(u.Id) + u.Email + u.Login + u.Password + u.Rands
        code := createTimeLimitCode(data, minutes, startInf)

        // add tail hex username
        code += hex.EncodeToString([]byte(u.Login))
        return code
}</span>
</pre>
		
		<pre class="file" id="file137" style="display: none">package notifications

import (
        m "github.com/grafana/grafana/pkg/models"
        "github.com/grafana/grafana/pkg/setting"
)

type Message struct {
        To           []string
        From         string
        Subject      string
        Body         string
        Info         string
        EmbededFiles []string
}

func setDefaultTemplateData(data map[string]interface{}, u *m.User) <span class="cov8" title="1">{
        data["AppUrl"] = setting.AppUrl
        data["BuildVersion"] = setting.BuildVersion
        data["BuildStamp"] = setting.BuildStamp
        data["EmailCodeValidHours"] = setting.EmailCodeValidMinutes / 60
        data["Subject"] = map[string]interface{}{}
        if u != nil </span><span class="cov0" title="0">{
                data["Name"] = u.NameOrFallback()
        }</span>
}
</pre>
		
		<pre class="file" id="file138" style="display: none">// Copyright 2014 The Gogs Authors. All rights reserved.
// Use of this source code is governed by a MIT-style
// license that can be found in the LICENSE file.

package notifications

import (
        "bytes"
        "crypto/tls"
        "errors"
        "fmt"
        "html/template"
        "net"
        "strconv"
        "strings"

        "github.com/grafana/grafana/pkg/log"
        m "github.com/grafana/grafana/pkg/models"
        "github.com/grafana/grafana/pkg/setting"
        "gopkg.in/gomail.v2"
)

var mailQueue chan *Message

func initMailQueue() <span class="cov8" title="1">{
        mailQueue = make(chan *Message, 10)
        go processMailQueue()
}</span>

func processMailQueue() <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                select </span>{
                case msg := &lt;-mailQueue:<span class="cov0" title="0">
                        num, err := send(msg)
                        tos := strings.Join(msg.To, "; ")
                        info := ""
                        if err != nil </span><span class="cov0" title="0">{
                                if len(msg.Info) &gt; 0 </span><span class="cov0" title="0">{
                                        info = ", info: " + msg.Info
                                }</span>
                                <span class="cov0" title="0">log.Error(4, fmt.Sprintf("Async sent email %d succeed, not send emails: %s%s err: %s", num, tos, info, err))</span>
                        }<span class="cov0" title="0"> else {
                                log.Trace(fmt.Sprintf("Async sent email %d succeed, sent emails: %s%s", num, tos, info))
                        }</span>
                }
        }
}

var addToMailQueue = func(msg *Message) <span class="cov0" title="0">{
        mailQueue &lt;- msg
}</span>

func send(msg *Message) (int, error) <span class="cov0" title="0">{
        dialer, err := createDialer()
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">for _, address := range msg.To </span><span class="cov0" title="0">{
                m := gomail.NewMessage()
                m.SetHeader("From", msg.From)
                m.SetHeader("To", address)
                m.SetHeader("Subject", msg.Subject)
                for _, file := range msg.EmbededFiles </span><span class="cov0" title="0">{
                        m.Embed(file)
                }</span>

                <span class="cov0" title="0">m.SetBody("text/html", msg.Body)

                if err := dialer.DialAndSend(m); err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
        }

        <span class="cov0" title="0">return len(msg.To), nil</span>
}

func createDialer() (*gomail.Dialer, error) <span class="cov0" title="0">{
        host, port, err := net.SplitHostPort(setting.Smtp.Host)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">iPort, err := strconv.Atoi(port)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">tlsconfig := &amp;tls.Config{
                InsecureSkipVerify: setting.Smtp.SkipVerify,
                ServerName:         host,
        }

        if setting.Smtp.CertFile != "" </span><span class="cov0" title="0">{
                cert, err := tls.LoadX509KeyPair(setting.Smtp.CertFile, setting.Smtp.KeyFile)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("Could not load cert or key file. error: %v", err)
                }</span>
                <span class="cov0" title="0">tlsconfig.Certificates = []tls.Certificate{cert}</span>
        }

        <span class="cov0" title="0">d := gomail.NewDialer(host, iPort, setting.Smtp.User, setting.Smtp.Password)
        d.TLSConfig = tlsconfig
        d.LocalName = setting.InstanceName
        return d, nil</span>
}

func buildEmailMessage(cmd *m.SendEmailCommand) (*Message, error) <span class="cov8" title="1">{
        if !setting.Smtp.Enabled </span><span class="cov0" title="0">{
                return nil, errors.New("Grafana mailing/smtp options not configured, contact your Grafana admin")
        }</span>

        <span class="cov8" title="1">var buffer bytes.Buffer
        var err error

        data := cmd.Data
        if data == nil </span><span class="cov0" title="0">{
                data = make(map[string]interface{}, 10)
        }</span>

        <span class="cov8" title="1">setDefaultTemplateData(data, nil)
        err = mailTemplates.ExecuteTemplate(&amp;buffer, cmd.Template, data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">subject := cmd.Subject
        if cmd.Subject == "" </span><span class="cov8" title="1">{
                var subjectText interface{}
                subjectData := data["Subject"].(map[string]interface{})
                subjectText, hasSubject := subjectData["value"]

                if !hasSubject </span><span class="cov0" title="0">{
                        return nil, errors.New(fmt.Sprintf("Missing subject in Template %s", cmd.Template))
                }</span>

                <span class="cov8" title="1">subjectTmpl, err := template.New("subject").Parse(subjectText.(string))
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">var subjectBuffer bytes.Buffer
                err = subjectTmpl.ExecuteTemplate(&amp;subjectBuffer, "subject", data)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">subject = subjectBuffer.String()</span>
        }

        <span class="cov8" title="1">return &amp;Message{
                To:           cmd.To,
                From:         fmt.Sprintf("%s &lt;%s&gt;", setting.Smtp.FromName, setting.Smtp.FromAddress),
                Subject:      subject,
                Body:         buffer.String(),
                EmbededFiles: cmd.EmbededFiles,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file139" style="display: none">package notifications

import (
        "context"
        "errors"
        "fmt"
        "html/template"
        "net/url"
        "path/filepath"

        "github.com/grafana/grafana/pkg/bus"
        "github.com/grafana/grafana/pkg/events"
        "github.com/grafana/grafana/pkg/log"
        m "github.com/grafana/grafana/pkg/models"
        "github.com/grafana/grafana/pkg/setting"
        "github.com/grafana/grafana/pkg/util"
)

var mailTemplates *template.Template
var tmplResetPassword = "reset_password.html"
var tmplSignUpStarted = "signup_started.html"
var tmplWelcomeOnSignUp = "welcome_on_signup.html"

func Init() error <span class="cov8" title="1">{
        initMailQueue()
        initWebhookQueue()

        bus.AddHandler("email", sendResetPasswordEmail)
        bus.AddHandler("email", validateResetPasswordCode)
        bus.AddHandler("email", sendEmailCommandHandler)

        bus.AddCtxHandler("email", sendEmailCommandHandlerSync)

        bus.AddCtxHandler("webhook", SendWebhookSync)

        bus.AddEventListener(signUpStartedHandler)
        bus.AddEventListener(signUpCompletedHandler)

        mailTemplates = template.New("name")
        mailTemplates.Funcs(template.FuncMap{
                "Subject": subjectTemplateFunc,
        })

        templatePattern := filepath.Join(setting.StaticRootPath, setting.Smtp.TemplatesPattern)
        _, err := mailTemplates.ParseGlob(templatePattern)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if !util.IsEmail(setting.Smtp.FromAddress) </span><span class="cov0" title="0">{
                return errors.New("Invalid email address for SMTP from_address config")
        }</span>

        <span class="cov8" title="1">if setting.EmailCodeValidMinutes == 0 </span><span class="cov0" title="0">{
                setting.EmailCodeValidMinutes = 120
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func SendWebhookSync(ctx context.Context, cmd *m.SendWebhookSync) error <span class="cov0" title="0">{
        return sendWebRequestSync(ctx, &amp;Webhook{
                Url:        cmd.Url,
                User:       cmd.User,
                Password:   cmd.Password,
                Body:       cmd.Body,
                HttpMethod: cmd.HttpMethod,
                HttpHeader: cmd.HttpHeader,
        })
}</span>

func subjectTemplateFunc(obj map[string]interface{}, value string) string <span class="cov8" title="1">{
        obj["value"] = value
        return ""
}</span>

func sendEmailCommandHandlerSync(ctx context.Context, cmd *m.SendEmailCommandSync) error <span class="cov0" title="0">{
        message, err := buildEmailMessage(&amp;m.SendEmailCommand{
                Data:         cmd.Data,
                Info:         cmd.Info,
                Template:     cmd.Template,
                To:           cmd.To,
                EmbededFiles: cmd.EmbededFiles,
                Subject:      cmd.Subject,
        })

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">_, err = send(message)

        return err</span>
}

func sendEmailCommandHandler(cmd *m.SendEmailCommand) error <span class="cov8" title="1">{
        message, err := buildEmailMessage(cmd)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">addToMailQueue(message)

        return nil</span>
}

func sendResetPasswordEmail(cmd *m.SendResetPasswordEmailCommand) error <span class="cov8" title="1">{
        return sendEmailCommandHandler(&amp;m.SendEmailCommand{
                To:       []string{cmd.User.Email},
                Template: tmplResetPassword,
                Data: map[string]interface{}{
                        "Code": createUserEmailCode(cmd.User, nil),
                        "Name": cmd.User.NameOrFallback(),
                },
        })
}</span>

func validateResetPasswordCode(query *m.ValidateResetPasswordCodeQuery) error <span class="cov0" title="0">{
        login := getLoginForEmailCode(query.Code)
        if login == "" </span><span class="cov0" title="0">{
                return m.ErrInvalidEmailCode
        }</span>

        <span class="cov0" title="0">userQuery := m.GetUserByLoginQuery{LoginOrEmail: login}
        if err := bus.Dispatch(&amp;userQuery); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if !validateUserEmailCode(userQuery.Result, query.Code) </span><span class="cov0" title="0">{
                return m.ErrInvalidEmailCode
        }</span>

        <span class="cov0" title="0">query.Result = userQuery.Result
        return nil</span>
}

func signUpStartedHandler(evt *events.SignUpStarted) error <span class="cov0" title="0">{
        if !setting.VerifyEmailEnabled </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">log.Info("User signup started: %s", evt.Email)

        if evt.Email == "" </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return sendEmailCommandHandler(&amp;m.SendEmailCommand{
                To:       []string{evt.Email},
                Template: tmplSignUpStarted,
                Data: map[string]interface{}{
                        "Email":     evt.Email,
                        "Code":      evt.Code,
                        "SignUpUrl": setting.ToAbsUrl(fmt.Sprintf("signup/?email=%s&amp;code=%s", url.QueryEscape(evt.Email), url.QueryEscape(evt.Code))),
                },
        })</span>
}

func signUpCompletedHandler(evt *events.SignUpCompleted) error <span class="cov0" title="0">{
        if evt.Email == "" || !setting.Smtp.SendWelcomeEmailOnSignUp </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return sendEmailCommandHandler(&amp;m.SendEmailCommand{
                To:       []string{evt.Email},
                Template: tmplWelcomeOnSignUp,
                Data: map[string]interface{}{
                        "Name": evt.Name,
                },
        })</span>
}
</pre>
		
		<pre class="file" id="file140" style="display: none">package notifications

import (
        "bytes"
        "context"
        "fmt"
        "io/ioutil"
        "net/http"

        "golang.org/x/net/context/ctxhttp"

        "github.com/grafana/grafana/pkg/log"
        "github.com/grafana/grafana/pkg/util"
)

type Webhook struct {
        Url        string
        User       string
        Password   string
        Body       string
        HttpMethod string
        HttpHeader map[string]string
}

var (
        webhookQueue chan *Webhook
        webhookLog   log.Logger
)

func initWebhookQueue() <span class="cov8" title="1">{
        webhookLog = log.New("notifications.webhook")
        webhookQueue = make(chan *Webhook, 10)
        go processWebhookQueue()
}</span>

func processWebhookQueue() <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                select </span>{
                case webhook := &lt;-webhookQueue:<span class="cov0" title="0">
                        err := sendWebRequestSync(context.TODO(), webhook)

                        if err != nil </span><span class="cov0" title="0">{
                                webhookLog.Error("Failed to send webrequest ", "error", err)
                        }</span>
                }
        }
}

func sendWebRequestSync(ctx context.Context, webhook *Webhook) error <span class="cov0" title="0">{
        webhookLog.Debug("Sending webhook", "url", webhook.Url, "http method", webhook.HttpMethod)

        if webhook.HttpMethod == "" </span><span class="cov0" title="0">{
                webhook.HttpMethod = http.MethodPost
        }</span>

        <span class="cov0" title="0">request, err := http.NewRequest(webhook.HttpMethod, webhook.Url, bytes.NewReader([]byte(webhook.Body)))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">request.Header.Add("Content-Type", "application/json")
        request.Header.Add("User-Agent", "Grafana")
        if webhook.User != "" &amp;&amp; webhook.Password != "" </span><span class="cov0" title="0">{
                request.Header.Add("Authorization", util.GetBasicAuthHeader(webhook.User, webhook.Password))
        }</span>

        <span class="cov0" title="0">for k, v := range webhook.HttpHeader </span><span class="cov0" title="0">{
                request.Header.Set(k, v)
        }</span>

        <span class="cov0" title="0">resp, err := ctxhttp.Do(ctx, http.DefaultClient, request)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if resp.StatusCode/100 == 2 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">defer resp.Body.Close()
        body, err := ioutil.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">webhookLog.Debug("Webhook failed", "statuscode", resp.Status, "body", string(body))
        return fmt.Errorf("Webhook response status %v", resp.Status)</span>
}

var addToWebhookQueue = func(msg *Webhook) <span class="cov0" title="0">{
        webhookQueue &lt;- msg
}</span>
</pre>
		
		<pre class="file" id="file141" style="display: none">package search

import (
        "log"
        "path/filepath"
        "sort"

        "github.com/grafana/grafana/pkg/bus"
        m "github.com/grafana/grafana/pkg/models"
        "github.com/grafana/grafana/pkg/setting"
)

var jsonDashIndex *JsonDashIndex

func Init() <span class="cov0" title="0">{
        bus.AddHandler("search", searchHandler)

        jsonIndexCfg, _ := setting.Cfg.GetSection("dashboards.json")

        if jsonIndexCfg == nil </span><span class="cov0" title="0">{
                log.Fatal("Config section missing: dashboards.json")
                return
        }</span>

        <span class="cov0" title="0">jsonIndexEnabled := jsonIndexCfg.Key("enabled").MustBool(false)

        if jsonIndexEnabled </span><span class="cov0" title="0">{
                jsonFilesPath := jsonIndexCfg.Key("path").String()
                if !filepath.IsAbs(jsonFilesPath) </span><span class="cov0" title="0">{
                        jsonFilesPath = filepath.Join(setting.HomePath, jsonFilesPath)
                }</span>

                <span class="cov0" title="0">jsonDashIndex = NewJsonDashIndex(jsonFilesPath)
                go jsonDashIndex.updateLoop()</span>
        }
}

func searchHandler(query *Query) error <span class="cov8" title="1">{
        hits := make(HitList, 0)

        dashQuery := FindPersistedDashboardsQuery{
                Title:        query.Title,
                UserId:       query.UserId,
                IsStarred:    query.IsStarred,
                OrgId:        query.OrgId,
                DashboardIds: query.DashboardIds,
        }

        if err := bus.Dispatch(&amp;dashQuery); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">hits = append(hits, dashQuery.Result...)

        if jsonDashIndex != nil </span><span class="cov8" title="1">{
                jsonHits, err := jsonDashIndex.Search(query)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">hits = append(hits, jsonHits...)</span>
        }

        // filter out results with tag filter
        <span class="cov8" title="1">if len(query.Tags) &gt; 0 </span><span class="cov8" title="1">{
                filtered := HitList{}
                for _, hit := range hits </span><span class="cov8" title="1">{
                        if hasRequiredTags(query.Tags, hit.Tags) </span><span class="cov8" title="1">{
                                filtered = append(filtered, hit)
                        }</span>
                }
                <span class="cov8" title="1">hits = filtered</span>
        }

        // sort main result array
        <span class="cov8" title="1">sort.Sort(hits)

        if len(hits) &gt; query.Limit </span><span class="cov0" title="0">{
                hits = hits[0:query.Limit]
        }</span>

        // sort tags
        <span class="cov8" title="1">for _, hit := range hits </span><span class="cov8" title="1">{
                sort.Strings(hit.Tags)
        }</span>

        // add isStarred info
        <span class="cov8" title="1">if err := setIsStarredFlagOnSearchResults(query.UserId, hits); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">query.Result = hits
        return nil</span>
}

func stringInSlice(a string, list []string) bool <span class="cov8" title="1">{
        for _, b := range list </span><span class="cov8" title="1">{
                if b == a </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func hasRequiredTags(queryTags, hitTags []string) bool <span class="cov8" title="1">{
        for _, queryTag := range queryTags </span><span class="cov8" title="1">{
                if !stringInSlice(queryTag, hitTags) </span><span class="cov8" title="1">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return true</span>
}

func setIsStarredFlagOnSearchResults(userId int64, hits []*Hit) error <span class="cov8" title="1">{
        query := m.GetUserStarsQuery{UserId: userId}
        if err := bus.Dispatch(&amp;query); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">for _, dash := range hits </span><span class="cov8" title="1">{
                if _, exists := query.Result[dash.Id]; exists </span><span class="cov8" title="1">{
                        dash.IsStarred = true
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func GetDashboardFromJsonIndex(filename string) *m.Dashboard <span class="cov0" title="0">{
        if jsonDashIndex == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return jsonDashIndex.GetDashboard(filename)</span>
}
</pre>
		
		<pre class="file" id="file142" style="display: none">package search

import (
        "os"
        "path/filepath"
        "strings"
        "time"

        "github.com/grafana/grafana/pkg/components/simplejson"
        "github.com/grafana/grafana/pkg/log"
        m "github.com/grafana/grafana/pkg/models"
)

type JsonDashIndex struct {
        path  string
        items []*JsonDashIndexItem
}

type JsonDashIndexItem struct {
        TitleLower string
        TagsCsv    string
        Path       string
        Dashboard  *m.Dashboard
}

func NewJsonDashIndex(path string) *JsonDashIndex <span class="cov8" title="1">{
        log.Info("Creating json dashboard index for path: %v", path)

        index := JsonDashIndex{}
        index.path = path
        index.updateIndex()
        return &amp;index
}</span>

func (index *JsonDashIndex) updateLoop() <span class="cov0" title="0">{
        ticker := time.NewTicker(time.Minute)
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ticker.C:<span class="cov0" title="0">
                        if err := index.updateIndex(); err != nil </span><span class="cov0" title="0">{
                                log.Error(3, "Failed to update dashboard json index %v", err)
                        }</span>
                }
        }
}

func (index *JsonDashIndex) Search(query *Query) ([]*Hit, error) <span class="cov8" title="1">{
        results := make([]*Hit, 0)

        if query.IsStarred </span><span class="cov8" title="1">{
                return results, nil
        }</span>

        <span class="cov8" title="1">queryStr := strings.ToLower(query.Title)

        for _, item := range index.items </span><span class="cov8" title="1">{
                if len(results) &gt; query.Limit </span><span class="cov0" title="0">{
                        break</span>
                }

                // add results with matchig title filter
                <span class="cov8" title="1">if strings.Contains(item.TitleLower, queryStr) </span><span class="cov8" title="1">{
                        results = append(results, &amp;Hit{
                                Type:  DashHitJson,
                                Title: item.Dashboard.Title,
                                Tags:  item.Dashboard.GetTags(),
                                Uri:   "file/" + item.Path,
                        })
                }</span>
        }

        <span class="cov8" title="1">return results, nil</span>
}

func (index *JsonDashIndex) GetDashboard(path string) *m.Dashboard <span class="cov0" title="0">{
        for _, item := range index.items </span><span class="cov0" title="0">{
                if item.Path == path </span><span class="cov0" title="0">{
                        return item.Dashboard
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (index *JsonDashIndex) updateIndex() error <span class="cov8" title="1">{
        var items = make([]*JsonDashIndexItem, 0)

        visitor := func(path string, f os.FileInfo, err error) error </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if f.IsDir() </span><span class="cov8" title="1">{
                        return nil
                }</span>

                <span class="cov8" title="1">if strings.HasSuffix(f.Name(), ".json") </span><span class="cov8" title="1">{
                        dash, err := loadDashboardFromFile(path)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov8" title="1">items = append(items, dash)</span>
                }

                <span class="cov8" title="1">return nil</span>
        }

        <span class="cov8" title="1">if err := filepath.Walk(index.path, visitor); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">index.items = items
        return nil</span>
}

func loadDashboardFromFile(filename string) (*JsonDashIndexItem, error) <span class="cov8" title="1">{
        reader, err := os.Open(filename)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer reader.Close()

        data, err := simplejson.NewFromReader(reader)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">stat, _ := os.Stat(filename)

        item := &amp;JsonDashIndexItem{}
        item.Dashboard = m.NewDashboardFromJson(data)
        item.TitleLower = strings.ToLower(item.Dashboard.Title)
        item.TagsCsv = strings.Join(item.Dashboard.GetTags(), ",")
        item.Path = stat.Name()

        return item, nil</span>
}
</pre>
		
		<pre class="file" id="file143" style="display: none">package search

type HitType string

const (
        DashHitDB       HitType = "dash-db"
        DashHitHome     HitType = "dash-home"
        DashHitJson     HitType = "dash-json"
        DashHitScripted HitType = "dash-scripted"
)

type Hit struct {
        Id        int64    `json:"id"`
        Title     string   `json:"title"`
        Uri       string   `json:"uri"`
        Type      HitType  `json:"type"`
        Tags      []string `json:"tags"`
        IsStarred bool     `json:"isStarred"`
}

type HitList []*Hit

func (s HitList) Len() int           <span class="cov8" title="1">{ return len(s) }</span>
func (s HitList) Swap(i, j int)      <span class="cov8" title="1">{ s[i], s[j] = s[j], s[i] }</span>
func (s HitList) Less(i, j int) bool <span class="cov8" title="1">{ return s[i].Title &lt; s[j].Title }</span>

type Query struct {
        Title        string
        Tags         []string
        OrgId        int64
        UserId       int64
        Limit        int
        IsStarred    bool
        DashboardIds []int

        Result HitList
}

type FindPersistedDashboardsQuery struct {
        Title        string
        OrgId        int64
        UserId       int64
        IsStarred    bool
        DashboardIds []int

        Result HitList
}
</pre>
		
		<pre class="file" id="file144" style="display: none">package sqlstore

import (
        "bytes"
        "fmt"
        "strings"
        "time"

        "github.com/go-xorm/xorm"
        "github.com/grafana/grafana/pkg/bus"
        m "github.com/grafana/grafana/pkg/models"
)

func init() <span class="cov8" title="1">{
        bus.AddHandler("sql", SaveAlerts)
        bus.AddHandler("sql", HandleAlertsQuery)
        bus.AddHandler("sql", GetAlertById)
        bus.AddHandler("sql", DeleteAlertById)
        bus.AddHandler("sql", GetAllAlertQueryHandler)
        bus.AddHandler("sql", SetAlertState)
        bus.AddHandler("sql", GetAlertStatesForDashboard)
        bus.AddHandler("sql", PauseAlert)
        bus.AddHandler("sql", PauseAllAlerts)
}</span>

func GetAlertById(query *m.GetAlertByIdQuery) error <span class="cov0" title="0">{
        alert := m.Alert{}
        has, err := x.Id(query.Id).Get(&amp;alert)
        if !has </span><span class="cov0" title="0">{
                return fmt.Errorf("could not find alert")
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">query.Result = &amp;alert
        return nil</span>
}

func GetAllAlertQueryHandler(query *m.GetAllAlertsQuery) error <span class="cov0" title="0">{
        var alerts []*m.Alert
        err := x.Sql("select * from alert").Find(&amp;alerts)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">query.Result = alerts
        return nil</span>
}

func deleteAlertByIdInternal(alertId int64, reason string, sess *xorm.Session) error <span class="cov8" title="1">{
        sqlog.Debug("Deleting alert", "id", alertId, "reason", reason)

        if _, err := sess.Exec("DELETE FROM alert WHERE id = ?", alertId); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if _, err := sess.Exec("DELETE FROM annotation WHERE alert_id = ?", alertId); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func DeleteAlertById(cmd *m.DeleteAlertCommand) error <span class="cov0" title="0">{
        return inTransaction(func(sess *xorm.Session) error </span><span class="cov0" title="0">{
                return deleteAlertByIdInternal(cmd.AlertId, "DeleteAlertCommand", sess)
        }</span>)
}

func HandleAlertsQuery(query *m.GetAlertsQuery) error <span class="cov8" title="1">{
        var sql bytes.Buffer
        params := make([]interface{}, 0)

        sql.WriteString(`SELECT *
                                                from alert
                                                `)

        sql.WriteString(`WHERE org_id = ?`)
        params = append(params, query.OrgId)

        if query.DashboardId != 0 </span><span class="cov8" title="1">{
                sql.WriteString(` AND dashboard_id = ?`)
                params = append(params, query.DashboardId)
        }</span>

        <span class="cov8" title="1">if query.PanelId != 0 </span><span class="cov8" title="1">{
                sql.WriteString(` AND panel_id = ?`)
                params = append(params, query.PanelId)
        }</span>

        <span class="cov8" title="1">if len(query.State) &gt; 0 &amp;&amp; query.State[0] != "ALL" </span><span class="cov0" title="0">{
                sql.WriteString(` AND (`)
                for i, v := range query.State </span><span class="cov0" title="0">{
                        if i &gt; 0 </span><span class="cov0" title="0">{
                                sql.WriteString(" OR ")
                        }</span>
                        <span class="cov0" title="0">sql.WriteString("state = ? ")
                        params = append(params, v)</span>
                }
                <span class="cov0" title="0">sql.WriteString(")")</span>
        }

        <span class="cov8" title="1">if query.Limit != 0 </span><span class="cov0" title="0">{
                sql.WriteString(" LIMIT ?")
                params = append(params, query.Limit)
        }</span>

        <span class="cov8" title="1">sql.WriteString(" ORDER BY name ASC")

        alerts := make([]*m.Alert, 0)
        if err := x.Sql(sql.String(), params...).Find(&amp;alerts); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">for i := range alerts </span><span class="cov8" title="1">{
                if alerts[i].ExecutionError == " " </span><span class="cov0" title="0">{
                        alerts[i].ExecutionError = ""
                }</span>
        }

        <span class="cov8" title="1">query.Result = alerts
        return nil</span>
}

func DeleteAlertDefinition(dashboardId int64, sess *xorm.Session) error <span class="cov8" title="1">{
        alerts := make([]*m.Alert, 0)
        sess.Where("dashboard_id = ?", dashboardId).Find(&amp;alerts)

        for _, alert := range alerts </span><span class="cov8" title="1">{
                deleteAlertByIdInternal(alert.Id, "Dashboard deleted", sess)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func SaveAlerts(cmd *m.SaveAlertsCommand) error <span class="cov8" title="1">{
        return inTransaction(func(sess *xorm.Session) error </span><span class="cov8" title="1">{
                existingAlerts, err := GetAlertsByDashboardId2(cmd.DashboardId, sess)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">if err := upsertAlerts(existingAlerts, cmd, sess); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">if err := deleteMissingAlerts(existingAlerts, cmd, sess); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">return nil</span>
        })
}

func upsertAlerts(existingAlerts []*m.Alert, cmd *m.SaveAlertsCommand, sess *xorm.Session) error <span class="cov8" title="1">{
        for _, alert := range cmd.Alerts </span><span class="cov8" title="1">{
                update := false
                var alertToUpdate *m.Alert

                for _, k := range existingAlerts </span><span class="cov8" title="1">{
                        if alert.PanelId == k.PanelId </span><span class="cov8" title="1">{
                                update = true
                                alert.Id = k.Id
                                alertToUpdate = k
                                break</span>
                        }
                }

                <span class="cov8" title="1">if update </span><span class="cov8" title="1">{
                        if alertToUpdate.ContainsUpdates(alert) </span><span class="cov8" title="1">{
                                alert.Updated = time.Now()
                                alert.State = alertToUpdate.State
                                _, err := sess.Id(alert.Id).Update(alert)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>

                                <span class="cov8" title="1">sqlog.Debug("Alert updated", "name", alert.Name, "id", alert.Id)</span>
                        }
                }<span class="cov8" title="1"> else {
                        alert.Updated = time.Now()
                        alert.Created = time.Now()
                        alert.State = m.AlertStatePending
                        alert.NewStateDate = time.Now()

                        _, err := sess.Insert(alert)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov8" title="1">sqlog.Debug("Alert inserted", "name", alert.Name, "id", alert.Id)</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

func deleteMissingAlerts(alerts []*m.Alert, cmd *m.SaveAlertsCommand, sess *xorm.Session) error <span class="cov8" title="1">{
        for _, missingAlert := range alerts </span><span class="cov8" title="1">{
                missing := true

                for _, k := range cmd.Alerts </span><span class="cov8" title="1">{
                        if missingAlert.PanelId == k.PanelId </span><span class="cov8" title="1">{
                                missing = false
                                break</span>
                        }
                }

                <span class="cov8" title="1">if missing </span><span class="cov8" title="1">{
                        deleteAlertByIdInternal(missingAlert.Id, "Removed from dashboard", sess)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func GetAlertsByDashboardId2(dashboardId int64, sess *xorm.Session) ([]*m.Alert, error) <span class="cov8" title="1">{
        alerts := make([]*m.Alert, 0)
        err := sess.Where("dashboard_id = ?", dashboardId).Find(&amp;alerts)

        if err != nil </span><span class="cov0" title="0">{
                return []*m.Alert{}, err
        }</span>

        <span class="cov8" title="1">return alerts, nil</span>
}

func SetAlertState(cmd *m.SetAlertStateCommand) error <span class="cov8" title="1">{
        return inTransaction(func(sess *xorm.Session) error </span><span class="cov8" title="1">{
                alert := m.Alert{}

                if has, err := sess.Id(cmd.AlertId).Get(&amp;alert); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span><span class="cov8" title="1"> else if !has </span><span class="cov0" title="0">{
                        return fmt.Errorf("Could not find alert")
                }</span>

                <span class="cov8" title="1">if alert.State == m.AlertStatePaused </span><span class="cov8" title="1">{
                        return m.ErrCannotChangeStateOnPausedAlert
                }</span>

                <span class="cov8" title="1">if alert.State == cmd.State </span><span class="cov0" title="0">{
                        return m.ErrRequiresNewState
                }</span>

                <span class="cov8" title="1">alert.State = cmd.State
                alert.StateChanges += 1
                alert.NewStateDate = time.Now()
                alert.EvalData = cmd.EvalData

                if cmd.Error == "" </span><span class="cov8" title="1">{
                        alert.ExecutionError = " " //without this space, xorm skips updating this field
                }</span><span class="cov0" title="0"> else {
                        alert.ExecutionError = cmd.Error
                }</span>

                <span class="cov8" title="1">sess.Id(alert.Id).Update(&amp;alert)
                return nil</span>
        })
}

func PauseAlert(cmd *m.PauseAlertCommand) error <span class="cov0" title="0">{
        return inTransaction(func(sess *xorm.Session) error </span><span class="cov0" title="0">{
                if len(cmd.AlertIds) == 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("command contains no alertids")
                }</span>

                <span class="cov0" title="0">var buffer bytes.Buffer
                params := make([]interface{}, 0)

                buffer.WriteString(`UPDATE alert SET state = ?`)
                if cmd.Paused </span><span class="cov0" title="0">{
                        params = append(params, string(m.AlertStatePaused))
                }</span><span class="cov0" title="0"> else {
                        params = append(params, string(m.AlertStatePending))
                }</span>

                <span class="cov0" title="0">buffer.WriteString(` WHERE id IN (?` + strings.Repeat(",?", len(cmd.AlertIds)-1) + `)`)
                for _, v := range cmd.AlertIds </span><span class="cov0" title="0">{
                        params = append(params, v)
                }</span>

                <span class="cov0" title="0">res, err := sess.Exec(buffer.String(), params...)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">cmd.ResultCount, _ = res.RowsAffected()
                return nil</span>
        })
}

func PauseAllAlerts(cmd *m.PauseAllAlertCommand) error <span class="cov8" title="1">{
        return inTransaction(func(sess *xorm.Session) error </span><span class="cov8" title="1">{
                var newState string
                if cmd.Paused </span><span class="cov8" title="1">{
                        newState = string(m.AlertStatePaused)
                }</span><span class="cov0" title="0"> else {
                        newState = string(m.AlertStatePending)
                }</span>

                <span class="cov8" title="1">res, err := sess.Exec(`UPDATE alert SET state = ?`, newState)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">cmd.ResultCount, _ = res.RowsAffected()
                return nil</span>
        })
}

func GetAlertStatesForDashboard(query *m.GetAlertStatesForDashboardQuery) error <span class="cov0" title="0">{
        var rawSql = `SELECT
                        id,
                        dashboard_id,
                        panel_id,
                        state,
                        new_state_date
                        FROM alert
                        WHERE org_id = ? AND dashboard_id = ?`

        query.Result = make([]*m.AlertStateInfoDTO, 0)
        err := x.Sql(rawSql, query.OrgId, query.DashboardId).Find(&amp;query.Result)

        return err
}</span>
</pre>
		
		<pre class="file" id="file145" style="display: none">package sqlstore

import (
        "bytes"
        "fmt"
        "strings"
        "time"

        "github.com/go-xorm/xorm"
        "github.com/grafana/grafana/pkg/bus"
        m "github.com/grafana/grafana/pkg/models"
)

func init() <span class="cov8" title="1">{
        bus.AddHandler("sql", GetAlertNotifications)
        bus.AddHandler("sql", CreateAlertNotificationCommand)
        bus.AddHandler("sql", UpdateAlertNotification)
        bus.AddHandler("sql", DeleteAlertNotification)
        bus.AddHandler("sql", GetAlertNotificationsToSend)
        bus.AddHandler("sql", GetAllAlertNotifications)
}</span>

func DeleteAlertNotification(cmd *m.DeleteAlertNotificationCommand) error <span class="cov0" title="0">{
        return inTransaction(func(sess *xorm.Session) error </span><span class="cov0" title="0">{
                sql := "DELETE FROM alert_notification WHERE alert_notification.org_id = ? AND alert_notification.id = ?"
                _, err := sess.Exec(sql, cmd.OrgId, cmd.Id)

                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">return nil</span>
        })
}

func GetAlertNotifications(query *m.GetAlertNotificationsQuery) error <span class="cov8" title="1">{
        return getAlertNotificationInternal(query, x.NewSession())
}</span>

func GetAllAlertNotifications(query *m.GetAllAlertNotificationsQuery) error <span class="cov8" title="1">{
        results := make([]*m.AlertNotification, 0)
        if err := x.Where("org_id = ?", query.OrgId).Find(&amp;results); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">query.Result = results
        return nil</span>
}

func GetAlertNotificationsToSend(query *m.GetAlertNotificationsToSendQuery) error <span class="cov8" title="1">{
        var sql bytes.Buffer
        params := make([]interface{}, 0)

        sql.WriteString(`SELECT
                                                                                alert_notification.id,
                                                                                alert_notification.org_id,
                                                                                alert_notification.name,
                                                                                alert_notification.type,
                                                                                alert_notification.created,
                                                                                alert_notification.updated,
                                                                                alert_notification.settings,
                                                                                alert_notification.is_default
                                                                                FROM alert_notification
                                                                  `)

        sql.WriteString(` WHERE alert_notification.org_id = ?`)
        params = append(params, query.OrgId)

        sql.WriteString(` AND ((alert_notification.is_default = ?)`)
        params = append(params, dialect.BooleanStr(true))
        if len(query.Ids) &gt; 0 </span><span class="cov8" title="1">{
                sql.WriteString(` OR alert_notification.id IN (?` + strings.Repeat(",?", len(query.Ids)-1) + ")")
                for _, v := range query.Ids </span><span class="cov8" title="1">{
                        params = append(params, v)
                }</span>
        }
        <span class="cov8" title="1">sql.WriteString(`)`)

        results := make([]*m.AlertNotification, 0)
        if err := x.Sql(sql.String(), params...).Find(&amp;results); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">query.Result = results
        return nil</span>
}

func getAlertNotificationInternal(query *m.GetAlertNotificationsQuery, sess *xorm.Session) error <span class="cov8" title="1">{
        var sql bytes.Buffer
        params := make([]interface{}, 0)

        sql.WriteString(`SELECT
                                                                                alert_notification.id,
                                                                                alert_notification.org_id,
                                                                                alert_notification.name,
                                                                                alert_notification.type,
                                                                                alert_notification.created,
                                                                                alert_notification.updated,
                                                                                alert_notification.settings,
                                                                                alert_notification.is_default
                                                                                FROM alert_notification
                                                                  `)

        sql.WriteString(` WHERE alert_notification.org_id = ?`)
        params = append(params, query.OrgId)

        if query.Name != "" || query.Id != 0 </span><span class="cov8" title="1">{
                if query.Name != "" </span><span class="cov8" title="1">{
                        sql.WriteString(` AND alert_notification.name = ?`)
                        params = append(params, query.Name)
                }</span>

                <span class="cov8" title="1">if query.Id != 0 </span><span class="cov0" title="0">{
                        sql.WriteString(` AND alert_notification.id = ?`)
                        params = append(params, query.Id)
                }</span>
        }

        <span class="cov8" title="1">results := make([]*m.AlertNotification, 0)
        if err := sess.Sql(sql.String(), params...).Find(&amp;results); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if len(results) == 0 </span><span class="cov8" title="1">{
                query.Result = nil
        }</span><span class="cov8" title="1"> else {
                query.Result = results[0]
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func CreateAlertNotificationCommand(cmd *m.CreateAlertNotificationCommand) error <span class="cov8" title="1">{
        return inTransaction(func(sess *xorm.Session) error </span><span class="cov8" title="1">{
                existingQuery := &amp;m.GetAlertNotificationsQuery{OrgId: cmd.OrgId, Name: cmd.Name}
                err := getAlertNotificationInternal(existingQuery, sess)

                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">if existingQuery.Result != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("Alert notification name %s already exists", cmd.Name)
                }</span>

                <span class="cov8" title="1">alertNotification := &amp;m.AlertNotification{
                        OrgId:     cmd.OrgId,
                        Name:      cmd.Name,
                        Type:      cmd.Type,
                        Settings:  cmd.Settings,
                        Created:   time.Now(),
                        Updated:   time.Now(),
                        IsDefault: cmd.IsDefault,
                }

                if _, err = sess.Insert(alertNotification); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">cmd.Result = alertNotification
                return nil</span>
        })
}

func UpdateAlertNotification(cmd *m.UpdateAlertNotificationCommand) error <span class="cov8" title="1">{
        return inTransaction(func(sess *xorm.Session) (err error) </span><span class="cov8" title="1">{
                current := m.AlertNotification{}

                if _, err = sess.Id(cmd.Id).Get(&amp;current); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // check if name exists
                <span class="cov8" title="1">sameNameQuery := &amp;m.GetAlertNotificationsQuery{OrgId: cmd.OrgId, Name: cmd.Name}
                if err := getAlertNotificationInternal(sameNameQuery, sess); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">if sameNameQuery.Result != nil &amp;&amp; sameNameQuery.Result.Id != current.Id </span><span class="cov0" title="0">{
                        return fmt.Errorf("Alert notification name %s already exists", cmd.Name)
                }</span>

                <span class="cov8" title="1">current.Updated = time.Now()
                current.Settings = cmd.Settings
                current.Name = cmd.Name
                current.Type = cmd.Type
                current.IsDefault = cmd.IsDefault

                sess.UseBool("is_default")

                if affected, err := sess.Id(cmd.Id).Update(current); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span><span class="cov8" title="1"> else if affected == 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("Could not find alert notification")
                }</span>

                <span class="cov8" title="1">cmd.Result = &amp;current
                return nil</span>
        })
}
</pre>
		
		<pre class="file" id="file146" style="display: none">package sqlstore

import (
        "bytes"
        "fmt"
        "strings"

        "github.com/go-xorm/xorm"
        "github.com/grafana/grafana/pkg/services/annotations"
)

type SqlAnnotationRepo struct {
}

func (r *SqlAnnotationRepo) Save(item *annotations.Item) error <span class="cov0" title="0">{
        return inTransaction(func(sess *xorm.Session) error </span><span class="cov0" title="0">{

                if _, err := sess.Table("annotation").Insert(item); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">return nil</span>
        })
}

func (r *SqlAnnotationRepo) Find(query *annotations.ItemQuery) ([]*annotations.Item, error) <span class="cov0" title="0">{
        var sql bytes.Buffer
        params := make([]interface{}, 0)

        sql.WriteString(`SELECT *
                                                from annotation
                                                `)

        sql.WriteString(`WHERE org_id = ?`)
        params = append(params, query.OrgId)

        if query.AlertId != 0 </span><span class="cov0" title="0">{
                sql.WriteString(` AND alert_id = ?`)
                params = append(params, query.AlertId)
        }</span>

        <span class="cov0" title="0">if query.AlertId != 0 </span><span class="cov0" title="0">{
                sql.WriteString(` AND alert_id = ?`)
                params = append(params, query.AlertId)
        }</span>

        <span class="cov0" title="0">if query.DashboardId != 0 </span><span class="cov0" title="0">{
                sql.WriteString(` AND dashboard_id = ?`)
                params = append(params, query.DashboardId)
        }</span>

        <span class="cov0" title="0">if query.PanelId != 0 </span><span class="cov0" title="0">{
                sql.WriteString(` AND panel_id = ?`)
                params = append(params, query.PanelId)
        }</span>

        <span class="cov0" title="0">if query.From &gt; 0 &amp;&amp; query.To &gt; 0 </span><span class="cov0" title="0">{
                sql.WriteString(` AND epoch BETWEEN ? AND ?`)
                params = append(params, query.From, query.To)
        }</span>

        <span class="cov0" title="0">if query.Type != "" </span><span class="cov0" title="0">{
                sql.WriteString(` AND type = ?`)
                params = append(params, string(query.Type))
        }</span>

        <span class="cov0" title="0">if len(query.NewState) &gt; 0 </span><span class="cov0" title="0">{
                sql.WriteString(` AND new_state IN (?` + strings.Repeat(",?", len(query.NewState)-1) + ")")
                for _, v := range query.NewState </span><span class="cov0" title="0">{
                        params = append(params, v)
                }</span>
        }

        <span class="cov0" title="0">if query.Limit == 0 </span><span class="cov0" title="0">{
                query.Limit = 10
        }</span>

        <span class="cov0" title="0">sql.WriteString(fmt.Sprintf(" ORDER BY epoch DESC LIMIT %v", query.Limit))

        items := make([]*annotations.Item, 0)
        if err := x.Sql(sql.String(), params...).Find(&amp;items); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return items, nil</span>
}

func (r *SqlAnnotationRepo) Delete(params *annotations.DeleteParams) error <span class="cov0" title="0">{
        return inTransaction(func(sess *xorm.Session) error </span><span class="cov0" title="0">{

                sql := "DELETE FROM annotation WHERE dashboard_id = ? AND panel_id = ?"

                _, err := sess.Exec(sql, params.DashboardId, params.PanelId)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">return nil</span>
        })
}
</pre>
		
		<pre class="file" id="file147" style="display: none">package sqlstore

import (
        "time"

        "github.com/go-xorm/xorm"
        "github.com/grafana/grafana/pkg/bus"
        m "github.com/grafana/grafana/pkg/models"
)

func init() <span class="cov8" title="1">{
        bus.AddHandler("sql", GetApiKeys)
        bus.AddHandler("sql", GetApiKeyById)
        bus.AddHandler("sql", GetApiKeyByName)
        bus.AddHandler("sql", DeleteApiKey)
        bus.AddHandler("sql", AddApiKey)
}</span>

func GetApiKeys(query *m.GetApiKeysQuery) error <span class="cov0" title="0">{
        sess := x.Limit(100, 0).Where("org_id=?", query.OrgId).Asc("name")

        query.Result = make([]*m.ApiKey, 0)
        return sess.Find(&amp;query.Result)
}</span>

func DeleteApiKey(cmd *m.DeleteApiKeyCommand) error <span class="cov0" title="0">{
        return inTransaction(func(sess *xorm.Session) error </span><span class="cov0" title="0">{
                var rawSql = "DELETE FROM api_key WHERE id=? and org_id=?"
                _, err := sess.Exec(rawSql, cmd.Id, cmd.OrgId)
                return err
        }</span>)
}

func AddApiKey(cmd *m.AddApiKeyCommand) error <span class="cov8" title="1">{
        return inTransaction(func(sess *xorm.Session) error </span><span class="cov8" title="1">{
                t := m.ApiKey{
                        OrgId:   cmd.OrgId,
                        Name:    cmd.Name,
                        Role:    cmd.Role,
                        Key:     cmd.Key,
                        Created: time.Now(),
                        Updated: time.Now(),
                }

                if _, err := sess.Insert(&amp;t); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">cmd.Result = &amp;t
                return nil</span>
        })
}

func GetApiKeyById(query *m.GetApiKeyByIdQuery) error <span class="cov0" title="0">{
        var apikey m.ApiKey
        has, err := x.Id(query.ApiKeyId).Get(&amp;apikey)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span><span class="cov0" title="0"> else if has == false </span><span class="cov0" title="0">{
                return m.ErrInvalidApiKey
        }</span>

        <span class="cov0" title="0">query.Result = &amp;apikey
        return nil</span>
}

func GetApiKeyByName(query *m.GetApiKeyByNameQuery) error <span class="cov8" title="1">{
        var apikey m.ApiKey
        has, err := x.Where("org_id=? AND name=?", query.OrgId, query.KeyName).Get(&amp;apikey)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span><span class="cov8" title="1"> else if has == false </span><span class="cov0" title="0">{
                return m.ErrInvalidApiKey
        }</span>

        <span class="cov8" title="1">query.Result = &amp;apikey
        return nil</span>
}
</pre>
		
		<pre class="file" id="file148" style="display: none">package sqlstore

import (
        "bytes"
        "fmt"

        "github.com/go-xorm/xorm"
        "github.com/grafana/grafana/pkg/bus"
        "github.com/grafana/grafana/pkg/metrics"
        m "github.com/grafana/grafana/pkg/models"
        "github.com/grafana/grafana/pkg/services/search"
)

func init() <span class="cov8" title="1">{
        bus.AddHandler("sql", SaveDashboard)
        bus.AddHandler("sql", GetDashboard)
        bus.AddHandler("sql", GetDashboards)
        bus.AddHandler("sql", DeleteDashboard)
        bus.AddHandler("sql", SearchDashboards)
        bus.AddHandler("sql", GetDashboardTags)
        bus.AddHandler("sql", GetDashboardSlugById)
        bus.AddHandler("sql", GetDashboardsByPluginId)
}</span>

func SaveDashboard(cmd *m.SaveDashboardCommand) error <span class="cov8" title="1">{
        return inTransaction(func(sess *xorm.Session) error </span><span class="cov8" title="1">{
                dash := cmd.GetDashboardModel()

                // try get existing dashboard
                var existing, sameTitle m.Dashboard

                if dash.Id &gt; 0 </span><span class="cov8" title="1">{
                        dashWithIdExists, err := sess.Where("id=? AND org_id=?", dash.Id, dash.OrgId).Get(&amp;existing)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">if !dashWithIdExists </span><span class="cov8" title="1">{
                                return m.ErrDashboardNotFound
                        }</span>

                        // check for is someone else has written in between
                        <span class="cov0" title="0">if dash.Version != existing.Version </span><span class="cov0" title="0">{
                                if cmd.Overwrite </span><span class="cov0" title="0">{
                                        dash.Version = existing.Version
                                }</span><span class="cov0" title="0"> else {
                                        return m.ErrDashboardVersionMismatch
                                }</span>
                        }

                        // do not allow plugin dashboard updates without overwrite flag
                        <span class="cov0" title="0">if existing.PluginId != "" &amp;&amp; cmd.Overwrite == false </span><span class="cov0" title="0">{
                                return m.UpdatePluginDashboardError{PluginId: existing.PluginId}
                        }</span>
                }

                <span class="cov8" title="1">sameTitleExists, err := sess.Where("org_id=? AND slug=?", dash.OrgId, dash.Slug).Get(&amp;sameTitle)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">if sameTitleExists </span><span class="cov8" title="1">{
                        // another dashboard with same name
                        if dash.Id != sameTitle.Id </span><span class="cov8" title="1">{
                                if cmd.Overwrite </span><span class="cov0" title="0">{
                                        dash.Id = sameTitle.Id
                                }</span><span class="cov8" title="1"> else {
                                        return m.ErrDashboardWithSameNameExists
                                }</span>
                        }
                }

                <span class="cov8" title="1">affectedRows := int64(0)

                if dash.Id == 0 </span><span class="cov8" title="1">{
                        metrics.M_Models_Dashboard_Insert.Inc(1)
                        affectedRows, err = sess.Insert(dash)
                }</span><span class="cov0" title="0"> else {
                        dash.Version += 1
                        dash.Data.Set("version", dash.Version)
                        affectedRows, err = sess.Id(dash.Id).Update(dash)
                }</span>

                <span class="cov8" title="1">if affectedRows == 0 </span><span class="cov0" title="0">{
                        return m.ErrDashboardNotFound
                }</span>

                // delete existing tabs
                <span class="cov8" title="1">_, err = sess.Exec("DELETE FROM dashboard_tag WHERE dashboard_id=?", dash.Id)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // insert new tags
                <span class="cov8" title="1">tags := dash.GetTags()
                if len(tags) &gt; 0 </span><span class="cov8" title="1">{
                        for _, tag := range tags </span><span class="cov8" title="1">{
                                if _, err := sess.Insert(&amp;DashboardTag{DashboardId: dash.Id, Term: tag}); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                }

                <span class="cov8" title="1">cmd.Result = dash

                return err</span>
        })
}

func GetDashboard(query *m.GetDashboardQuery) error <span class="cov8" title="1">{
        dashboard := m.Dashboard{Slug: query.Slug, OrgId: query.OrgId}
        has, err := x.Get(&amp;dashboard)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span><span class="cov8" title="1"> else if has == false </span><span class="cov0" title="0">{
                return m.ErrDashboardNotFound
        }</span>

        <span class="cov8" title="1">dashboard.Data.Set("id", dashboard.Id)
        query.Result = &amp;dashboard

        return nil</span>
}

type DashboardSearchProjection struct {
        Id    int64
        Title string
        Slug  string
        Term  string
}

func SearchDashboards(query *search.FindPersistedDashboardsQuery) error <span class="cov8" title="1">{
        var sql bytes.Buffer
        params := make([]interface{}, 0)

        sql.WriteString(`SELECT
                                          dashboard.id,
                                          dashboard.title,
                                          dashboard.slug,
                                          dashboard_tag.term
                                        FROM dashboard
                                        LEFT OUTER JOIN dashboard_tag on dashboard_tag.dashboard_id = dashboard.id`)

        if query.IsStarred </span><span class="cov8" title="1">{
                sql.WriteString(" INNER JOIN star on star.dashboard_id = dashboard.id")
        }</span>

        <span class="cov8" title="1">sql.WriteString(` WHERE dashboard.org_id=?`)

        params = append(params, query.OrgId)

        if query.IsStarred </span><span class="cov8" title="1">{
                sql.WriteString(` AND star.user_id=?`)
                params = append(params, query.UserId)
        }</span>

        <span class="cov8" title="1">if len(query.DashboardIds) &gt; 0 </span><span class="cov8" title="1">{
                sql.WriteString(" AND (")
                for i, dashboardId := range query.DashboardIds </span><span class="cov8" title="1">{
                        if i != 0 </span><span class="cov8" title="1">{
                                sql.WriteString(" OR")
                        }</span>

                        <span class="cov8" title="1">sql.WriteString(" dashboard.id = ?")
                        params = append(params, dashboardId)</span>
                }
                <span class="cov8" title="1">sql.WriteString(")")</span>
        }

        <span class="cov8" title="1">if len(query.Title) &gt; 0 </span><span class="cov8" title="1">{
                sql.WriteString(" AND dashboard.title " + dialect.LikeStr() + " ?")
                params = append(params, "%"+query.Title+"%")
        }</span>

        <span class="cov8" title="1">sql.WriteString(fmt.Sprintf(" ORDER BY dashboard.title ASC LIMIT 1000"))

        var res []DashboardSearchProjection

        err := x.Sql(sql.String(), params...).Find(&amp;res)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">query.Result = make([]*search.Hit, 0)
        hits := make(map[int64]*search.Hit)

        for _, item := range res </span><span class="cov8" title="1">{
                hit, exists := hits[item.Id]
                if !exists </span><span class="cov8" title="1">{
                        hit = &amp;search.Hit{
                                Id:    item.Id,
                                Title: item.Title,
                                Uri:   "db/" + item.Slug,
                                Type:  search.DashHitDB,
                                Tags:  []string{},
                        }
                        query.Result = append(query.Result, hit)
                        hits[item.Id] = hit
                }</span>
                <span class="cov8" title="1">if len(item.Term) &gt; 0 </span><span class="cov8" title="1">{
                        hit.Tags = append(hit.Tags, item.Term)
                }</span>
        }

        <span class="cov8" title="1">return err</span>
}

func GetDashboardTags(query *m.GetDashboardTagsQuery) error <span class="cov8" title="1">{
        sql := `SELECT
                                          COUNT(*) as count,
                                                term
                                        FROM dashboard
                                        INNER JOIN dashboard_tag on dashboard_tag.dashboard_id = dashboard.id
                                        WHERE dashboard.org_id=?
                                        GROUP BY term`

        query.Result = make([]*m.DashboardTagCloudItem, 0)
        sess := x.Sql(sql, query.OrgId)
        err := sess.Find(&amp;query.Result)
        return err
}</span>

func DeleteDashboard(cmd *m.DeleteDashboardCommand) error <span class="cov8" title="1">{
        return inTransaction2(func(sess *session) error </span><span class="cov8" title="1">{
                dashboard := m.Dashboard{Slug: cmd.Slug, OrgId: cmd.OrgId}
                has, err := sess.Get(&amp;dashboard)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span><span class="cov8" title="1"> else if has == false </span><span class="cov0" title="0">{
                        return m.ErrDashboardNotFound
                }</span>

                <span class="cov8" title="1">deletes := []string{
                        "DELETE FROM dashboard_tag WHERE dashboard_id = ? ",
                        "DELETE FROM star WHERE dashboard_id = ? ",
                        "DELETE FROM dashboard WHERE id = ?",
                        "DELETE FROM playlist_item WHERE type = 'dashboard_by_id' AND value = ?",
                }

                for _, sql := range deletes </span><span class="cov8" title="1">{
                        _, err := sess.Exec(sql, dashboard.Id)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                <span class="cov8" title="1">if err := DeleteAlertDefinition(dashboard.Id, sess.Session); err != nil </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov8" title="1">return nil</span>
        })
}

func GetDashboards(query *m.GetDashboardsQuery) error <span class="cov0" title="0">{
        if len(query.DashboardIds) == 0 </span><span class="cov0" title="0">{
                return m.ErrCommandValidationFailed
        }</span>

        <span class="cov0" title="0">var dashboards = make([]*m.Dashboard, 0)

        err := x.In("id", query.DashboardIds).Find(&amp;dashboards)
        query.Result = dashboards

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func GetDashboardsByPluginId(query *m.GetDashboardsByPluginIdQuery) error <span class="cov0" title="0">{
        var dashboards = make([]*m.Dashboard, 0)

        err := x.Where("org_id=? AND plugin_id=?", query.OrgId, query.PluginId).Find(&amp;dashboards)
        query.Result = dashboards

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

type DashboardSlugDTO struct {
        Slug string
}

func GetDashboardSlugById(query *m.GetDashboardSlugByIdQuery) error <span class="cov0" title="0">{
        var rawSql = `SELECT slug from dashboard WHERE Id=?`
        var slug = DashboardSlugDTO{}

        exists, err := x.Sql(rawSql, query.Id).Get(&amp;slug)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span><span class="cov0" title="0"> else if exists == false </span><span class="cov0" title="0">{
                return m.ErrDashboardNotFound
        }</span>

        <span class="cov0" title="0">query.Result = slug.Slug
        return nil</span>
}
</pre>
		
		<pre class="file" id="file149" style="display: none">package sqlstore

import (
        "time"

        "github.com/go-xorm/xorm"
        "github.com/grafana/grafana/pkg/bus"
        m "github.com/grafana/grafana/pkg/models"
        "github.com/grafana/grafana/pkg/setting"
)

func init() <span class="cov8" title="1">{
        bus.AddHandler("sql", CreateDashboardSnapshot)
        bus.AddHandler("sql", GetDashboardSnapshot)
        bus.AddHandler("sql", DeleteDashboardSnapshot)
        bus.AddHandler("sql", SearchDashboardSnapshots)
        bus.AddHandler("sql", DeleteExpiredSnapshots)
}</span>

func DeleteExpiredSnapshots(cmd *m.DeleteExpiredSnapshotsCommand) error <span class="cov0" title="0">{
        return inTransaction(func(sess *xorm.Session) error </span><span class="cov0" title="0">{
                var expiredCount int64 = 0

                if setting.SnapShotRemoveExpired </span><span class="cov0" title="0">{
                        deleteExpiredSql := "DELETE FROM dashboard_snapshot WHERE expires &lt; ?"
                        expiredResponse, err := x.Exec(deleteExpiredSql, time.Now)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">expiredCount, _ = expiredResponse.RowsAffected()</span>
                }

                <span class="cov0" title="0">sqlog.Debug("Deleted old/expired snaphots", "expired", expiredCount)
                return nil</span>
        })
}

func CreateDashboardSnapshot(cmd *m.CreateDashboardSnapshotCommand) error <span class="cov8" title="1">{
        return inTransaction(func(sess *xorm.Session) error </span><span class="cov8" title="1">{

                // never
                var expires = time.Now().Add(time.Hour * 24 * 365 * 50)
                if cmd.Expires &gt; 0 </span><span class="cov0" title="0">{
                        expires = time.Now().Add(time.Second * time.Duration(cmd.Expires))
                }</span>

                <span class="cov8" title="1">snapshot := &amp;m.DashboardSnapshot{
                        Name:      cmd.Name,
                        Key:       cmd.Key,
                        DeleteKey: cmd.DeleteKey,
                        OrgId:     cmd.OrgId,
                        UserId:    cmd.UserId,
                        External:  cmd.External,
                        Dashboard: cmd.Dashboard,
                        Expires:   expires,
                        Created:   time.Now(),
                        Updated:   time.Now(),
                }

                _, err := sess.Insert(snapshot)
                cmd.Result = snapshot

                return err</span>
        })
}

func DeleteDashboardSnapshot(cmd *m.DeleteDashboardSnapshotCommand) error <span class="cov0" title="0">{
        return inTransaction(func(sess *xorm.Session) error </span><span class="cov0" title="0">{
                var rawSql = "DELETE FROM dashboard_snapshot WHERE delete_key=?"
                _, err := sess.Exec(rawSql, cmd.DeleteKey)
                return err
        }</span>)
}

func GetDashboardSnapshot(query *m.GetDashboardSnapshotQuery) error <span class="cov8" title="1">{
        snapshot := m.DashboardSnapshot{Key: query.Key}
        has, err := x.Get(&amp;snapshot)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span><span class="cov8" title="1"> else if has == false </span><span class="cov0" title="0">{
                return m.ErrDashboardSnapshotNotFound
        }</span>

        <span class="cov8" title="1">query.Result = &amp;snapshot
        return nil</span>
}

func SearchDashboardSnapshots(query *m.GetDashboardSnapshotsQuery) error <span class="cov0" title="0">{
        var snapshots = make(m.DashboardSnapshots, 0)

        sess := x.Limit(query.Limit)

        if query.Name != "" </span><span class="cov0" title="0">{
                sess.Where("name LIKE ?", query.Name)
        }</span>

        <span class="cov0" title="0">sess.Where("org_id = ?", query.OrgId)
        err := sess.Find(&amp;snapshots)
        query.Result = snapshots
        return err</span>
}
</pre>
		
		<pre class="file" id="file150" style="display: none">package sqlstore

import (
        "time"

        "github.com/grafana/grafana/pkg/bus"
        "github.com/grafana/grafana/pkg/components/securejsondata"
        m "github.com/grafana/grafana/pkg/models"

        "github.com/go-xorm/xorm"
)

func init() <span class="cov8" title="1">{
        bus.AddHandler("sql", GetDataSources)
        bus.AddHandler("sql", AddDataSource)
        bus.AddHandler("sql", DeleteDataSourceById)
        bus.AddHandler("sql", DeleteDataSourceByName)
        bus.AddHandler("sql", UpdateDataSource)
        bus.AddHandler("sql", GetDataSourceById)
        bus.AddHandler("sql", GetDataSourceByName)
}</span>

func GetDataSourceById(query *m.GetDataSourceByIdQuery) error <span class="cov0" title="0">{
        datasource := m.DataSource{OrgId: query.OrgId, Id: query.Id}
        has, err := x.Get(&amp;datasource)

        if !has </span><span class="cov0" title="0">{
                return m.ErrDataSourceNotFound
        }</span>

        <span class="cov0" title="0">query.Result = &amp;datasource
        return err</span>
}

func GetDataSourceByName(query *m.GetDataSourceByNameQuery) error <span class="cov0" title="0">{
        datasource := m.DataSource{OrgId: query.OrgId, Name: query.Name}
        has, err := x.Get(&amp;datasource)

        if !has </span><span class="cov0" title="0">{
                return m.ErrDataSourceNotFound
        }</span>

        <span class="cov0" title="0">query.Result = &amp;datasource
        return err</span>
}

func GetDataSources(query *m.GetDataSourcesQuery) error <span class="cov8" title="1">{
        sess := x.Limit(1000, 0).Where("org_id=?", query.OrgId).Asc("name")

        query.Result = make([]*m.DataSource, 0)
        return sess.Find(&amp;query.Result)
}</span>

func DeleteDataSourceById(cmd *m.DeleteDataSourceByIdCommand) error <span class="cov8" title="1">{
        return inTransaction(func(sess *xorm.Session) error </span><span class="cov8" title="1">{
                var rawSql = "DELETE FROM data_source WHERE id=? and org_id=?"
                _, err := sess.Exec(rawSql, cmd.Id, cmd.OrgId)
                return err
        }</span>)
}

func DeleteDataSourceByName(cmd *m.DeleteDataSourceByNameCommand) error <span class="cov8" title="1">{
        return inTransaction(func(sess *xorm.Session) error </span><span class="cov8" title="1">{
                var rawSql = "DELETE FROM data_source WHERE name=? and org_id=?"
                _, err := sess.Exec(rawSql, cmd.Name, cmd.OrgId)
                return err
        }</span>)
}

func AddDataSource(cmd *m.AddDataSourceCommand) error <span class="cov8" title="1">{

        return inTransaction(func(sess *xorm.Session) error </span><span class="cov8" title="1">{
                existing := m.DataSource{OrgId: cmd.OrgId, Name: cmd.Name}
                has, _ := sess.Get(&amp;existing)

                if has </span><span class="cov0" title="0">{
                        return m.ErrDataSourceNameExists
                }</span>

                <span class="cov8" title="1">ds := &amp;m.DataSource{
                        OrgId:             cmd.OrgId,
                        Name:              cmd.Name,
                        Type:              cmd.Type,
                        Access:            cmd.Access,
                        Url:               cmd.Url,
                        User:              cmd.User,
                        Password:          cmd.Password,
                        Database:          cmd.Database,
                        IsDefault:         cmd.IsDefault,
                        BasicAuth:         cmd.BasicAuth,
                        BasicAuthUser:     cmd.BasicAuthUser,
                        BasicAuthPassword: cmd.BasicAuthPassword,
                        WithCredentials:   cmd.WithCredentials,
                        JsonData:          cmd.JsonData,
                        SecureJsonData:    securejsondata.GetEncryptedJsonData(cmd.SecureJsonData),
                        Created:           time.Now(),
                        Updated:           time.Now(),
                }

                if _, err := sess.Insert(ds); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if err := updateIsDefaultFlag(ds, sess); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">cmd.Result = ds
                return nil</span>
        })
}

func updateIsDefaultFlag(ds *m.DataSource, sess *xorm.Session) error <span class="cov8" title="1">{
        // Handle is default flag
        if ds.IsDefault </span><span class="cov0" title="0">{
                rawSql := "UPDATE data_source SET is_default=? WHERE org_id=? AND id &lt;&gt; ?"
                if _, err := sess.Exec(rawSql, false, ds.OrgId, ds.Id); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func UpdateDataSource(cmd *m.UpdateDataSourceCommand) error <span class="cov0" title="0">{

        return inTransaction(func(sess *xorm.Session) error </span><span class="cov0" title="0">{
                ds := &amp;m.DataSource{
                        Id:                cmd.Id,
                        OrgId:             cmd.OrgId,
                        Name:              cmd.Name,
                        Type:              cmd.Type,
                        Access:            cmd.Access,
                        Url:               cmd.Url,
                        User:              cmd.User,
                        Password:          cmd.Password,
                        Database:          cmd.Database,
                        IsDefault:         cmd.IsDefault,
                        BasicAuth:         cmd.BasicAuth,
                        BasicAuthUser:     cmd.BasicAuthUser,
                        BasicAuthPassword: cmd.BasicAuthPassword,
                        WithCredentials:   cmd.WithCredentials,
                        JsonData:          cmd.JsonData,
                        SecureJsonData:    securejsondata.GetEncryptedJsonData(cmd.SecureJsonData),
                        Updated:           time.Now(),
                }

                sess.UseBool("is_default")
                sess.UseBool("basic_auth")
                sess.UseBool("with_credentials")

                _, err := sess.Where("id=? and org_id=?", ds.Id, ds.OrgId).Update(ds)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">err = updateIsDefaultFlag(ds, sess)
                return err</span>
        })
}
</pre>
		
		<pre class="file" id="file151" style="display: none">package migrations

import (
        . "github.com/grafana/grafana/pkg/services/sqlstore/migrator"
)

func addAlertMigrations(mg *Migrator) <span class="cov8" title="1">{

        alertV1 := Table{
                Name: "alert",
                Columns: []*Column{
                        {Name: "id", Type: DB_BigInt, IsPrimaryKey: true, IsAutoIncrement: true},
                        {Name: "version", Type: DB_BigInt, Nullable: false},
                        {Name: "dashboard_id", Type: DB_BigInt, Nullable: false},
                        {Name: "panel_id", Type: DB_BigInt, Nullable: false},
                        {Name: "org_id", Type: DB_BigInt, Nullable: false},
                        {Name: "name", Type: DB_NVarchar, Length: 255, Nullable: false},
                        {Name: "message", Type: DB_Text, Nullable: false},
                        {Name: "state", Type: DB_NVarchar, Length: 255, Nullable: false},
                        {Name: "settings", Type: DB_Text, Nullable: false},
                        {Name: "frequency", Type: DB_BigInt, Nullable: false},
                        {Name: "handler", Type: DB_BigInt, Nullable: false},
                        {Name: "severity", Type: DB_Text, Nullable: false},
                        {Name: "silenced", Type: DB_Bool, Nullable: false},
                        {Name: "execution_error", Type: DB_Text, Nullable: false},
                        {Name: "eval_data", Type: DB_Text, Nullable: true},
                        {Name: "eval_date", Type: DB_DateTime, Nullable: true},
                        {Name: "new_state_date", Type: DB_DateTime, Nullable: false},
                        {Name: "state_changes", Type: DB_Int, Nullable: false},
                        {Name: "created", Type: DB_DateTime, Nullable: false},
                        {Name: "updated", Type: DB_DateTime, Nullable: false},
                },
                Indices: []*Index{
                        {Cols: []string{"org_id", "id"}, Type: IndexType},
                        {Cols: []string{"state"}, Type: IndexType},
                        {Cols: []string{"dashboard_id"}, Type: IndexType},
                },
        }

        // create table
        mg.AddMigration("create alert table v1", NewAddTableMigration(alertV1))

        // create indices
        mg.AddMigration("add index alert org_id &amp; id ", NewAddIndexMigration(alertV1, alertV1.Indices[0]))
        mg.AddMigration("add index alert state", NewAddIndexMigration(alertV1, alertV1.Indices[1]))
        mg.AddMigration("add index alert dashboard_id", NewAddIndexMigration(alertV1, alertV1.Indices[2]))

        alert_notification := Table{
                Name: "alert_notification",
                Columns: []*Column{
                        {Name: "id", Type: DB_BigInt, IsPrimaryKey: true, IsAutoIncrement: true},
                        {Name: "org_id", Type: DB_BigInt, Nullable: false},
                        {Name: "name", Type: DB_NVarchar, Length: 255, Nullable: false},
                        {Name: "type", Type: DB_NVarchar, Length: 255, Nullable: false},
                        {Name: "settings", Type: DB_Text, Nullable: false},
                        {Name: "created", Type: DB_DateTime, Nullable: false},
                        {Name: "updated", Type: DB_DateTime, Nullable: false},
                },
                Indices: []*Index{
                        {Cols: []string{"org_id", "name"}, Type: UniqueIndex},
                },
        }

        mg.AddMigration("create alert_notification table v1", NewAddTableMigration(alert_notification))
        mg.AddMigration("Add column is_default", NewAddColumnMigration(alert_notification, &amp;Column{
                Name: "is_default", Type: DB_Bool, Nullable: false, Default: "0",
        }))
        mg.AddMigration("add index alert_notification org_id &amp; name", NewAddIndexMigration(alert_notification, alert_notification.Indices[0]))

}</span>
</pre>
		
		<pre class="file" id="file152" style="display: none">package migrations

import (
        . "github.com/grafana/grafana/pkg/services/sqlstore/migrator"
)

func addAnnotationMig(mg *Migrator) <span class="cov8" title="1">{

        table := Table{
                Name: "annotation",
                Columns: []*Column{
                        {Name: "id", Type: DB_BigInt, IsPrimaryKey: true, IsAutoIncrement: true},
                        {Name: "org_id", Type: DB_BigInt, Nullable: false},
                        {Name: "alert_id", Type: DB_BigInt, Nullable: true},
                        {Name: "user_id", Type: DB_BigInt, Nullable: true},
                        {Name: "dashboard_id", Type: DB_BigInt, Nullable: true},
                        {Name: "panel_id", Type: DB_BigInt, Nullable: true},
                        {Name: "category_id", Type: DB_BigInt, Nullable: true},
                        {Name: "type", Type: DB_NVarchar, Length: 25, Nullable: false},
                        {Name: "title", Type: DB_Text, Nullable: false},
                        {Name: "text", Type: DB_Text, Nullable: false},
                        {Name: "metric", Type: DB_NVarchar, Length: 255, Nullable: true},
                        {Name: "prev_state", Type: DB_NVarchar, Length: 25, Nullable: false},
                        {Name: "new_state", Type: DB_NVarchar, Length: 25, Nullable: false},
                        {Name: "data", Type: DB_Text, Nullable: false},
                        {Name: "epoch", Type: DB_BigInt, Nullable: false},
                },
                Indices: []*Index{
                        {Cols: []string{"org_id", "alert_id"}, Type: IndexType},
                        {Cols: []string{"org_id", "type"}, Type: IndexType},
                        {Cols: []string{"org_id", "category_id"}, Type: IndexType},
                        {Cols: []string{"org_id", "dashboard_id", "panel_id", "epoch"}, Type: IndexType},
                        {Cols: []string{"org_id", "epoch"}, Type: IndexType},
                },
        }

        mg.AddMigration("Drop old annotation table v4", NewDropTableMigration("annotation"))

        mg.AddMigration("create annotation table v5", NewAddTableMigration(table))

        // create indices
        mg.AddMigration("add index annotation 0 v3", NewAddIndexMigration(table, table.Indices[0]))
        mg.AddMigration("add index annotation 1 v3", NewAddIndexMigration(table, table.Indices[1]))
        mg.AddMigration("add index annotation 2 v3", NewAddIndexMigration(table, table.Indices[2]))
        mg.AddMigration("add index annotation 3 v3", NewAddIndexMigration(table, table.Indices[3]))
        mg.AddMigration("add index annotation 4 v3", NewAddIndexMigration(table, table.Indices[4]))
}</span>
</pre>
		
		<pre class="file" id="file153" style="display: none">package migrations

import . "github.com/grafana/grafana/pkg/services/sqlstore/migrator"

func addApiKeyMigrations(mg *Migrator) <span class="cov8" title="1">{
        apiKeyV1 := Table{
                Name: "api_key",
                Columns: []*Column{
                        {Name: "id", Type: DB_BigInt, IsPrimaryKey: true, IsAutoIncrement: true},
                        {Name: "account_id", Type: DB_BigInt, Nullable: false},
                        {Name: "name", Type: DB_NVarchar, Length: 255, Nullable: false},
                        {Name: "key", Type: DB_Varchar, Length: 64, Nullable: false},
                        {Name: "role", Type: DB_NVarchar, Length: 255, Nullable: false},
                        {Name: "created", Type: DB_DateTime, Nullable: false},
                        {Name: "updated", Type: DB_DateTime, Nullable: false},
                },
                Indices: []*Index{
                        {Cols: []string{"account_id"}},
                        {Cols: []string{"key"}, Type: UniqueIndex},
                        {Cols: []string{"account_id", "name"}, Type: UniqueIndex},
                },
        }

        // create table
        mg.AddMigration("create api_key table", NewAddTableMigration(apiKeyV1))
        // create indices
        mg.AddMigration("add index api_key.account_id", NewAddIndexMigration(apiKeyV1, apiKeyV1.Indices[0]))
        mg.AddMigration("add index api_key.key", NewAddIndexMigration(apiKeyV1, apiKeyV1.Indices[1]))
        mg.AddMigration("add index api_key.account_id_name", NewAddIndexMigration(apiKeyV1, apiKeyV1.Indices[2]))

        // ---------------------
        // account -&gt; org changes

        // drop indexes
        addDropAllIndicesMigrations(mg, "v1", apiKeyV1)
        // rename table
        addTableRenameMigration(mg, "api_key", "api_key_v1", "v1")

        apiKeyV2 := Table{
                Name: "api_key",
                Columns: []*Column{
                        {Name: "id", Type: DB_BigInt, IsPrimaryKey: true, IsAutoIncrement: true},
                        {Name: "org_id", Type: DB_BigInt, Nullable: false},
                        {Name: "name", Type: DB_NVarchar, Length: 255, Nullable: false},
                        {Name: "key", Type: DB_Varchar, Length: 255, Nullable: false},
                        {Name: "role", Type: DB_NVarchar, Length: 255, Nullable: false},
                        {Name: "created", Type: DB_DateTime, Nullable: false},
                        {Name: "updated", Type: DB_DateTime, Nullable: false},
                },
                Indices: []*Index{
                        {Cols: []string{"org_id"}},
                        {Cols: []string{"key"}, Type: UniqueIndex},
                        {Cols: []string{"org_id", "name"}, Type: UniqueIndex},
                },
        }

        // create v2 table
        mg.AddMigration("create api_key table v2", NewAddTableMigration(apiKeyV2))

        // add v2 indíces
        addTableIndicesMigrations(mg, "v2", apiKeyV2)

        //------- copy data from v1 to v2 -------------------
        mg.AddMigration("copy api_key v1 to v2", NewCopyTableDataMigration("api_key", "api_key_v1", map[string]string{
                "id":      "id",
                "org_id":  "account_id",
                "name":    "name",
                "key":     "key",
                "role":    "role",
                "created": "created",
                "updated": "updated",
        }))

        mg.AddMigration("Drop old table api_key_v1", NewDropTableMigration("api_key_v1"))
}</span>
</pre>
		
		<pre class="file" id="file154" style="display: none">package migrations

import (
        "fmt"

        . "github.com/grafana/grafana/pkg/services/sqlstore/migrator"
)

func addDropAllIndicesMigrations(mg *Migrator, versionSuffix string, table Table) <span class="cov8" title="1">{
        for _, index := range table.Indices </span><span class="cov8" title="1">{
                migrationId := fmt.Sprintf("drop index %s - %s", index.XName(table.Name), versionSuffix)
                mg.AddMigration(migrationId, NewDropIndexMigration(table, index))
        }</span>
}

func addTableIndicesMigrations(mg *Migrator, versionSuffix string, table Table) <span class="cov8" title="1">{
        for _, index := range table.Indices </span><span class="cov8" title="1">{
                migrationId := fmt.Sprintf("create index %s - %s", index.XName(table.Name), versionSuffix)
                mg.AddMigration(migrationId, NewAddIndexMigration(table, index))
        }</span>
}

func addTableRenameMigration(mg *Migrator, oldName string, newName string, versionSuffix string) <span class="cov8" title="1">{
        migrationId := fmt.Sprintf("Rename table %s to %s - %s", oldName, newName, versionSuffix)
        mg.AddMigration(migrationId, NewRenameTableMigration(oldName, newName))
}</span>
</pre>
		
		<pre class="file" id="file155" style="display: none">package migrations

import . "github.com/grafana/grafana/pkg/services/sqlstore/migrator"

func addDashboardMigration(mg *Migrator) <span class="cov8" title="1">{
        var dashboardV1 = Table{
                Name: "dashboard",
                Columns: []*Column{
                        {Name: "id", Type: DB_BigInt, IsPrimaryKey: true, IsAutoIncrement: true},
                        {Name: "version", Type: DB_Int, Nullable: false},
                        {Name: "slug", Type: DB_NVarchar, Length: 255, Nullable: false},
                        {Name: "title", Type: DB_NVarchar, Length: 255, Nullable: false},
                        {Name: "data", Type: DB_Text, Nullable: false},
                        {Name: "account_id", Type: DB_BigInt, Nullable: false},
                        {Name: "created", Type: DB_DateTime, Nullable: false},
                        {Name: "updated", Type: DB_DateTime, Nullable: false},
                },
                Indices: []*Index{
                        {Cols: []string{"account_id"}},
                        {Cols: []string{"account_id", "slug"}, Type: UniqueIndex},
                },
        }

        mg.AddMigration("create dashboard table", NewAddTableMigration(dashboardV1))

        //-------  indexes ------------------
        mg.AddMigration("add index dashboard.account_id", NewAddIndexMigration(dashboardV1, dashboardV1.Indices[0]))
        mg.AddMigration("add unique index dashboard_account_id_slug", NewAddIndexMigration(dashboardV1, dashboardV1.Indices[1]))

        dashboardTagV1 := Table{
                Name: "dashboard_tag",
                Columns: []*Column{
                        {Name: "id", Type: DB_BigInt, IsPrimaryKey: true, IsAutoIncrement: true},
                        {Name: "dashboard_id", Type: DB_BigInt, Nullable: false},
                        {Name: "term", Type: DB_NVarchar, Length: 50, Nullable: false},
                },
                Indices: []*Index{
                        {Cols: []string{"dashboard_id", "term"}, Type: UniqueIndex},
                },
        }

        mg.AddMigration("create dashboard_tag table", NewAddTableMigration(dashboardTagV1))
        mg.AddMigration("add unique index dashboard_tag.dasboard_id_term", NewAddIndexMigration(dashboardTagV1, dashboardTagV1.Indices[0]))

        // ---------------------
        // account -&gt; org changes

        //-------  drop dashboard indexes ------------------
        addDropAllIndicesMigrations(mg, "v1", dashboardTagV1)
        //------- rename table ------------------
        addTableRenameMigration(mg, "dashboard", "dashboard_v1", "v1")

        // dashboard v2
        var dashboardV2 = Table{
                Name: "dashboard",
                Columns: []*Column{
                        {Name: "id", Type: DB_BigInt, IsPrimaryKey: true, IsAutoIncrement: true},
                        {Name: "version", Type: DB_Int, Nullable: false},
                        {Name: "slug", Type: DB_NVarchar, Length: 255, Nullable: false},
                        {Name: "title", Type: DB_NVarchar, Length: 255, Nullable: false},
                        {Name: "data", Type: DB_Text, Nullable: false},
                        {Name: "org_id", Type: DB_BigInt, Nullable: false},
                        {Name: "created", Type: DB_DateTime, Nullable: false},
                        {Name: "updated", Type: DB_DateTime, Nullable: false},
                },
                Indices: []*Index{
                        {Cols: []string{"org_id"}},
                        {Cols: []string{"org_id", "slug"}, Type: UniqueIndex},
                },
        }

        // recreate table
        mg.AddMigration("create dashboard v2", NewAddTableMigration(dashboardV2))
        // recreate indices
        addTableIndicesMigrations(mg, "v2", dashboardV2)
        // copy data
        mg.AddMigration("copy dashboard v1 to v2", NewCopyTableDataMigration("dashboard", "dashboard_v1", map[string]string{
                "id":      "id",
                "version": "version",
                "slug":    "slug",
                "title":   "title",
                "data":    "data",
                "org_id":  "account_id",
                "created": "created",
                "updated": "updated",
        }))

        mg.AddMigration("drop table dashboard_v1", NewDropTableMigration("dashboard_v1"))

        // change column type of dashboard.data
        mg.AddMigration("alter dashboard.data to mediumtext v1", new(RawSqlMigration).
                Sqlite("SELECT 0 WHERE 0;").
                Postgres("SELECT 0;").
                Mysql("ALTER TABLE dashboard MODIFY data MEDIUMTEXT;"))

        // add column to store updater of a dashboard
        mg.AddMigration("Add column updated_by in dashboard - v2", NewAddColumnMigration(dashboardV2, &amp;Column{
                Name: "updated_by", Type: DB_Int, Nullable: true,
        }))

        // add column to store creator of a dashboard
        mg.AddMigration("Add column created_by in dashboard - v2", NewAddColumnMigration(dashboardV2, &amp;Column{
                Name: "created_by", Type: DB_Int, Nullable: true,
        }))

        // add column to store gnetId
        mg.AddMigration("Add column gnetId in dashboard", NewAddColumnMigration(dashboardV2, &amp;Column{
                Name: "gnet_id", Type: DB_BigInt, Nullable: true,
        }))

        mg.AddMigration("Add index for gnetId in dashboard", NewAddIndexMigration(dashboardV2, &amp;Index{
                Cols: []string{"gnet_id"}, Type: IndexType,
        }))

        // add column to store plugin_id
        mg.AddMigration("Add column plugin_id in dashboard", NewAddColumnMigration(dashboardV2, &amp;Column{
                Name: "plugin_id", Type: DB_NVarchar, Nullable: true, Length: 255,
        }))

        mg.AddMigration("Add index for plugin_id in dashboard", NewAddIndexMigration(dashboardV2, &amp;Index{
                Cols: []string{"org_id", "plugin_id"}, Type: IndexType,
        }))

        // dashboard_id index for dashboard_tag table
        mg.AddMigration("Add index for dashboard_id in dashboard_tag", NewAddIndexMigration(dashboardTagV1, &amp;Index{
                Cols: []string{"dashboard_id"}, Type: IndexType,
        }))
}</span>
</pre>
		
		<pre class="file" id="file156" style="display: none">package migrations

import . "github.com/grafana/grafana/pkg/services/sqlstore/migrator"

func addDashboardSnapshotMigrations(mg *Migrator) <span class="cov8" title="1">{
        snapshotV4 := Table{
                Name: "dashboard_snapshot",
                Columns: []*Column{
                        {Name: "id", Type: DB_BigInt, IsPrimaryKey: true, IsAutoIncrement: true},
                        {Name: "name", Type: DB_NVarchar, Length: 255, Nullable: false},
                        {Name: "key", Type: DB_NVarchar, Length: 255, Nullable: false},
                        {Name: "dashboard", Type: DB_Text, Nullable: false},
                        {Name: "expires", Type: DB_DateTime, Nullable: false},
                        {Name: "created", Type: DB_DateTime, Nullable: false},
                        {Name: "updated", Type: DB_DateTime, Nullable: false},
                },
                Indices: []*Index{
                        {Cols: []string{"key"}, Type: UniqueIndex},
                },
        }

        // add v4
        mg.AddMigration("create dashboard_snapshot table v4", NewAddTableMigration(snapshotV4))
        mg.AddMigration("drop table dashboard_snapshot_v4 #1", NewDropTableMigration("dashboard_snapshot"))

        snapshotV5 := Table{
                Name: "dashboard_snapshot",
                Columns: []*Column{
                        {Name: "id", Type: DB_BigInt, IsPrimaryKey: true, IsAutoIncrement: true},
                        {Name: "name", Type: DB_NVarchar, Length: 255, Nullable: false},
                        {Name: "key", Type: DB_NVarchar, Length: 255, Nullable: false},
                        {Name: "delete_key", Type: DB_NVarchar, Length: 255, Nullable: false},
                        {Name: "org_id", Type: DB_BigInt, Nullable: false},
                        {Name: "user_id", Type: DB_BigInt, Nullable: false},
                        {Name: "external", Type: DB_Bool, Nullable: false},
                        {Name: "external_url", Type: DB_NVarchar, Length: 255, Nullable: false},
                        {Name: "dashboard", Type: DB_Text, Nullable: false},
                        {Name: "expires", Type: DB_DateTime, Nullable: false},
                        {Name: "created", Type: DB_DateTime, Nullable: false},
                        {Name: "updated", Type: DB_DateTime, Nullable: false},
                },
                Indices: []*Index{
                        {Cols: []string{"key"}, Type: UniqueIndex},
                        {Cols: []string{"delete_key"}, Type: UniqueIndex},
                        {Cols: []string{"user_id"}},
                },
        }

        mg.AddMigration("create dashboard_snapshot table v5 #2", NewAddTableMigration(snapshotV5))
        addTableIndicesMigrations(mg, "v5", snapshotV5)

        // change column type of dashboard
        mg.AddMigration("alter dashboard_snapshot to mediumtext v2", new(RawSqlMigration).
                Sqlite("SELECT 0 WHERE 0;").
                Postgres("SELECT 0;").
                Mysql("ALTER TABLE dashboard_snapshot MODIFY dashboard MEDIUMTEXT;"))
}</span>
</pre>
		
		<pre class="file" id="file157" style="display: none">package migrations

import . "github.com/grafana/grafana/pkg/services/sqlstore/migrator"

func addDataSourceMigration(mg *Migrator) <span class="cov8" title="1">{
        var tableV1 = Table{
                Name: "data_source",
                Columns: []*Column{
                        {Name: "id", Type: DB_BigInt, IsPrimaryKey: true, IsAutoIncrement: true},
                        {Name: "account_id", Type: DB_BigInt, Nullable: false},
                        {Name: "version", Type: DB_Int, Nullable: false},
                        {Name: "type", Type: DB_NVarchar, Length: 255, Nullable: false},
                        {Name: "name", Type: DB_NVarchar, Length: 255, Nullable: false},
                        {Name: "access", Type: DB_NVarchar, Length: 255, Nullable: false},
                        {Name: "url", Type: DB_NVarchar, Length: 255, Nullable: false},
                        {Name: "password", Type: DB_NVarchar, Length: 255, Nullable: true},
                        {Name: "user", Type: DB_NVarchar, Length: 255, Nullable: true},
                        {Name: "database", Type: DB_NVarchar, Length: 255, Nullable: true},
                        {Name: "basic_auth", Type: DB_Bool, Nullable: false},
                        {Name: "basic_auth_user", Type: DB_NVarchar, Length: 255, Nullable: true},
                        {Name: "basic_auth_password", Type: DB_NVarchar, Length: 255, Nullable: true},
                        {Name: "is_default", Type: DB_Bool, Nullable: false},
                        {Name: "created", Type: DB_DateTime, Nullable: false},
                        {Name: "updated", Type: DB_DateTime, Nullable: false},
                },
                Indices: []*Index{
                        {Cols: []string{"account_id"}},
                        {Cols: []string{"account_id", "name"}, Type: UniqueIndex},
                },
        }

        mg.AddMigration("create data_source table", NewAddTableMigration(tableV1))
        mg.AddMigration("add index data_source.account_id", NewAddIndexMigration(tableV1, tableV1.Indices[0]))
        mg.AddMigration("add unique index data_source.account_id_name", NewAddIndexMigration(tableV1, tableV1.Indices[1]))

        // ---------------------
        // account -&gt; org changes

        // drop v1 indices
        addDropAllIndicesMigrations(mg, "v1", tableV1)
        // rename table
        addTableRenameMigration(mg, "data_source", "data_source_v1", "v1")

        // new table
        var tableV2 = Table{
                Name: "data_source",
                Columns: []*Column{
                        {Name: "id", Type: DB_BigInt, IsPrimaryKey: true, IsAutoIncrement: true},
                        {Name: "org_id", Type: DB_BigInt, Nullable: false},
                        {Name: "version", Type: DB_Int, Nullable: false},
                        {Name: "type", Type: DB_NVarchar, Length: 255, Nullable: false},
                        {Name: "name", Type: DB_NVarchar, Length: 255, Nullable: false},
                        {Name: "access", Type: DB_NVarchar, Length: 255, Nullable: false},
                        {Name: "url", Type: DB_NVarchar, Length: 255, Nullable: false},
                        {Name: "password", Type: DB_NVarchar, Length: 255, Nullable: true},
                        {Name: "user", Type: DB_NVarchar, Length: 255, Nullable: true},
                        {Name: "database", Type: DB_NVarchar, Length: 255, Nullable: true},
                        {Name: "basic_auth", Type: DB_Bool, Nullable: false},
                        {Name: "basic_auth_user", Type: DB_NVarchar, Length: 255, Nullable: true},
                        {Name: "basic_auth_password", Type: DB_NVarchar, Length: 255, Nullable: true},
                        {Name: "is_default", Type: DB_Bool, Nullable: false},
                        {Name: "json_data", Type: DB_Text, Nullable: true},
                        {Name: "created", Type: DB_DateTime, Nullable: false},
                        {Name: "updated", Type: DB_DateTime, Nullable: false},
                },
                Indices: []*Index{
                        {Cols: []string{"org_id"}},
                        {Cols: []string{"org_id", "name"}, Type: UniqueIndex},
                },
        }

        // create v2 table
        mg.AddMigration("create data_source table v2", NewAddTableMigration(tableV2))

        // add v2 indíces
        addTableIndicesMigrations(mg, "v2", tableV2)

        //------- copy data from v1 to v2 -------------------
        mg.AddMigration("copy data_source v1 to v2", NewCopyTableDataMigration("data_source", "data_source_v1", map[string]string{
                "id":                  "id",
                "org_id":              "account_id",
                "version":             "version",
                "type":                "type",
                "name":                "name",
                "access":              "access",
                "url":                 "url",
                "user":                "user",
                "password":            "password",
                "database":            "database",
                "basic_auth":          "basic_auth",
                "basic_auth_user":     "basic_auth_user",
                "basic_auth_password": "basic_auth_password",
                "is_default":          "is_default",
                "created":             "created",
                "updated":             "updated",
        }))

        mg.AddMigration("Drop old table data_source_v1 #2", NewDropTableMigration("data_source_v1"))

        // add column to activate withCredentials option
        mg.AddMigration("Add column with_credentials", NewAddColumnMigration(tableV2, &amp;Column{
                Name: "with_credentials", Type: DB_Bool, Nullable: false, Default: "0",
        }))

        // add column that can store TLS client auth data
        mg.AddMigration("Add secure json data column", NewAddColumnMigration(tableV2, &amp;Column{
                Name: "secure_json_data", Type: DB_Text, Nullable: true,
        }))
}</span>
</pre>
		
		<pre class="file" id="file158" style="display: none">package migrations

import . "github.com/grafana/grafana/pkg/services/sqlstore/migrator"

// --- Migration Guide line ---
// 1. Never change a migration that is committed and pushed to master
// 2. Always add new migrations (to change or undo previous migrations)
// 3. Some migrations are not yet written (rename column, table, drop table, index etc)

func AddMigrations(mg *Migrator) <span class="cov8" title="1">{
        addMigrationLogMigrations(mg)
        addUserMigrations(mg)
        addTempUserMigrations(mg)
        addStarMigrations(mg)
        addOrgMigrations(mg)
        addDashboardMigration(mg)
        addDataSourceMigration(mg)
        addApiKeyMigrations(mg)
        addDashboardSnapshotMigrations(mg)
        addQuotaMigration(mg)
        addAppSettingsMigration(mg)
        addSessionMigration(mg)
        addPlaylistMigrations(mg)
        addPreferencesMigrations(mg)
        addAlertMigrations(mg)
        addAnnotationMig(mg)
}</span>

func addMigrationLogMigrations(mg *Migrator) <span class="cov8" title="1">{
        migrationLogV1 := Table{
                Name: "migration_log",
                Columns: []*Column{
                        {Name: "id", Type: DB_BigInt, IsPrimaryKey: true, IsAutoIncrement: true},
                        {Name: "migration_id", Type: DB_NVarchar, Length: 255},
                        {Name: "sql", Type: DB_Text},
                        {Name: "success", Type: DB_Bool},
                        {Name: "error", Type: DB_Text},
                        {Name: "timestamp", Type: DB_DateTime},
                },
        }

        mg.AddMigration("create migration_log table", NewAddTableMigration(migrationLogV1))
}</span>

func addStarMigrations(mg *Migrator) <span class="cov8" title="1">{
        starV1 := Table{
                Name: "star",
                Columns: []*Column{
                        {Name: "id", Type: DB_BigInt, IsPrimaryKey: true, IsAutoIncrement: true},
                        {Name: "user_id", Type: DB_BigInt, Nullable: false},
                        {Name: "dashboard_id", Type: DB_BigInt, Nullable: false},
                },
                Indices: []*Index{
                        {Cols: []string{"user_id", "dashboard_id"}, Type: UniqueIndex},
                },
        }

        mg.AddMigration("create star table", NewAddTableMigration(starV1))
        mg.AddMigration("add unique index star.user_id_dashboard_id", NewAddIndexMigration(starV1, starV1.Indices[0]))
}</span>
</pre>
		
		<pre class="file" id="file159" style="display: none">package migrations

import . "github.com/grafana/grafana/pkg/services/sqlstore/migrator"

func addOrgMigrations(mg *Migrator) <span class="cov8" title="1">{
        orgV1 := Table{
                Name: "org",
                Columns: []*Column{
                        {Name: "id", Type: DB_BigInt, IsPrimaryKey: true, IsAutoIncrement: true},
                        {Name: "version", Type: DB_Int, Nullable: false},
                        {Name: "name", Type: DB_NVarchar, Length: 255, Nullable: false},
                        {Name: "address1", Type: DB_NVarchar, Length: 255, Nullable: true},
                        {Name: "address2", Type: DB_NVarchar, Length: 255, Nullable: true},
                        {Name: "city", Type: DB_NVarchar, Length: 255, Nullable: true},
                        {Name: "state", Type: DB_NVarchar, Length: 255, Nullable: true},
                        {Name: "zip_code", Type: DB_NVarchar, Length: 50, Nullable: true},
                        {Name: "country", Type: DB_NVarchar, Length: 255, Nullable: true},
                        {Name: "billing_email", Type: DB_NVarchar, Length: 255, Nullable: true},
                        {Name: "created", Type: DB_DateTime, Nullable: false},
                        {Name: "updated", Type: DB_DateTime, Nullable: false},
                },
                Indices: []*Index{
                        {Cols: []string{"name"}, Type: UniqueIndex},
                },
        }

        // add org v1
        mg.AddMigration("create org table v1", NewAddTableMigration(orgV1))
        addTableIndicesMigrations(mg, "v1", orgV1)

        orgUserV1 := Table{
                Name: "org_user",
                Columns: []*Column{
                        {Name: "id", Type: DB_BigInt, IsPrimaryKey: true, IsAutoIncrement: true},
                        {Name: "org_id", Type: DB_BigInt},
                        {Name: "user_id", Type: DB_BigInt},
                        {Name: "role", Type: DB_NVarchar, Length: 20},
                        {Name: "created", Type: DB_DateTime},
                        {Name: "updated", Type: DB_DateTime},
                },
                Indices: []*Index{
                        {Cols: []string{"org_id"}},
                        {Cols: []string{"org_id", "user_id"}, Type: UniqueIndex},
                },
        }

        //-------  org_user table -------------------
        mg.AddMigration("create org_user table v1", NewAddTableMigration(orgUserV1))
        addTableIndicesMigrations(mg, "v1", orgUserV1)

        //-------  copy data from old table-------------------
        mg.AddMigration("copy data account to org", NewCopyTableDataMigration("org", "account", map[string]string{
                "id":      "id",
                "version": "version",
                "name":    "name",
                "created": "created",
                "updated": "updated",
        }).IfTableExists("account"))

        mg.AddMigration("copy data account_user to org_user", NewCopyTableDataMigration("org_user", "account_user", map[string]string{
                "id":      "id",
                "org_id":  "account_id",
                "user_id": "user_id",
                "role":    "role",
                "created": "created",
                "updated": "updated",
        }).IfTableExists("account_user"))

        mg.AddMigration("Drop old table account", NewDropTableMigration("account"))
        mg.AddMigration("Drop old table account_user", NewDropTableMigration("account_user"))
}</span>
</pre>
		
		<pre class="file" id="file160" style="display: none">package migrations

import . "github.com/grafana/grafana/pkg/services/sqlstore/migrator"

func addPlaylistMigrations(mg *Migrator) <span class="cov8" title="1">{
        mg.AddMigration("Drop old table playlist table", NewDropTableMigration("playlist"))
        mg.AddMigration("Drop old table playlist_item table", NewDropTableMigration("playlist_item"))

        playlistV2 := Table{
                Name: "playlist",
                Columns: []*Column{
                        {Name: "id", Type: DB_BigInt, IsPrimaryKey: true, IsAutoIncrement: true},
                        {Name: "name", Type: DB_NVarchar, Length: 255, Nullable: false},
                        {Name: "interval", Type: DB_NVarchar, Length: 255, Nullable: false},
                        {Name: "org_id", Type: DB_BigInt, Nullable: false},
                },
        }

        // create table
        mg.AddMigration("create playlist table v2", NewAddTableMigration(playlistV2))

        playlistItemV2 := Table{
                Name: "playlist_item",
                Columns: []*Column{
                        {Name: "id", Type: DB_BigInt, IsPrimaryKey: true, IsAutoIncrement: true},
                        {Name: "playlist_id", Type: DB_BigInt, Nullable: false},
                        {Name: "type", Type: DB_NVarchar, Length: 255, Nullable: false},
                        {Name: "value", Type: DB_Text, Nullable: false},
                        {Name: "title", Type: DB_Text, Nullable: false},
                        {Name: "order", Type: DB_Int, Nullable: false},
                },
        }

        mg.AddMigration("create playlist item table v2", NewAddTableMigration(playlistItemV2))
}</span>
</pre>
		
		<pre class="file" id="file161" style="display: none">package migrations

import . "github.com/grafana/grafana/pkg/services/sqlstore/migrator"

func addAppSettingsMigration(mg *Migrator) <span class="cov8" title="1">{

        pluginSettingTable := Table{
                Name: "plugin_setting",
                Columns: []*Column{
                        {Name: "id", Type: DB_BigInt, IsPrimaryKey: true, IsAutoIncrement: true},
                        {Name: "org_id", Type: DB_BigInt, Nullable: true},
                        {Name: "plugin_id", Type: DB_NVarchar, Length: 255, Nullable: false},
                        {Name: "enabled", Type: DB_Bool, Nullable: false},
                        {Name: "pinned", Type: DB_Bool, Nullable: false},
                        {Name: "json_data", Type: DB_Text, Nullable: true},
                        {Name: "secure_json_data", Type: DB_Text, Nullable: true},
                        {Name: "created", Type: DB_DateTime, Nullable: false},
                        {Name: "updated", Type: DB_DateTime, Nullable: false},
                },
                Indices: []*Index{
                        {Cols: []string{"org_id", "plugin_id"}, Type: UniqueIndex},
                },
        }

        mg.AddMigration("create plugin_setting table", NewAddTableMigration(pluginSettingTable))

        //-------  indexes ------------------
        addTableIndicesMigrations(mg, "v1", pluginSettingTable)

        // add column to store installed version
        mg.AddMigration("Add column plugin_version to plugin_settings", NewAddColumnMigration(pluginSettingTable, &amp;Column{
                Name: "plugin_version", Type: DB_NVarchar, Nullable: true, Length: 50,
        }))

}</span>
</pre>
		
		<pre class="file" id="file162" style="display: none">package migrations

import . "github.com/grafana/grafana/pkg/services/sqlstore/migrator"

func addPreferencesMigrations(mg *Migrator) <span class="cov8" title="1">{

        mg.AddMigration("drop preferences table v2", NewDropTableMigration("preferences"))

        preferencesV2 := Table{
                Name: "preferences",
                Columns: []*Column{
                        {Name: "id", Type: DB_BigInt, IsPrimaryKey: true, IsAutoIncrement: true},
                        {Name: "org_id", Type: DB_BigInt, Nullable: false},
                        {Name: "user_id", Type: DB_BigInt, Nullable: false},
                        {Name: "version", Type: DB_Int, Nullable: false},
                        {Name: "home_dashboard_id", Type: DB_BigInt, Nullable: false},
                        {Name: "timezone", Type: DB_NVarchar, Length: 50, Nullable: false},
                        {Name: "theme", Type: DB_NVarchar, Length: 20, Nullable: false},
                        {Name: "created", Type: DB_DateTime, Nullable: false},
                        {Name: "updated", Type: DB_DateTime, Nullable: false},
                },
                Indices: []*Index{
                        {Cols: []string{"org_id"}},
                        {Cols: []string{"user_id"}},
                },
        }

        mg.AddMigration("drop preferences table v3", NewDropTableMigration("preferences"))

        // create table
        mg.AddMigration("create preferences table v3", NewAddTableMigration(preferencesV2))
}</span>
</pre>
		
		<pre class="file" id="file163" style="display: none">package migrations

import (
        . "github.com/grafana/grafana/pkg/services/sqlstore/migrator"
)

func addQuotaMigration(mg *Migrator) <span class="cov8" title="1">{

        var quotaV1 = Table{
                Name: "quota",
                Columns: []*Column{
                        {Name: "id", Type: DB_BigInt, IsPrimaryKey: true, IsAutoIncrement: true},
                        {Name: "org_id", Type: DB_BigInt, Nullable: true},
                        {Name: "user_id", Type: DB_BigInt, Nullable: true},
                        {Name: "target", Type: DB_NVarchar, Length: 255, Nullable: false},
                        {Name: "limit", Type: DB_BigInt, Nullable: false},
                        {Name: "created", Type: DB_DateTime, Nullable: false},
                        {Name: "updated", Type: DB_DateTime, Nullable: false},
                },
                Indices: []*Index{
                        {Cols: []string{"org_id", "user_id", "target"}, Type: UniqueIndex},
                },
        }
        mg.AddMigration("create quota table v1", NewAddTableMigration(quotaV1))

        //-------  indexes ------------------
        addTableIndicesMigrations(mg, "v1", quotaV1)
}</span>
</pre>
		
		<pre class="file" id="file164" style="display: none">package migrations

import . "github.com/grafana/grafana/pkg/services/sqlstore/migrator"

func addSessionMigration(mg *Migrator) <span class="cov8" title="1">{
        var sessionV1 = Table{
                Name: "session",
                Columns: []*Column{
                        {Name: "key", Type: DB_Char, IsPrimaryKey: true, Length: 16},
                        {Name: "data", Type: DB_Blob},
                        {Name: "expiry", Type: DB_Integer, Length: 255, Nullable: false},
                },
        }

        mg.AddMigration("create session table", NewAddTableMigration(sessionV1))
}</span>
</pre>
		
		<pre class="file" id="file165" style="display: none">package migrations

import . "github.com/grafana/grafana/pkg/services/sqlstore/migrator"

func addTempUserMigrations(mg *Migrator) <span class="cov8" title="1">{
        tempUserV1 := Table{
                Name: "temp_user",
                Columns: []*Column{
                        {Name: "id", Type: DB_BigInt, IsPrimaryKey: true, IsAutoIncrement: true},
                        {Name: "org_id", Type: DB_BigInt, Nullable: false},
                        {Name: "version", Type: DB_Int, Nullable: false},
                        {Name: "email", Type: DB_NVarchar, Length: 255},
                        {Name: "name", Type: DB_NVarchar, Length: 255, Nullable: true},
                        {Name: "role", Type: DB_NVarchar, Length: 20, Nullable: true},
                        {Name: "code", Type: DB_NVarchar, Length: 255},
                        {Name: "status", Type: DB_Varchar, Length: 20},
                        {Name: "invited_by_user_id", Type: DB_BigInt, Nullable: true},
                        {Name: "email_sent", Type: DB_Bool},
                        {Name: "email_sent_on", Type: DB_DateTime, Nullable: true},
                        {Name: "remote_addr", Type: DB_Varchar, Length: 255, Nullable: true},
                        {Name: "created", Type: DB_DateTime},
                        {Name: "updated", Type: DB_DateTime},
                },
                Indices: []*Index{
                        {Cols: []string{"email"}, Type: IndexType},
                        {Cols: []string{"org_id"}, Type: IndexType},
                        {Cols: []string{"code"}, Type: IndexType},
                        {Cols: []string{"status"}, Type: IndexType},
                },
        }

        // addDropAllIndicesMigrations(mg, "v7", tempUserV1)
        // mg.AddMigration("Drop old table tempUser v7", NewDropTableMigration("temp_user"))

        // create table
        mg.AddMigration("create temp user table v1-7", NewAddTableMigration(tempUserV1))
        addTableIndicesMigrations(mg, "v1-7", tempUserV1)
}</span>
</pre>
		
		<pre class="file" id="file166" style="display: none">package migrations

import . "github.com/grafana/grafana/pkg/services/sqlstore/migrator"

func addUserMigrations(mg *Migrator) <span class="cov8" title="1">{
        userV1 := Table{
                Name: "user",
                Columns: []*Column{
                        {Name: "id", Type: DB_BigInt, IsPrimaryKey: true, IsAutoIncrement: true},
                        {Name: "version", Type: DB_Int, Nullable: false},
                        {Name: "login", Type: DB_NVarchar, Length: 255, Nullable: false},
                        {Name: "email", Type: DB_NVarchar, Length: 255, Nullable: false},
                        {Name: "name", Type: DB_NVarchar, Length: 255, Nullable: true},
                        {Name: "password", Type: DB_NVarchar, Length: 255, Nullable: true},
                        {Name: "salt", Type: DB_NVarchar, Length: 50, Nullable: true},
                        {Name: "rands", Type: DB_NVarchar, Length: 50, Nullable: true},
                        {Name: "company", Type: DB_NVarchar, Length: 255, Nullable: true},
                        {Name: "account_id", Type: DB_BigInt, Nullable: false},
                        {Name: "is_admin", Type: DB_Bool, Nullable: false},
                        {Name: "created", Type: DB_DateTime, Nullable: false},
                        {Name: "updated", Type: DB_DateTime, Nullable: false},
                },
                Indices: []*Index{
                        {Cols: []string{"login"}, Type: UniqueIndex},
                        {Cols: []string{"email"}, Type: UniqueIndex},
                },
        }

        // create table
        mg.AddMigration("create user table", NewAddTableMigration(userV1))
        // add indices
        mg.AddMigration("add unique index user.login", NewAddIndexMigration(userV1, userV1.Indices[0]))
        mg.AddMigration("add unique index user.email", NewAddIndexMigration(userV1, userV1.Indices[1]))

        // ---------------------
        // account -&gt; org changes

        //-------  drop indexes ------------------
        addDropAllIndicesMigrations(mg, "v1", userV1)

        //------- rename table ------------------
        addTableRenameMigration(mg, "user", "user_v1", "v1")

        //------- recreate table with new column names ------------------
        userV2 := Table{
                Name: "user",
                Columns: []*Column{
                        {Name: "id", Type: DB_BigInt, IsPrimaryKey: true, IsAutoIncrement: true},
                        {Name: "version", Type: DB_Int, Nullable: false},
                        {Name: "login", Type: DB_NVarchar, Length: 255, Nullable: false},
                        {Name: "email", Type: DB_NVarchar, Length: 255, Nullable: false},
                        {Name: "name", Type: DB_NVarchar, Length: 255, Nullable: true},
                        {Name: "password", Type: DB_NVarchar, Length: 255, Nullable: true},
                        {Name: "salt", Type: DB_NVarchar, Length: 50, Nullable: true},
                        {Name: "rands", Type: DB_NVarchar, Length: 50, Nullable: true},
                        {Name: "company", Type: DB_NVarchar, Length: 255, Nullable: true},
                        {Name: "org_id", Type: DB_BigInt, Nullable: false},
                        {Name: "is_admin", Type: DB_Bool, Nullable: false},
                        {Name: "email_verified", Type: DB_Bool, Nullable: true},
                        {Name: "theme", Type: DB_NVarchar, Length: 255, Nullable: true},
                        {Name: "created", Type: DB_DateTime, Nullable: false},
                        {Name: "updated", Type: DB_DateTime, Nullable: false},
                },
                Indices: []*Index{
                        {Cols: []string{"login"}, Type: UniqueIndex},
                        {Cols: []string{"email"}, Type: UniqueIndex},
                },
        }

        mg.AddMigration("create user table v2", NewAddTableMigration(userV2))
        addTableIndicesMigrations(mg, "v2", userV2)

        //------- copy data from v1 to v2 -------------------
        mg.AddMigration("copy data_source v1 to v2", NewCopyTableDataMigration("user", "user_v1", map[string]string{
                "id":       "id",
                "version":  "version",
                "login":    "login",
                "email":    "email",
                "name":     "name",
                "password": "password",
                "salt":     "salt",
                "rands":    "rands",
                "company":  "company",
                "org_id":   "account_id",
                "is_admin": "is_admin",
                "created":  "created",
                "updated":  "updated",
        }))

        mg.AddMigration("Drop old table user_v1", NewDropTableMigration("user_v1"))

        mg.AddMigration("Add column help_flags1 to user table", NewAddColumnMigration(userV2, &amp;Column{
                Name: "help_flags1", Type: DB_BigInt, Nullable: false, Default: "0",
        }))
}</span>
</pre>
		
		<pre class="file" id="file167" style="display: none">package sqlstore

import (
        "time"

        "github.com/grafana/grafana/pkg/bus"
        "github.com/grafana/grafana/pkg/events"
        m "github.com/grafana/grafana/pkg/models"
)

func init() <span class="cov8" title="1">{
        bus.AddHandler("sql", GetOrgById)
        bus.AddHandler("sql", CreateOrg)
        bus.AddHandler("sql", UpdateOrg)
        bus.AddHandler("sql", UpdateOrgAddress)
        bus.AddHandler("sql", GetOrgByName)
        bus.AddHandler("sql", SearchOrgs)
        bus.AddHandler("sql", DeleteOrg)
}</span>

func SearchOrgs(query *m.SearchOrgsQuery) error <span class="cov0" title="0">{
        query.Result = make([]*m.OrgDTO, 0)
        sess := x.Table("org")
        if query.Query != "" </span><span class="cov0" title="0">{
                sess.Where("name LIKE ?", query.Query+"%")
        }</span>
        <span class="cov0" title="0">if query.Name != "" </span><span class="cov0" title="0">{
                sess.Where("name=?", query.Name)
        }</span>
        <span class="cov0" title="0">sess.Limit(query.Limit, query.Limit*query.Page)
        sess.Cols("id", "name")
        err := sess.Find(&amp;query.Result)
        return err</span>
}

func GetOrgById(query *m.GetOrgByIdQuery) error <span class="cov0" title="0">{
        var org m.Org
        exists, err := x.Id(query.Id).Get(&amp;org)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if !exists </span><span class="cov0" title="0">{
                return m.ErrOrgNotFound
        }</span>

        <span class="cov0" title="0">query.Result = &amp;org
        return nil</span>
}

func GetOrgByName(query *m.GetOrgByNameQuery) error <span class="cov0" title="0">{
        var org m.Org
        exists, err := x.Where("name=?", query.Name).Get(&amp;org)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if !exists </span><span class="cov0" title="0">{
                return m.ErrOrgNotFound
        }</span>

        <span class="cov0" title="0">query.Result = &amp;org
        return nil</span>
}

func isOrgNameTaken(name string, existingId int64, sess *session) (bool, error) <span class="cov8" title="1">{
        // check if org name is taken
        var org m.Org
        exists, err := sess.Where("name=?", name).Get(&amp;org)

        if err != nil </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        <span class="cov8" title="1">if exists &amp;&amp; existingId != org.Id </span><span class="cov0" title="0">{
                return true, nil
        }</span>

        <span class="cov8" title="1">return false, nil</span>
}

func CreateOrg(cmd *m.CreateOrgCommand) error <span class="cov8" title="1">{
        return inTransaction2(func(sess *session) error </span><span class="cov8" title="1">{

                if isNameTaken, err := isOrgNameTaken(cmd.Name, 0, sess); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span><span class="cov8" title="1"> else if isNameTaken </span><span class="cov0" title="0">{
                        return m.ErrOrgNameTaken
                }</span>

                <span class="cov8" title="1">org := m.Org{
                        Name:    cmd.Name,
                        Created: time.Now(),
                        Updated: time.Now(),
                }

                if _, err := sess.Insert(&amp;org); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">user := m.OrgUser{
                        OrgId:   org.Id,
                        UserId:  cmd.UserId,
                        Role:    m.ROLE_ADMIN,
                        Created: time.Now(),
                        Updated: time.Now(),
                }

                _, err := sess.Insert(&amp;user)
                cmd.Result = org

                sess.publishAfterCommit(&amp;events.OrgCreated{
                        Timestamp: org.Created,
                        Id:        org.Id,
                        Name:      org.Name,
                })

                return err</span>
        })
}

func UpdateOrg(cmd *m.UpdateOrgCommand) error <span class="cov0" title="0">{
        return inTransaction2(func(sess *session) error </span><span class="cov0" title="0">{

                if isNameTaken, err := isOrgNameTaken(cmd.Name, cmd.OrgId, sess); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span><span class="cov0" title="0"> else if isNameTaken </span><span class="cov0" title="0">{
                        return m.ErrOrgNameTaken
                }</span>

                <span class="cov0" title="0">org := m.Org{
                        Name:    cmd.Name,
                        Updated: time.Now(),
                }

                affectedRows, err := sess.Id(cmd.OrgId).Update(&amp;org)

                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">if affectedRows == 0 </span><span class="cov0" title="0">{
                        return m.ErrOrgNotFound
                }</span>

                <span class="cov0" title="0">sess.publishAfterCommit(&amp;events.OrgUpdated{
                        Timestamp: org.Updated,
                        Id:        org.Id,
                        Name:      org.Name,
                })

                return nil</span>
        })
}

func UpdateOrgAddress(cmd *m.UpdateOrgAddressCommand) error <span class="cov0" title="0">{
        return inTransaction2(func(sess *session) error </span><span class="cov0" title="0">{
                org := m.Org{
                        Address1: cmd.Address1,
                        Address2: cmd.Address2,
                        City:     cmd.City,
                        ZipCode:  cmd.ZipCode,
                        State:    cmd.State,
                        Country:  cmd.Country,

                        Updated: time.Now(),
                }

                if _, err := sess.Id(cmd.OrgId).Update(&amp;org); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">sess.publishAfterCommit(&amp;events.OrgUpdated{
                        Timestamp: org.Updated,
                        Id:        org.Id,
                        Name:      org.Name,
                })

                return nil</span>
        })
}

func DeleteOrg(cmd *m.DeleteOrgCommand) error <span class="cov0" title="0">{
        return inTransaction2(func(sess *session) error </span><span class="cov0" title="0">{
                if res, err := sess.Query("SELECT 1 from org WHERE id=?", cmd.Id); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span><span class="cov0" title="0"> else if len(res) != 1 </span><span class="cov0" title="0">{
                        return m.ErrOrgNotFound
                }</span>

                <span class="cov0" title="0">deletes := []string{
                        "DELETE FROM star WHERE EXISTS (SELECT 1 FROM dashboard WHERE org_id = ? AND star.dashboard_id = dashboard.id)",
                        "DELETE FROM dashboard_tag WHERE EXISTS (SELECT 1 FROM dashboard WHERE org_id = ? AND dashboard_tag.dashboard_id = dashboard.id)",
                        "DELETE FROM dashboard WHERE org_id = ?",
                        "DELETE FROM api_key WHERE org_id = ?",
                        "DELETE FROM data_source WHERE org_id = ?",
                        "DELETE FROM org_user WHERE org_id = ?",
                        "DELETE FROM org WHERE id = ?",
                        "DELETE FROM temp_user WHERE org_id = ?",
                }

                for _, sql := range deletes </span><span class="cov0" title="0">{
                        _, err := sess.Exec(sql, cmd.Id)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                <span class="cov0" title="0">return nil</span>
        })
}
</pre>
		
		<pre class="file" id="file168" style="display: none">package sqlstore

import (
        "fmt"
        "time"

        "github.com/go-xorm/xorm"

        "github.com/grafana/grafana/pkg/bus"
        m "github.com/grafana/grafana/pkg/models"
)

func init() <span class="cov8" title="1">{
        bus.AddHandler("sql", AddOrgUser)
        bus.AddHandler("sql", RemoveOrgUser)
        bus.AddHandler("sql", GetOrgUsers)
        bus.AddHandler("sql", UpdateOrgUser)
}</span>

func AddOrgUser(cmd *m.AddOrgUserCommand) error <span class="cov8" title="1">{
        return inTransaction(func(sess *xorm.Session) error </span><span class="cov8" title="1">{
                // check if user exists
                if res, err := sess.Query("SELECT 1 from org_user WHERE org_id=? and user_id=?", cmd.OrgId, cmd.UserId); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span><span class="cov8" title="1"> else if len(res) == 1 </span><span class="cov0" title="0">{
                        return m.ErrOrgUserAlreadyAdded
                }</span>

                <span class="cov8" title="1">if res, err := sess.Query("SELECT 1 from org WHERE id=?", cmd.OrgId); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span><span class="cov8" title="1"> else if len(res) != 1 </span><span class="cov0" title="0">{
                        return m.ErrOrgNotFound
                }</span>

                <span class="cov8" title="1">entity := m.OrgUser{
                        OrgId:   cmd.OrgId,
                        UserId:  cmd.UserId,
                        Role:    cmd.Role,
                        Created: time.Now(),
                        Updated: time.Now(),
                }

                _, err := sess.Insert(&amp;entity)
                return err</span>
        })
}

func UpdateOrgUser(cmd *m.UpdateOrgUserCommand) error <span class="cov8" title="1">{
        return inTransaction(func(sess *xorm.Session) error </span><span class="cov8" title="1">{
                var orgUser m.OrgUser
                exists, err := sess.Where("org_id=? AND user_id=?", cmd.OrgId, cmd.UserId).Get(&amp;orgUser)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">if !exists </span><span class="cov0" title="0">{
                        return m.ErrOrgUserNotFound
                }</span>

                <span class="cov8" title="1">orgUser.Role = cmd.Role
                orgUser.Updated = time.Now()
                _, err = sess.Id(orgUser.Id).Update(&amp;orgUser)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">return validateOneAdminLeftInOrg(cmd.OrgId, sess)</span>
        })
}

func GetOrgUsers(query *m.GetOrgUsersQuery) error <span class="cov8" title="1">{
        query.Result = make([]*m.OrgUserDTO, 0)
        sess := x.Table("org_user")
        sess.Join("INNER", "user", fmt.Sprintf("org_user.user_id=%s.id", x.Dialect().Quote("user")))
        sess.Where("org_user.org_id=?", query.OrgId)
        sess.Cols("org_user.org_id", "org_user.user_id", "user.email", "user.login", "org_user.role")
        sess.Asc("user.email", "user.login")

        err := sess.Find(&amp;query.Result)
        return err
}</span>

func RemoveOrgUser(cmd *m.RemoveOrgUserCommand) error <span class="cov8" title="1">{
        return inTransaction(func(sess *xorm.Session) error </span><span class="cov8" title="1">{
                var rawSql = "DELETE FROM org_user WHERE org_id=? and user_id=?"
                _, err := sess.Exec(rawSql, cmd.OrgId, cmd.UserId)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">return validateOneAdminLeftInOrg(cmd.OrgId, sess)</span>
        })
}

func validateOneAdminLeftInOrg(orgId int64, sess *xorm.Session) error <span class="cov8" title="1">{
        // validate that there is an admin user left
        res, err := sess.Query("SELECT 1 from org_user WHERE org_id=? and role='Admin'", orgId)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if len(res) == 0 </span><span class="cov8" title="1">{
                return m.ErrLastOrgAdmin
        }</span>

        <span class="cov8" title="1">return err</span>
}
</pre>
		
		<pre class="file" id="file169" style="display: none">package sqlstore

import (
        "fmt"

        "github.com/go-xorm/xorm"

        "github.com/grafana/grafana/pkg/bus"
        m "github.com/grafana/grafana/pkg/models"
)

func init() <span class="cov8" title="1">{
        bus.AddHandler("sql", CreatePlaylist)
        bus.AddHandler("sql", UpdatePlaylist)
        bus.AddHandler("sql", DeletePlaylist)
        bus.AddHandler("sql", SearchPlaylists)
        bus.AddHandler("sql", GetPlaylist)
        bus.AddHandler("sql", GetPlaylistItem)
}</span>

func CreatePlaylist(cmd *m.CreatePlaylistCommand) error <span class="cov8" title="1">{
        var err error

        playlist := m.Playlist{
                Name:     cmd.Name,
                Interval: cmd.Interval,
                OrgId:    cmd.OrgId,
        }

        _, err = x.Insert(&amp;playlist)

        fmt.Printf("%v", playlist.Id)

        playlistItems := make([]m.PlaylistItem, 0)
        for _, item := range cmd.Items </span><span class="cov8" title="1">{
                playlistItems = append(playlistItems, m.PlaylistItem{
                        PlaylistId: playlist.Id,
                        Type:       item.Type,
                        Value:      item.Value,
                        Order:      item.Order,
                        Title:      item.Title,
                })
        }</span>

        <span class="cov8" title="1">_, err = x.Insert(&amp;playlistItems)

        cmd.Result = &amp;playlist
        return err</span>
}

func UpdatePlaylist(cmd *m.UpdatePlaylistCommand) error <span class="cov8" title="1">{
        var err error
        playlist := m.Playlist{
                Id:       cmd.Id,
                OrgId:    cmd.OrgId,
                Name:     cmd.Name,
                Interval: cmd.Interval,
        }

        existingPlaylist := x.Where("id = ? AND org_id = ?", cmd.Id, cmd.OrgId).Find(m.Playlist{})

        if existingPlaylist == nil </span><span class="cov0" title="0">{
                return m.ErrPlaylistNotFound
        }</span>

        <span class="cov8" title="1">cmd.Result = &amp;m.PlaylistDTO{
                Id:       playlist.Id,
                OrgId:    playlist.OrgId,
                Name:     playlist.Name,
                Interval: playlist.Interval,
        }

        _, err = x.Id(cmd.Id).Cols("id", "name", "interval").Update(&amp;playlist)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">rawSql := "DELETE FROM playlist_item WHERE playlist_id = ?"
        _, err = x.Exec(rawSql, cmd.Id)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">playlistItems := make([]m.PlaylistItem, 0)

        for _, item := range cmd.Items </span><span class="cov8" title="1">{
                playlistItems = append(playlistItems, m.PlaylistItem{
                        PlaylistId: playlist.Id,
                        Type:       item.Type,
                        Value:      item.Value,
                        Order:      item.Order,
                        Title:      item.Title,
                })
        }</span>

        <span class="cov8" title="1">_, err = x.Insert(&amp;playlistItems)

        return err</span>
}

func GetPlaylist(query *m.GetPlaylistByIdQuery) error <span class="cov0" title="0">{
        if query.Id == 0 </span><span class="cov0" title="0">{
                return m.ErrCommandValidationFailed
        }</span>

        <span class="cov0" title="0">playlist := m.Playlist{}
        _, err := x.Id(query.Id).Get(&amp;playlist)

        query.Result = &amp;playlist

        return err</span>
}

func DeletePlaylist(cmd *m.DeletePlaylistCommand) error <span class="cov8" title="1">{
        if cmd.Id == 0 </span><span class="cov0" title="0">{
                return m.ErrCommandValidationFailed
        }</span>

        <span class="cov8" title="1">return inTransaction(func(sess *xorm.Session) error </span><span class="cov8" title="1">{
                var rawPlaylistSql = "DELETE FROM playlist WHERE id = ? and org_id = ?"
                _, err := sess.Exec(rawPlaylistSql, cmd.Id, cmd.OrgId)

                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">var rawItemSql = "DELETE FROM playlist_item WHERE playlist_id = ?"
                _, err2 := sess.Exec(rawItemSql, cmd.Id)

                return err2</span>
        })
}

func SearchPlaylists(query *m.GetPlaylistsQuery) error <span class="cov0" title="0">{
        var playlists = make(m.Playlists, 0)

        sess := x.Limit(query.Limit)

        if query.Name != "" </span><span class="cov0" title="0">{
                sess.Where("name LIKE ?", query.Name)
        }</span>

        <span class="cov0" title="0">sess.Where("org_id = ?", query.OrgId)
        err := sess.Find(&amp;playlists)
        query.Result = playlists

        return err</span>
}

func GetPlaylistItem(query *m.GetPlaylistItemsByIdQuery) error <span class="cov0" title="0">{
        if query.PlaylistId == 0 </span><span class="cov0" title="0">{
                return m.ErrCommandValidationFailed
        }</span>

        <span class="cov0" title="0">var playlistItems = make([]m.PlaylistItem, 0)
        err := x.Where("playlist_id=?", query.PlaylistId).Find(&amp;playlistItems)

        query.Result = &amp;playlistItems

        return err</span>
}
</pre>
		
		<pre class="file" id="file170" style="display: none">package sqlstore

import (
        "time"

        "github.com/grafana/grafana/pkg/bus"
        m "github.com/grafana/grafana/pkg/models"
        "github.com/grafana/grafana/pkg/setting"
        "github.com/grafana/grafana/pkg/util"
)

func init() <span class="cov8" title="1">{
        bus.AddHandler("sql", GetPluginSettings)
        bus.AddHandler("sql", GetPluginSettingById)
        bus.AddHandler("sql", UpdatePluginSetting)
        bus.AddHandler("sql", UpdatePluginSettingVersion)
}</span>

func GetPluginSettings(query *m.GetPluginSettingsQuery) error <span class="cov0" title="0">{
        sql := `SELECT org_id, plugin_id, enabled, pinned, plugin_version
                                        FROM plugin_setting `
        params := make([]interface{}, 0)

        if query.OrgId != 0 </span><span class="cov0" title="0">{
                sql += "WHERE org_id=?"
                params = append(params, query.OrgId)
        }</span>

        <span class="cov0" title="0">sess := x.Sql(sql, params...)
        query.Result = make([]*m.PluginSettingInfoDTO, 0)
        return sess.Find(&amp;query.Result)</span>
}

func GetPluginSettingById(query *m.GetPluginSettingByIdQuery) error <span class="cov0" title="0">{
        pluginSetting := m.PluginSetting{OrgId: query.OrgId, PluginId: query.PluginId}
        has, err := x.Get(&amp;pluginSetting)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span><span class="cov0" title="0"> else if has == false </span><span class="cov0" title="0">{
                return m.ErrPluginSettingNotFound
        }</span>
        <span class="cov0" title="0">query.Result = &amp;pluginSetting
        return nil</span>
}

func UpdatePluginSetting(cmd *m.UpdatePluginSettingCmd) error <span class="cov0" title="0">{
        return inTransaction2(func(sess *session) error </span><span class="cov0" title="0">{
                var pluginSetting m.PluginSetting

                exists, err := sess.Where("org_id=? and plugin_id=?", cmd.OrgId, cmd.PluginId).Get(&amp;pluginSetting)
                sess.UseBool("enabled")
                sess.UseBool("pinned")
                if !exists </span><span class="cov0" title="0">{
                        pluginSetting = m.PluginSetting{
                                PluginId:       cmd.PluginId,
                                OrgId:          cmd.OrgId,
                                Enabled:        cmd.Enabled,
                                Pinned:         cmd.Pinned,
                                JsonData:       cmd.JsonData,
                                PluginVersion:  cmd.PluginVersion,
                                SecureJsonData: cmd.GetEncryptedJsonData(),
                                Created:        time.Now(),
                                Updated:        time.Now(),
                        }

                        // add state change event on commit success
                        sess.events = append(sess.events, &amp;m.PluginStateChangedEvent{
                                PluginId: cmd.PluginId,
                                OrgId:    cmd.OrgId,
                                Enabled:  cmd.Enabled,
                        })

                        _, err = sess.Insert(&amp;pluginSetting)
                        return err
                }</span><span class="cov0" title="0"> else {
                        for key, data := range cmd.SecureJsonData </span><span class="cov0" title="0">{
                                pluginSetting.SecureJsonData[key] = util.Encrypt([]byte(data), setting.SecretKey)
                        }</span>

                        // add state change event on commit success
                        <span class="cov0" title="0">if pluginSetting.Enabled != cmd.Enabled </span><span class="cov0" title="0">{
                                sess.events = append(sess.events, &amp;m.PluginStateChangedEvent{
                                        PluginId: cmd.PluginId,
                                        OrgId:    cmd.OrgId,
                                        Enabled:  cmd.Enabled,
                                })
                        }</span>

                        <span class="cov0" title="0">pluginSetting.Updated = time.Now()
                        pluginSetting.Enabled = cmd.Enabled
                        pluginSetting.JsonData = cmd.JsonData
                        pluginSetting.Pinned = cmd.Pinned
                        pluginSetting.PluginVersion = cmd.PluginVersion

                        _, err = sess.Id(pluginSetting.Id).Update(&amp;pluginSetting)
                        return err</span>
                }
        })
}

func UpdatePluginSettingVersion(cmd *m.UpdatePluginSettingVersionCmd) error <span class="cov0" title="0">{
        return inTransaction2(func(sess *session) error </span><span class="cov0" title="0">{

                _, err := sess.Exec("UPDATE plugin_setting SET plugin_version=? WHERE org_id=? AND plugin_id=?", cmd.PluginVersion, cmd.OrgId, cmd.PluginId)
                return err

        }</span>)
}
</pre>
		
		<pre class="file" id="file171" style="display: none">package sqlstore

import (
        "time"

        "github.com/grafana/grafana/pkg/bus"
        m "github.com/grafana/grafana/pkg/models"

        "github.com/grafana/grafana/pkg/setting"
)

func init() <span class="cov8" title="1">{
        bus.AddHandler("sql", GetPreferences)
        bus.AddHandler("sql", GetPreferencesWithDefaults)
        bus.AddHandler("sql", SavePreferences)
}</span>

func GetPreferencesWithDefaults(query *m.GetPreferencesWithDefaultsQuery) error <span class="cov0" title="0">{

        prefs := make([]*m.Preferences, 0)
        filter := "(org_id=? AND user_id=?) OR (org_id=? AND user_id=0)"
        err := x.Where(filter, query.OrgId, query.UserId, query.OrgId).
                OrderBy("user_id ASC").
                Find(&amp;prefs)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">res := &amp;m.Preferences{
                Theme:           setting.DefaultTheme,
                Timezone:        "browser",
                HomeDashboardId: 0,
        }

        for _, p := range prefs </span><span class="cov0" title="0">{
                if p.Theme != "" </span><span class="cov0" title="0">{
                        res.Theme = p.Theme
                }</span>
                <span class="cov0" title="0">if p.Timezone != "" </span><span class="cov0" title="0">{
                        res.Timezone = p.Timezone
                }</span>
                <span class="cov0" title="0">if p.HomeDashboardId != 0 </span><span class="cov0" title="0">{
                        res.HomeDashboardId = p.HomeDashboardId
                }</span>
        }

        <span class="cov0" title="0">query.Result = res
        return nil</span>
}

func GetPreferences(query *m.GetPreferencesQuery) error <span class="cov0" title="0">{

        var prefs m.Preferences
        exists, err := x.Where("org_id=? AND user_id=?", query.OrgId, query.UserId).Get(&amp;prefs)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if exists </span><span class="cov0" title="0">{
                query.Result = &amp;prefs
        }</span><span class="cov0" title="0"> else {
                query.Result = new(m.Preferences)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func SavePreferences(cmd *m.SavePreferencesCommand) error <span class="cov0" title="0">{
        return inTransaction2(func(sess *session) error </span><span class="cov0" title="0">{

                var prefs m.Preferences
                exists, err := sess.Where("org_id=? AND user_id=?", cmd.OrgId, cmd.UserId).Get(&amp;prefs)

                if !exists </span><span class="cov0" title="0">{
                        prefs = m.Preferences{
                                UserId:          cmd.UserId,
                                OrgId:           cmd.OrgId,
                                HomeDashboardId: cmd.HomeDashboardId,
                                Timezone:        cmd.Timezone,
                                Theme:           cmd.Theme,
                                Created:         time.Now(),
                                Updated:         time.Now(),
                        }
                        _, err = sess.Insert(&amp;prefs)
                        return err
                }</span><span class="cov0" title="0"> else {
                        prefs.HomeDashboardId = cmd.HomeDashboardId
                        prefs.Timezone = cmd.Timezone
                        prefs.Theme = cmd.Theme
                        prefs.Updated = time.Now()
                        prefs.Version += 1
                        _, err := sess.Id(prefs.Id).AllCols().Update(&amp;prefs)
                        return err
                }</span>
        })
}
</pre>
		
		<pre class="file" id="file172" style="display: none">package sqlstore

import (
        "fmt"
        "github.com/grafana/grafana/pkg/bus"
        m "github.com/grafana/grafana/pkg/models"
        "github.com/grafana/grafana/pkg/setting"
)

func init() <span class="cov8" title="1">{
        bus.AddHandler("sql", GetOrgQuotaByTarget)
        bus.AddHandler("sql", GetOrgQuotas)
        bus.AddHandler("sql", UpdateOrgQuota)
        bus.AddHandler("sql", GetUserQuotaByTarget)
        bus.AddHandler("sql", GetUserQuotas)
        bus.AddHandler("sql", UpdateUserQuota)
        bus.AddHandler("sql", GetGlobalQuotaByTarget)
}</span>

type targetCount struct {
        Count int64
}

func GetOrgQuotaByTarget(query *m.GetOrgQuotaByTargetQuery) error <span class="cov8" title="1">{
        quota := m.Quota{
                Target: query.Target,
                OrgId:  query.OrgId,
        }
        has, err := x.Get(&amp;quota)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span><span class="cov8" title="1"> else if has == false </span><span class="cov8" title="1">{
                quota.Limit = query.Default
        }</span>

        //get quota used.
        <span class="cov8" title="1">rawSql := fmt.Sprintf("SELECT COUNT(*) as count from %s where org_id=?", dialect.Quote(query.Target))
        resp := make([]*targetCount, 0)
        if err := x.Sql(rawSql, query.OrgId).Find(&amp;resp); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">query.Result = &amp;m.OrgQuotaDTO{
                Target: query.Target,
                Limit:  quota.Limit,
                OrgId:  query.OrgId,
                Used:   resp[0].Count,
        }

        return nil</span>
}

func GetOrgQuotas(query *m.GetOrgQuotasQuery) error <span class="cov8" title="1">{
        quotas := make([]*m.Quota, 0)
        sess := x.Table("quota")
        if err := sess.Where("org_id=? AND user_id=0", query.OrgId).Find(&amp;quotas); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">defaultQuotas := setting.Quota.Org.ToMap()

        seenTargets := make(map[string]bool)
        for _, q := range quotas </span><span class="cov8" title="1">{
                seenTargets[q.Target] = true
        }</span>

        <span class="cov8" title="1">for t, v := range defaultQuotas </span><span class="cov8" title="1">{
                if _, ok := seenTargets[t]; !ok </span><span class="cov8" title="1">{
                        quotas = append(quotas, &amp;m.Quota{
                                OrgId:  query.OrgId,
                                Target: t,
                                Limit:  v,
                        })
                }</span>
        }

        <span class="cov8" title="1">result := make([]*m.OrgQuotaDTO, len(quotas))
        for i, q := range quotas </span><span class="cov8" title="1">{
                //get quota used.
                rawSql := fmt.Sprintf("SELECT COUNT(*) as count from %s where org_id=?", dialect.Quote(q.Target))
                resp := make([]*targetCount, 0)
                if err := x.Sql(rawSql, q.OrgId).Find(&amp;resp); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">result[i] = &amp;m.OrgQuotaDTO{
                        Target: q.Target,
                        Limit:  q.Limit,
                        OrgId:  q.OrgId,
                        Used:   resp[0].Count,
                }</span>
        }
        <span class="cov8" title="1">query.Result = result
        return nil</span>
}

func UpdateOrgQuota(cmd *m.UpdateOrgQuotaCmd) error <span class="cov8" title="1">{
        return inTransaction2(func(sess *session) error </span><span class="cov8" title="1">{
                //Check if quota is already defined in the DB
                quota := m.Quota{
                        Target: cmd.Target,
                        OrgId:  cmd.OrgId,
                }
                has, err := sess.Get(&amp;quota)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">quota.Limit = cmd.Limit
                if has == false </span><span class="cov8" title="1">{
                        //No quota in the DB for this target, so create a new one.
                        if _, err := sess.Insert(&amp;quota); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }<span class="cov0" title="0"> else {
                        //update existing quota entry in the DB.
                        if _, err := sess.Id(quota.Id).Update(&amp;quota); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                <span class="cov8" title="1">return nil</span>
        })
}

func GetUserQuotaByTarget(query *m.GetUserQuotaByTargetQuery) error <span class="cov8" title="1">{
        quota := m.Quota{
                Target: query.Target,
                UserId: query.UserId,
        }
        has, err := x.Get(&amp;quota)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span><span class="cov8" title="1"> else if has == false </span><span class="cov8" title="1">{
                quota.Limit = query.Default
        }</span>

        //get quota used.
        <span class="cov8" title="1">rawSql := fmt.Sprintf("SELECT COUNT(*) as count from %s where user_id=?", dialect.Quote(query.Target))
        resp := make([]*targetCount, 0)
        if err := x.Sql(rawSql, query.UserId).Find(&amp;resp); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">query.Result = &amp;m.UserQuotaDTO{
                Target: query.Target,
                Limit:  quota.Limit,
                UserId: query.UserId,
                Used:   resp[0].Count,
        }

        return nil</span>
}

func GetUserQuotas(query *m.GetUserQuotasQuery) error <span class="cov8" title="1">{
        quotas := make([]*m.Quota, 0)
        sess := x.Table("quota")
        if err := sess.Where("user_id=? AND org_id=0", query.UserId).Find(&amp;quotas); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">defaultQuotas := setting.Quota.User.ToMap()

        seenTargets := make(map[string]bool)
        for _, q := range quotas </span><span class="cov8" title="1">{
                seenTargets[q.Target] = true
        }</span>

        <span class="cov8" title="1">for t, v := range defaultQuotas </span><span class="cov8" title="1">{
                if _, ok := seenTargets[t]; !ok </span><span class="cov0" title="0">{
                        quotas = append(quotas, &amp;m.Quota{
                                UserId: query.UserId,
                                Target: t,
                                Limit:  v,
                        })
                }</span>
        }

        <span class="cov8" title="1">result := make([]*m.UserQuotaDTO, len(quotas))
        for i, q := range quotas </span><span class="cov8" title="1">{
                //get quota used.
                rawSql := fmt.Sprintf("SELECT COUNT(*) as count from %s where user_id=?", dialect.Quote(q.Target))
                resp := make([]*targetCount, 0)
                if err := x.Sql(rawSql, q.UserId).Find(&amp;resp); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">result[i] = &amp;m.UserQuotaDTO{
                        Target: q.Target,
                        Limit:  q.Limit,
                        UserId: q.UserId,
                        Used:   resp[0].Count,
                }</span>
        }
        <span class="cov8" title="1">query.Result = result
        return nil</span>
}

func UpdateUserQuota(cmd *m.UpdateUserQuotaCmd) error <span class="cov8" title="1">{
        return inTransaction2(func(sess *session) error </span><span class="cov8" title="1">{
                //Check if quota is already defined in the DB
                quota := m.Quota{
                        Target: cmd.Target,
                        UserId: cmd.UserId,
                }
                has, err := sess.Get(&amp;quota)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">quota.Limit = cmd.Limit
                if has == false </span><span class="cov8" title="1">{
                        //No quota in the DB for this target, so create a new one.
                        if _, err := sess.Insert(&amp;quota); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }<span class="cov0" title="0"> else {
                        //update existing quota entry in the DB.
                        if _, err := sess.Id(quota.Id).Update(&amp;quota); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                <span class="cov8" title="1">return nil</span>
        })
}

func GetGlobalQuotaByTarget(query *m.GetGlobalQuotaByTargetQuery) error <span class="cov8" title="1">{
        //get quota used.
        rawSql := fmt.Sprintf("SELECT COUNT(*) as count from %s", dialect.Quote(query.Target))
        resp := make([]*targetCount, 0)
        if err := x.Sql(rawSql).Find(&amp;resp); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">query.Result = &amp;m.GlobalQuotaDTO{
                Target: query.Target,
                Limit:  query.Default,
                Used:   resp[0].Count,
        }

        return nil</span>
}
</pre>
		
		<pre class="file" id="file173" style="display: none">package sqlstore

import (
        "github.com/go-xorm/xorm"
        "github.com/grafana/grafana/pkg/bus"
        "github.com/grafana/grafana/pkg/log"
)

type dbTransactionFunc func(sess *xorm.Session) error
type dbTransactionFunc2 func(sess *session) error

type session struct {
        *xorm.Session
        events []interface{}
}

func (sess *session) publishAfterCommit(msg interface{}) <span class="cov8" title="1">{
        sess.events = append(sess.events, msg)
}</span>

func inTransaction(callback dbTransactionFunc) error <span class="cov8" title="1">{
        var err error

        sess := x.NewSession()
        defer sess.Close()

        if err = sess.Begin(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">err = callback(sess)

        if err != nil </span><span class="cov8" title="1">{
                sess.Rollback()
                return err
        }</span><span class="cov8" title="1"> else if err = sess.Commit(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func inTransaction2(callback dbTransactionFunc2) error <span class="cov8" title="1">{
        var err error

        sess := session{Session: x.NewSession()}

        defer sess.Close()
        if err = sess.Begin(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">err = callback(&amp;sess)

        if err != nil </span><span class="cov0" title="0">{
                sess.Rollback()
                return err
        }</span><span class="cov8" title="1"> else if err = sess.Commit(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if len(sess.events) &gt; 0 </span><span class="cov8" title="1">{
                for _, e := range sess.events </span><span class="cov8" title="1">{
                        if err = bus.Publish(e); err != nil </span><span class="cov0" title="0">{
                                log.Error(3, "Failed to publish event after commit", err)
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file174" style="display: none">package sqlstore

import (
        "fmt"
        "net/url"
        "os"
        "path"
        "path/filepath"
        "strings"

        "github.com/grafana/grafana/pkg/bus"
        "github.com/grafana/grafana/pkg/log"
        m "github.com/grafana/grafana/pkg/models"
        "github.com/grafana/grafana/pkg/services/annotations"
        "github.com/grafana/grafana/pkg/services/sqlstore/migrations"
        "github.com/grafana/grafana/pkg/services/sqlstore/migrator"
        "github.com/grafana/grafana/pkg/setting"

        "github.com/go-sql-driver/mysql"
        _ "github.com/go-sql-driver/mysql"
        "github.com/go-xorm/xorm"
        _ "github.com/lib/pq"
        _ "github.com/mattn/go-sqlite3"
)

type DatabaseConfig struct {
        Type, Host, Name, User, Pwd, Path, SslMode string
        CaCertPath                                 string
        ClientKeyPath                              string
        ClientCertPath                             string
        ServerCertName                             string
        MaxConn                                    int
        MaxOpenConn                                int
        MaxIdleConn                                int
}

var (
        x       *xorm.Engine
        dialect migrator.Dialect

        HasEngine bool

        DbCfg DatabaseConfig

        UseSQLite3 bool
        sqlog      log.Logger = log.New("sqlstore")
)

func EnsureAdminUser() <span class="cov0" title="0">{
        statsQuery := m.GetSystemStatsQuery{}

        if err := bus.Dispatch(&amp;statsQuery); err != nil </span><span class="cov0" title="0">{
                log.Fatal(3, "Could not determine if admin user exists: %v", err)
                return
        }</span>

        <span class="cov0" title="0">if statsQuery.Result.UserCount &gt; 0 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">cmd := m.CreateUserCommand{}
        cmd.Login = setting.AdminUser
        cmd.Email = setting.AdminUser + "@localhost"
        cmd.Password = setting.AdminPassword
        cmd.IsAdmin = true

        if err := bus.Dispatch(&amp;cmd); err != nil </span><span class="cov0" title="0">{
                log.Error(3, "Failed to create default admin user", err)
                return
        }</span>

        <span class="cov0" title="0">log.Info("Created default admin user: %v", setting.AdminUser)</span>
}

func NewEngine() <span class="cov0" title="0">{
        x, err := getEngine()

        if err != nil </span><span class="cov0" title="0">{
                sqlog.Crit("Fail to connect to database", "error", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">err = SetEngine(x)

        if err != nil </span><span class="cov0" title="0">{
                sqlog.Error("Fail to initialize orm engine", "error", err)
                os.Exit(1)
        }</span>
}

func SetEngine(engine *xorm.Engine) (err error) <span class="cov8" title="1">{
        x = engine
        dialect = migrator.NewDialect(x.DriverName())

        migrator := migrator.NewMigrator(x)
        migrations.AddMigrations(migrator)

        if err := migrator.Start(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Sqlstore::Migration failed err: %v\n", err)
        }</span>

        <span class="cov8" title="1">annotations.SetRepository(&amp;SqlAnnotationRepo{})

        return nil</span>
}

func getEngine() (*xorm.Engine, error) <span class="cov0" title="0">{
        LoadConfig()

        cnnstr := ""
        switch DbCfg.Type </span>{
        case "mysql":<span class="cov0" title="0">
                protocol := "tcp"
                if strings.HasPrefix(DbCfg.Host, "/") </span><span class="cov0" title="0">{
                        protocol = "unix"
                }</span>

                <span class="cov0" title="0">cnnstr = fmt.Sprintf("%s:%s@%s(%s)/%s?charset=utf8",
                        DbCfg.User, DbCfg.Pwd, protocol, DbCfg.Host, DbCfg.Name)

                if DbCfg.SslMode == "true" || DbCfg.SslMode == "skip-verify" </span><span class="cov0" title="0">{
                        tlsCert, err := makeCert("custom", DbCfg)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">mysql.RegisterTLSConfig("custom", tlsCert)
                        cnnstr += "&amp;tls=custom"</span>
                }
        case "postgres":<span class="cov0" title="0">
                var host, port = "127.0.0.1", "5432"
                fields := strings.Split(DbCfg.Host, ":")
                if len(fields) &gt; 0 &amp;&amp; len(strings.TrimSpace(fields[0])) &gt; 0 </span><span class="cov0" title="0">{
                        host = fields[0]
                }</span>
                <span class="cov0" title="0">if len(fields) &gt; 1 &amp;&amp; len(strings.TrimSpace(fields[1])) &gt; 0 </span><span class="cov0" title="0">{
                        port = fields[1]
                }</span>
                <span class="cov0" title="0">if DbCfg.Pwd == "" </span><span class="cov0" title="0">{
                        DbCfg.Pwd = "''"
                }</span>
                <span class="cov0" title="0">if DbCfg.User == "" </span><span class="cov0" title="0">{
                        DbCfg.User = "''"
                }</span>
                <span class="cov0" title="0">cnnstr = fmt.Sprintf("user=%s password=%s host=%s port=%s dbname=%s sslmode=%s sslcert=%s sslkey=%s sslrootcert=%s", DbCfg.User, DbCfg.Pwd, host, port, DbCfg.Name, DbCfg.SslMode, DbCfg.ClientCertPath, DbCfg.ClientKeyPath, DbCfg.CaCertPath)</span>
        case "sqlite3":<span class="cov0" title="0">
                if !filepath.IsAbs(DbCfg.Path) </span><span class="cov0" title="0">{
                        DbCfg.Path = filepath.Join(setting.DataPath, DbCfg.Path)
                }</span>
                <span class="cov0" title="0">os.MkdirAll(path.Dir(DbCfg.Path), os.ModePerm)
                cnnstr = "file:" + DbCfg.Path + "?cache=shared&amp;mode=rwc&amp;_loc=Local"</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("Unknown database type: %s", DbCfg.Type)</span>
        }

        <span class="cov0" title="0">sqlog.Info("Initializing DB", "dbtype", DbCfg.Type)
        engine, err := xorm.NewEngine(DbCfg.Type, cnnstr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span><span class="cov0" title="0"> else {
                engine.SetMaxConns(DbCfg.MaxConn)
                engine.SetMaxOpenConns(DbCfg.MaxOpenConn)
                engine.SetMaxIdleConns(DbCfg.MaxIdleConn)
        }</span>
        <span class="cov0" title="0">return engine, nil</span>
}

func LoadConfig() <span class="cov0" title="0">{
        sec := setting.Cfg.Section("database")

        cfgURL := sec.Key("url").String()
        if len(cfgURL) != 0 </span><span class="cov0" title="0">{
                dbURL, _ := url.Parse(cfgURL)
                DbCfg.Type = dbURL.Scheme
                DbCfg.Host = dbURL.Host

                pathSplit := strings.Split(dbURL.Path, "/")
                if len(pathSplit) &gt; 1 </span><span class="cov0" title="0">{
                        DbCfg.Name = pathSplit[1]
                }</span>

                <span class="cov0" title="0">userInfo := dbURL.User
                if userInfo != nil </span><span class="cov0" title="0">{
                        DbCfg.User = userInfo.Username()
                        DbCfg.Pwd, _ = userInfo.Password()
                }</span>
        }<span class="cov0" title="0"> else {
                DbCfg.Type = sec.Key("type").String()
                DbCfg.Host = sec.Key("host").String()
                DbCfg.Name = sec.Key("name").String()
                DbCfg.User = sec.Key("user").String()
                DbCfg.MaxConn = sec.Key("max_conn").MustInt(0)
                DbCfg.MaxOpenConn = sec.Key("max_open_conn").MustInt(0)
                DbCfg.MaxIdleConn = sec.Key("max_idle_conn").MustInt(0)
                if len(DbCfg.Pwd) == 0 </span><span class="cov0" title="0">{
                        DbCfg.Pwd = sec.Key("password").String()
                }</span>
        }

        <span class="cov0" title="0">if DbCfg.Type == "sqlite3" </span><span class="cov0" title="0">{
                UseSQLite3 = true
        }</span>
        <span class="cov0" title="0">DbCfg.SslMode = sec.Key("ssl_mode").String()
        DbCfg.CaCertPath = sec.Key("ca_cert_path").String()
        DbCfg.ClientKeyPath = sec.Key("client_key_path").String()
        DbCfg.ClientCertPath = sec.Key("client_cert_path").String()
        DbCfg.ServerCertName = sec.Key("server_cert_name").String()
        DbCfg.Path = sec.Key("path").MustString("data/grafana.db")</span>
}
</pre>
		
		<pre class="file" id="file175" style="display: none">package sqlstore

import (
        "github.com/go-xorm/xorm"

        "github.com/grafana/grafana/pkg/bus"
        m "github.com/grafana/grafana/pkg/models"
)

func init() <span class="cov8" title="1">{
        bus.AddHandler("sql", StarDashboard)
        bus.AddHandler("sql", UnstarDashboard)
        bus.AddHandler("sql", GetUserStars)
        bus.AddHandler("sql", IsStarredByUser)
}</span>

func IsStarredByUser(query *m.IsStarredByUserQuery) error <span class="cov8" title="1">{
        rawSql := "SELECT 1 from star where user_id=? and dashboard_id=?"
        results, err := x.Query(rawSql, query.UserId, query.DashboardId)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if len(results) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">query.Result = true

        return nil</span>
}

func StarDashboard(cmd *m.StarDashboardCommand) error <span class="cov8" title="1">{
        if cmd.DashboardId == 0 || cmd.UserId == 0 </span><span class="cov0" title="0">{
                return m.ErrCommandValidationFailed
        }</span>

        <span class="cov8" title="1">return inTransaction(func(sess *xorm.Session) error </span><span class="cov8" title="1">{

                entity := m.Star{
                        UserId:      cmd.UserId,
                        DashboardId: cmd.DashboardId,
                }

                _, err := sess.Insert(&amp;entity)
                return err
        }</span>)
}

func UnstarDashboard(cmd *m.UnstarDashboardCommand) error <span class="cov0" title="0">{
        if cmd.DashboardId == 0 || cmd.UserId == 0 </span><span class="cov0" title="0">{
                return m.ErrCommandValidationFailed
        }</span>

        <span class="cov0" title="0">return inTransaction(func(sess *xorm.Session) error </span><span class="cov0" title="0">{
                var rawSql = "DELETE FROM star WHERE user_id=? and dashboard_id=?"
                _, err := sess.Exec(rawSql, cmd.UserId, cmd.DashboardId)
                return err
        }</span>)
}

func GetUserStars(query *m.GetUserStarsQuery) error <span class="cov0" title="0">{
        var stars = make([]m.Star, 0)
        err := x.Where("user_id=?", query.UserId).Find(&amp;stars)

        query.Result = make(map[int64]bool)
        for _, star := range stars </span><span class="cov0" title="0">{
                query.Result[star.DashboardId] = true
        }</span>

        <span class="cov0" title="0">return err</span>
}
</pre>
		
		<pre class="file" id="file176" style="display: none">package sqlstore

import (
        "github.com/grafana/grafana/pkg/bus"
        m "github.com/grafana/grafana/pkg/models"
)

func init() <span class="cov8" title="1">{
        bus.AddHandler("sql", GetSystemStats)
        bus.AddHandler("sql", GetDataSourceStats)
        bus.AddHandler("sql", GetAdminStats)
}</span>

func GetDataSourceStats(query *m.GetDataSourceStatsQuery) error <span class="cov0" title="0">{
        var rawSql = `SELECT COUNT(*) as count, type FROM data_source GROUP BY type`
        query.Result = make([]*m.DataSourceStats, 0)
        err := x.Sql(rawSql).Find(&amp;query.Result)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return err</span>
}

func GetSystemStats(query *m.GetSystemStatsQuery) error <span class="cov0" title="0">{
        var rawSql = `SELECT
                        (
                                SELECT COUNT(*)
        FROM ` + dialect.Quote("user") + `
      ) AS user_count,
                        (
                                SELECT COUNT(*)
        FROM ` + dialect.Quote("org") + `
      ) AS org_count,
      (
        SELECT COUNT(*)
        FROM ` + dialect.Quote("dashboard") + `
      ) AS dashboard_count,
      (
        SELECT COUNT(*)
        FROM ` + dialect.Quote("playlist") + `
      ) AS playlist_count,
      (
        SELECT COUNT(*)
        FROM ` + dialect.Quote("alert") + `
      ) AS alert_count
                        `

        var stats m.SystemStats
        _, err := x.Sql(rawSql).Get(&amp;stats)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">query.Result = &amp;stats
        return err</span>
}

func GetAdminStats(query *m.GetAdminStatsQuery) error <span class="cov0" title="0">{
        var rawSql = `SELECT
      (
        SELECT COUNT(*)
        FROM ` + dialect.Quote("user") + `
      ) AS user_count,
      (
        SELECT COUNT(*)
        FROM ` + dialect.Quote("org") + `
      ) AS org_count,
      (
        SELECT COUNT(*)
        FROM ` + dialect.Quote("dashboard") + `
      ) AS dashboard_count,
      (
        SELECT COUNT(*)
        FROM ` + dialect.Quote("dashboard_snapshot") + `
      ) AS db_snapshot_count,
      (
        SELECT COUNT( DISTINCT ( ` + dialect.Quote("term") + ` ))
        FROM ` + dialect.Quote("dashboard_tag") + `
      ) AS db_tag_count,
      (
        SELECT COUNT(*)
        FROM ` + dialect.Quote("data_source") + `
      ) AS data_source_count,
      (
        SELECT COUNT(*)
        FROM ` + dialect.Quote("playlist") + `
      ) AS playlist_count,
      (
        SELECT COUNT(DISTINCT ` + dialect.Quote("dashboard_id") + ` )
        FROM ` + dialect.Quote("star") + `
      ) AS starred_db_count,
      (
        SELECT COUNT(*)
        FROM ` + dialect.Quote("alert") + `
      ) AS alert_count
      `

        var stats m.AdminStats
        _, err := x.Sql(rawSql).Get(&amp;stats)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">query.Result = &amp;stats
        return err</span>
}
</pre>
		
		<pre class="file" id="file177" style="display: none">package sqlstore

import (
        "time"

        "github.com/go-xorm/xorm"
        "github.com/grafana/grafana/pkg/bus"
        m "github.com/grafana/grafana/pkg/models"
)

func init() <span class="cov8" title="1">{
        bus.AddHandler("sql", CreateTempUser)
        bus.AddHandler("sql", GetTempUsersQuery)
        bus.AddHandler("sql", UpdateTempUserStatus)
        bus.AddHandler("sql", GetTempUserByCode)
}</span>

func UpdateTempUserStatus(cmd *m.UpdateTempUserStatusCommand) error <span class="cov8" title="1">{
        return inTransaction(func(sess *xorm.Session) error </span><span class="cov8" title="1">{
                var rawSql = "UPDATE temp_user SET status=? WHERE code=?"
                _, err := sess.Exec(rawSql, string(cmd.Status), cmd.Code)
                return err
        }</span>)
}

func CreateTempUser(cmd *m.CreateTempUserCommand) error <span class="cov8" title="1">{
        return inTransaction2(func(sess *session) error </span><span class="cov8" title="1">{

                // create user
                user := &amp;m.TempUser{
                        Email:           cmd.Email,
                        Name:            cmd.Name,
                        OrgId:           cmd.OrgId,
                        Code:            cmd.Code,
                        Role:            cmd.Role,
                        Status:          cmd.Status,
                        RemoteAddr:      cmd.RemoteAddr,
                        InvitedByUserId: cmd.InvitedByUserId,
                        Created:         time.Now(),
                        Updated:         time.Now(),
                }

                if _, err := sess.Insert(user); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">cmd.Result = user
                return nil</span>
        })
}

func GetTempUsersQuery(query *m.GetTempUsersQuery) error <span class="cov8" title="1">{
        rawSql := `SELECT
                        tu.id             as id,
                        tu.org_id         as org_id,
                        tu.email          as email,
                                                                        tu.name           as name,
                                                                        tu.role           as role,
                                                                        tu.code           as code,
                                                                        tu.status         as status,
                                                                        tu.email_sent     as email_sent,
                                                                        tu.email_sent_on  as email_sent_on,
                                                                        tu.created                                as created,
                                                                        u.login                                                as invited_by_login,
                                                                        u.name                                                as invited_by_name,
                                                                        u.email                                                as invited_by_email
                        FROM ` + dialect.Quote("temp_user") + ` as tu
                                                                        LEFT OUTER JOIN ` + dialect.Quote("user") + ` as u on u.id = tu.invited_by_user_id
                                                                        WHERE tu.status=?`
        params := []interface{}{string(query.Status)}

        if query.OrgId &gt; 0 </span><span class="cov8" title="1">{
                rawSql += ` AND tu.org_id=?`
                params = append(params, query.OrgId)
        }</span>

        <span class="cov8" title="1">if query.Email != "" </span><span class="cov8" title="1">{
                rawSql += ` AND tu.email=?`
                params = append(params, query.Email)
        }</span>

        <span class="cov8" title="1">rawSql += " ORDER BY tu.created desc"

        query.Result = make([]*m.TempUserDTO, 0)
        sess := x.Sql(rawSql, params...)
        err := sess.Find(&amp;query.Result)
        return err</span>
}

func GetTempUserByCode(query *m.GetTempUserByCodeQuery) error <span class="cov8" title="1">{
        var rawSql = `SELECT
                        tu.id             as id,
                        tu.org_id         as org_id,
                        tu.email          as email,
                                                                        tu.name           as name,
                                                                        tu.role           as role,
                                                                        tu.code           as code,
                                                                        tu.status         as status,
                                                                        tu.email_sent     as email_sent,
                                                                        tu.email_sent_on  as email_sent_on,
                                                                        tu.created                                as created,
                                                                        u.login                                                as invited_by_login,
                                                                        u.name                                                as invited_by_name,
                                                                        u.email                                                as invited_by_email
                        FROM ` + dialect.Quote("temp_user") + ` as tu
                                                                        LEFT OUTER JOIN ` + dialect.Quote("user") + ` as u on u.id = tu.invited_by_user_id
                        WHERE tu.code=?`

        var tempUser m.TempUserDTO
        sess := x.Sql(rawSql, query.Code)
        has, err := sess.Get(&amp;tempUser)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span><span class="cov8" title="1"> else if has == false </span><span class="cov0" title="0">{
                return m.ErrTempUserNotFound
        }</span>

        <span class="cov8" title="1">query.Result = &amp;tempUser
        return err</span>
}
</pre>
		
		<pre class="file" id="file178" style="display: none">package sqlstore

import (
        "crypto/tls"
        "crypto/x509"
        "fmt"
        "io/ioutil"
)

func makeCert(tlsPoolName string, config DatabaseConfig) (*tls.Config, error) <span class="cov0" title="0">{
        rootCertPool := x509.NewCertPool()
        pem, err := ioutil.ReadFile(config.CaCertPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Could not read DB CA Cert path: %v", config.CaCertPath)
        }</span>
        <span class="cov0" title="0">if ok := rootCertPool.AppendCertsFromPEM(pem); !ok </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">clientCert := make([]tls.Certificate, 0, 1)
        if config.ClientCertPath != "" &amp;&amp; config.ClientKeyPath != "" </span><span class="cov0" title="0">{

                certs, err := tls.LoadX509KeyPair(config.ClientCertPath, config.ClientKeyPath)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">clientCert = append(clientCert, certs)</span>
        }
        <span class="cov0" title="0">tlsConfig := &amp;tls.Config{
                RootCAs:      rootCertPool,
                Certificates: clientCert,
        }
        tlsConfig.ServerName = config.ServerCertName
        if config.SslMode == "skip-verify" </span><span class="cov0" title="0">{
                tlsConfig.InsecureSkipVerify = true
        }</span>
        // Return more meaningful error before it is too late
        <span class="cov0" title="0">if config.ServerCertName == "" &amp;&amp; !tlsConfig.InsecureSkipVerify </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("server_cert_name is missing. Consider using ssl_mode = skip-verify.")
        }</span>
        <span class="cov0" title="0">return tlsConfig, nil</span>
}
</pre>
		
		<pre class="file" id="file179" style="display: none">package sqlstore

import (
        "strings"
        "time"

        "github.com/go-xorm/xorm"

        "fmt"

        "github.com/grafana/grafana/pkg/bus"
        "github.com/grafana/grafana/pkg/events"
        m "github.com/grafana/grafana/pkg/models"
        "github.com/grafana/grafana/pkg/setting"
        "github.com/grafana/grafana/pkg/util"
)

func init() <span class="cov8" title="1">{
        bus.AddHandler("sql", CreateUser)
        bus.AddHandler("sql", GetUserById)
        bus.AddHandler("sql", UpdateUser)
        bus.AddHandler("sql", ChangeUserPassword)
        bus.AddHandler("sql", GetUserByLogin)
        bus.AddHandler("sql", GetUserByEmail)
        bus.AddHandler("sql", SetUsingOrg)
        bus.AddHandler("sql", GetUserProfile)
        bus.AddHandler("sql", GetSignedInUser)
        bus.AddHandler("sql", SearchUsers)
        bus.AddHandler("sql", GetUserOrgList)
        bus.AddHandler("sql", DeleteUser)
        bus.AddHandler("sql", SetUsingOrg)
        bus.AddHandler("sql", UpdateUserPermissions)
        bus.AddHandler("sql", SetUserHelpFlag)
}</span>

func getOrgIdForNewUser(cmd *m.CreateUserCommand, sess *session) (int64, error) <span class="cov8" title="1">{
        if cmd.SkipOrgSetup </span><span class="cov0" title="0">{
                return -1, nil
        }</span>

        <span class="cov8" title="1">var org m.Org

        if setting.AutoAssignOrg </span><span class="cov8" title="1">{
                // right now auto assign to org with id 1
                has, err := sess.Where("id=?", 1).Get(&amp;org)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov8" title="1">if has </span><span class="cov8" title="1">{
                        return org.Id, nil
                }</span><span class="cov8" title="1"> else {
                        org.Name = "Main Org."
                        org.Id = 1
                }</span>
        }<span class="cov8" title="1"> else {
                org.Name = cmd.OrgName
                if len(org.Name) == 0 </span><span class="cov8" title="1">{
                        org.Name = util.StringsFallback2(cmd.Email, cmd.Login)
                }</span>
        }

        <span class="cov8" title="1">org.Created = time.Now()
        org.Updated = time.Now()

        if _, err := sess.Insert(&amp;org); err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov8" title="1">sess.publishAfterCommit(&amp;events.OrgCreated{
                Timestamp: org.Created,
                Id:        org.Id,
                Name:      org.Name,
        })

        return org.Id, nil</span>
}

func CreateUser(cmd *m.CreateUserCommand) error <span class="cov8" title="1">{
        return inTransaction2(func(sess *session) error </span><span class="cov8" title="1">{
                orgId, err := getOrgIdForNewUser(cmd, sess)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">if cmd.Email == "" </span><span class="cov0" title="0">{
                        cmd.Email = cmd.Login
                }</span>

                // create user
                <span class="cov8" title="1">user := m.User{
                        Email:         cmd.Email,
                        Name:          cmd.Name,
                        Login:         cmd.Login,
                        Company:       cmd.Company,
                        IsAdmin:       cmd.IsAdmin,
                        OrgId:         orgId,
                        EmailVerified: cmd.EmailVerified,
                        Created:       time.Now(),
                        Updated:       time.Now(),
                }

                if len(cmd.Password) &gt; 0 </span><span class="cov0" title="0">{
                        user.Salt = util.GetRandomString(10)
                        user.Rands = util.GetRandomString(10)
                        user.Password = util.EncodePassword(cmd.Password, user.Salt)
                }</span>

                <span class="cov8" title="1">sess.UseBool("is_admin")

                if _, err := sess.Insert(&amp;user); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">sess.publishAfterCommit(&amp;events.UserCreated{
                        Timestamp: user.Created,
                        Id:        user.Id,
                        Name:      user.Name,
                        Login:     user.Login,
                        Email:     user.Email,
                })

                cmd.Result = user

                // create org user link
                if !cmd.SkipOrgSetup </span><span class="cov8" title="1">{
                        orgUser := m.OrgUser{
                                OrgId:   orgId,
                                UserId:  user.Id,
                                Role:    m.ROLE_ADMIN,
                                Created: time.Now(),
                                Updated: time.Now(),
                        }

                        if setting.AutoAssignOrg &amp;&amp; !user.IsAdmin </span><span class="cov8" title="1">{
                                if len(cmd.DefaultOrgRole) &gt; 0 </span><span class="cov0" title="0">{
                                        orgUser.Role = m.RoleType(cmd.DefaultOrgRole)
                                }</span><span class="cov8" title="1"> else {
                                        orgUser.Role = m.RoleType(setting.AutoAssignOrgRole)
                                }</span>
                        }

                        <span class="cov8" title="1">if _, err = sess.Insert(&amp;orgUser); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                <span class="cov8" title="1">return nil</span>
        })
}

func GetUserById(query *m.GetUserByIdQuery) error <span class="cov0" title="0">{
        user := new(m.User)
        has, err := x.Id(query.Id).Get(user)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span><span class="cov0" title="0"> else if has == false </span><span class="cov0" title="0">{
                return m.ErrUserNotFound
        }</span>

        <span class="cov0" title="0">query.Result = user

        return nil</span>
}

func GetUserByLogin(query *m.GetUserByLoginQuery) error <span class="cov0" title="0">{
        if query.LoginOrEmail == "" </span><span class="cov0" title="0">{
                return m.ErrUserNotFound
        }</span>

        <span class="cov0" title="0">user := new(m.User)

        // Try and find the user by login first.
        // It's not sufficient to assume that a LoginOrEmail with an "@" is an email.
        user = &amp;m.User{Login: query.LoginOrEmail}
        has, err := x.Get(user)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if has == false &amp;&amp; strings.Contains(query.LoginOrEmail, "@") </span><span class="cov0" title="0">{
                // If the user wasn't found, and it contains an "@" fallback to finding the
                // user by email.
                user = &amp;m.User{Email: query.LoginOrEmail}
                has, err = x.Get(user)
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span><span class="cov0" title="0"> else if has == false </span><span class="cov0" title="0">{
                return m.ErrUserNotFound
        }</span>

        <span class="cov0" title="0">query.Result = user

        return nil</span>
}

func GetUserByEmail(query *m.GetUserByEmailQuery) error <span class="cov0" title="0">{
        if query.Email == "" </span><span class="cov0" title="0">{
                return m.ErrUserNotFound
        }</span>

        <span class="cov0" title="0">user := new(m.User)

        user = &amp;m.User{Email: query.Email}
        has, err := x.Get(user)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span><span class="cov0" title="0"> else if has == false </span><span class="cov0" title="0">{
                return m.ErrUserNotFound
        }</span>

        <span class="cov0" title="0">query.Result = user

        return nil</span>
}

func UpdateUser(cmd *m.UpdateUserCommand) error <span class="cov0" title="0">{
        return inTransaction2(func(sess *session) error </span><span class="cov0" title="0">{

                user := m.User{
                        Name:    cmd.Name,
                        Email:   cmd.Email,
                        Login:   cmd.Login,
                        Theme:   cmd.Theme,
                        Updated: time.Now(),
                }

                if _, err := sess.Id(cmd.UserId).Update(&amp;user); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">sess.publishAfterCommit(&amp;events.UserUpdated{
                        Timestamp: user.Created,
                        Id:        user.Id,
                        Name:      user.Name,
                        Login:     user.Login,
                        Email:     user.Email,
                })

                return nil</span>
        })
}

func ChangeUserPassword(cmd *m.ChangeUserPasswordCommand) error <span class="cov0" title="0">{
        return inTransaction2(func(sess *session) error </span><span class="cov0" title="0">{

                user := m.User{
                        Password: cmd.NewPassword,
                        Updated:  time.Now(),
                }

                if _, err := sess.Id(cmd.UserId).Update(&amp;user); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">return nil</span>
        })
}

func SetUsingOrg(cmd *m.SetUsingOrgCommand) error <span class="cov8" title="1">{
        getOrgsForUserCmd := &amp;m.GetUserOrgListQuery{UserId: cmd.UserId}
        GetUserOrgList(getOrgsForUserCmd)

        valid := false
        for _, other := range getOrgsForUserCmd.Result </span><span class="cov8" title="1">{
                if other.OrgId == cmd.OrgId </span><span class="cov8" title="1">{
                        valid = true
                }</span>
        }

        <span class="cov8" title="1">if !valid </span><span class="cov0" title="0">{
                return fmt.Errorf("user does not belong ot org")
        }</span>

        <span class="cov8" title="1">return inTransaction(func(sess *xorm.Session) error </span><span class="cov8" title="1">{
                user := m.User{}
                sess.Id(cmd.UserId).Get(&amp;user)

                user.OrgId = cmd.OrgId
                _, err := sess.Id(user.Id).Update(&amp;user)
                return err
        }</span>)
}

func GetUserProfile(query *m.GetUserProfileQuery) error <span class="cov8" title="1">{
        var user m.User
        has, err := x.Id(query.UserId).Get(&amp;user)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span><span class="cov8" title="1"> else if has == false </span><span class="cov0" title="0">{
                return m.ErrUserNotFound
        }</span>

        <span class="cov8" title="1">query.Result = m.UserProfileDTO{
                Name:           user.Name,
                Email:          user.Email,
                Login:          user.Login,
                Theme:          user.Theme,
                IsGrafanaAdmin: user.IsAdmin,
                OrgId:          user.OrgId,
        }

        return err</span>
}

func GetUserOrgList(query *m.GetUserOrgListQuery) error <span class="cov8" title="1">{
        query.Result = make([]*m.UserOrgDTO, 0)
        sess := x.Table("org_user")
        sess.Join("INNER", "org", "org_user.org_id=org.id")
        sess.Where("org_user.user_id=?", query.UserId)
        sess.Cols("org.name", "org_user.role", "org_user.org_id")
        err := sess.Find(&amp;query.Result)
        return err
}</span>

func GetSignedInUser(query *m.GetSignedInUserQuery) error <span class="cov8" title="1">{
        var rawSql = `SELECT
                        u.id           as user_id,
                        u.is_admin     as is_grafana_admin,
                        u.email        as email,
                        u.login        as login,
                                                                        u.name         as name,
                                                                        u.help_flags1  as help_flags1,
                        org.name       as org_name,
                        org_user.role  as org_role,
                        org.id         as org_id
                        FROM ` + dialect.Quote("user") + ` as u
                                                                        LEFT OUTER JOIN org_user on org_user.org_id = u.org_id and org_user.user_id = u.id
                        LEFT OUTER JOIN org on org.id = u.org_id `

        sess := x.Table("user")
        if query.UserId &gt; 0 </span><span class="cov8" title="1">{
                sess.Sql(rawSql+"WHERE u.id=?", query.UserId)
        }</span><span class="cov0" title="0"> else if query.Login != "" </span><span class="cov0" title="0">{
                sess.Sql(rawSql+"WHERE u.login=?", query.Login)
        }</span><span class="cov0" title="0"> else if query.Email != "" </span><span class="cov0" title="0">{
                sess.Sql(rawSql+"WHERE u.email=?", query.Email)
        }</span>

        <span class="cov8" title="1">var user m.SignedInUser
        has, err := sess.Get(&amp;user)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span><span class="cov8" title="1"> else if !has </span><span class="cov0" title="0">{
                return m.ErrUserNotFound
        }</span>

        <span class="cov8" title="1">if user.OrgRole == "" </span><span class="cov0" title="0">{
                user.OrgId = -1
                user.OrgName = "Org missing"
        }</span>

        <span class="cov8" title="1">query.Result = &amp;user
        return err</span>
}

func SearchUsers(query *m.SearchUsersQuery) error <span class="cov8" title="1">{
        query.Result = m.SearchUserQueryResult{
                Users: make([]*m.UserSearchHitDTO, 0),
        }
        sess := x.Table("user")
        sess.Where("email LIKE ?", query.Query+"%")
        offset := query.Limit * (query.Page - 1)
        sess.Limit(query.Limit, offset)
        sess.Cols("id", "email", "name", "login", "is_admin")
        if err := sess.Find(&amp;query.Result.Users); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">user := m.User{}
        count, err := x.Count(&amp;user)
        query.Result.TotalCount = count
        return err</span>
}

func DeleteUser(cmd *m.DeleteUserCommand) error <span class="cov0" title="0">{
        return inTransaction(func(sess *xorm.Session) error </span><span class="cov0" title="0">{
                deletes := []string{
                        "DELETE FROM star WHERE user_id = ?",
                        "DELETE FROM " + dialect.Quote("user") + " WHERE id = ?",
                }

                for _, sql := range deletes </span><span class="cov0" title="0">{
                        _, err := sess.Exec(sql, cmd.UserId)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                <span class="cov0" title="0">return nil</span>
        })
}

func UpdateUserPermissions(cmd *m.UpdateUserPermissionsCommand) error <span class="cov0" title="0">{
        return inTransaction(func(sess *xorm.Session) error </span><span class="cov0" title="0">{
                user := m.User{}
                sess.Id(cmd.UserId).Get(&amp;user)

                user.IsAdmin = cmd.IsGrafanaAdmin
                sess.UseBool("is_admin")
                _, err := sess.Id(user.Id).Update(&amp;user)
                return err
        }</span>)
}

func SetUserHelpFlag(cmd *m.SetUserHelpFlagCommand) error <span class="cov0" title="0">{
        return inTransaction2(func(sess *session) error </span><span class="cov0" title="0">{

                user := m.User{
                        Id:         cmd.UserId,
                        HelpFlags1: cmd.HelpFlags1,
                        Updated:    time.Now(),
                }

                if _, err := sess.Id(cmd.UserId).Cols("help_flags1").Update(&amp;user); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">return nil</span>
        })
}
</pre>
		
		<pre class="file" id="file180" style="display: none">// Copyright 2014 Unknwon
// Copyright 2014 Torkel Ödegaard

package setting

import (
        "bytes"
        "fmt"
        "net/url"
        "os"
        "path"
        "path/filepath"
        "regexp"
        "runtime"
        "strings"

        "gopkg.in/ini.v1"

        "github.com/go-macaron/session"

        "github.com/grafana/grafana/pkg/log"
        "github.com/grafana/grafana/pkg/util"
)

type Scheme string

const (
        HTTP              Scheme = "http"
        HTTPS             Scheme = "https"
        DEFAULT_HTTP_ADDR string = "0.0.0.0"
)

const (
        DEV  string = "development"
        PROD string = "production"
        TEST string = "test"
)

var (
        // App settings.
        Env          string = DEV
        AppUrl       string
        AppSubUrl    string
        InstanceName string

        // build
        BuildVersion string
        BuildCommit  string
        BuildStamp   int64

        // Paths
        LogsPath       string
        HomePath       string
        DataPath       string
        PluginsPath    string
        CustomInitPath = "conf/custom.ini"

        // Log settings.
        LogModes   []string
        LogConfigs []util.DynMap

        // Http server options
        Protocol           Scheme
        Domain             string
        HttpAddr, HttpPort string
        SshPort            int
        CertFile, KeyFile  string
        RouterLogging      bool
        DataProxyLogging   bool
        StaticRootPath     string
        EnableGzip         bool
        EnforceDomain      bool

        // Security settings.
        SecretKey             string
        LogInRememberDays     int
        CookieUserName        string
        CookieRememberName    string
        DisableGravatar       bool
        EmailCodeValidMinutes int
        DataProxyWhiteList    map[string]bool

        // Snapshots
        ExternalSnapshotUrl   string
        ExternalSnapshotName  string
        ExternalEnabled       bool
        SnapShotTTLDays       int
        SnapShotRemoveExpired bool

        // User settings
        AllowUserSignUp    bool
        AllowUserOrgCreate bool
        AutoAssignOrg      bool
        AutoAssignOrgRole  string
        VerifyEmailEnabled bool
        LoginHint          string
        DefaultTheme       string
        DisableLoginForm   bool

        // Http auth
        AdminUser     string
        AdminPassword string

        AnonymousEnabled bool
        AnonymousOrgName string
        AnonymousOrgRole string

        // Auth proxy settings
        AuthProxyEnabled        bool
        AuthProxyHeaderName     string
        AuthProxyHeaderProperty string
        AuthProxyAutoSignUp     bool
        AuthProxyLdapSyncTtl    int
        AuthProxyWhitelist      string

        // Basic Auth
        BasicAuthEnabled bool

        // Session settings.
        SessionOptions session.Options

        // Global setting objects.
        Cfg          *ini.File
        ConfRootPath string
        IsWindows    bool

        // PhantomJs Rendering
        ImagesDir  string
        PhantomDir string

        // for logging purposes
        configFiles                  []string
        appliedCommandLineProperties []string
        appliedEnvOverrides          []string

        ReportingEnabled   bool
        CheckForUpdates    bool
        GoogleAnalyticsId  string
        GoogleTagManagerId string

        // LDAP
        LdapEnabled     bool
        LdapConfigFile  string
        LdapAllowSignup bool = true

        // SMTP email settings
        Smtp SmtpSettings

        // QUOTA
        Quota QuotaSettings

        // Alerting
        AlertingEnabled bool
        ExecuteAlerts   bool

        // logger
        logger log.Logger

        // Grafana.NET URL
        GrafanaNetUrl string

        // S3 temp image store
        S3TempImageStoreBucketUrl string
        S3TempImageStoreAccessKey string
        S3TempImageStoreSecretKey string

        ImageUploadProvider string
)

type CommandLineArgs struct {
        Config   string
        HomePath string
        Args     []string
}

func init() <span class="cov8" title="1">{
        IsWindows = runtime.GOOS == "windows"
        logger = log.New("settings")
}</span>

func parseAppUrlAndSubUrl(section *ini.Section) (string, string) <span class="cov8" title="1">{
        appUrl := section.Key("root_url").MustString("http://localhost:3000/")
        if appUrl[len(appUrl)-1] != '/' </span><span class="cov0" title="0">{
                appUrl += "/"
        }</span>

        // Check if has app suburl.
        <span class="cov8" title="1">url, err := url.Parse(appUrl)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(4, "Invalid root_url(%s): %s", appUrl, err)
        }</span>
        <span class="cov8" title="1">appSubUrl := strings.TrimSuffix(url.Path, "/")

        return appUrl, appSubUrl</span>
}

func ToAbsUrl(relativeUrl string) string <span class="cov0" title="0">{
        return AppUrl + relativeUrl
}</span>

func shouldRedactKey(s string) bool <span class="cov8" title="1">{
        uppercased := strings.ToUpper(s)
        return strings.Contains(uppercased, "PASSWORD") || strings.Contains(uppercased, "SECRET") || strings.Contains(uppercased, "PROVIDER_CONFIG")
}</span>

func shouldRedactURLKey(s string) bool <span class="cov8" title="1">{
        uppercased := strings.ToUpper(s)
        return strings.Contains(uppercased, "DATABASE_URL")
}</span>

func applyEnvVariableOverrides() <span class="cov8" title="1">{
        appliedEnvOverrides = make([]string, 0)
        for _, section := range Cfg.Sections() </span><span class="cov8" title="1">{
                for _, key := range section.Keys() </span><span class="cov8" title="1">{
                        sectionName := strings.ToUpper(strings.Replace(section.Name(), ".", "_", -1))
                        keyName := strings.ToUpper(strings.Replace(key.Name(), ".", "_", -1))
                        envKey := fmt.Sprintf("GF_%s_%s", sectionName, keyName)
                        envValue := os.Getenv(envKey)

                        if len(envValue) &gt; 0 </span><span class="cov8" title="1">{
                                key.SetValue(envValue)
                                if shouldRedactKey(envKey) </span><span class="cov8" title="1">{
                                        envValue = "*********"
                                }</span>
                                <span class="cov8" title="1">if shouldRedactURLKey(envKey) </span><span class="cov8" title="1">{
                                        u, _ := url.Parse(envValue)
                                        ui := u.User
                                        if ui != nil </span><span class="cov8" title="1">{
                                                _, exists := ui.Password()
                                                if exists </span><span class="cov8" title="1">{
                                                        u.User = url.UserPassword(ui.Username(), "-redacted-")
                                                        envValue = u.String()
                                                }</span>
                                        }
                                }
                                <span class="cov8" title="1">appliedEnvOverrides = append(appliedEnvOverrides, fmt.Sprintf("%s=%s", envKey, envValue))</span>
                        }
                }
        }
}

func applyCommandLineDefaultProperties(props map[string]string) <span class="cov8" title="1">{
        appliedCommandLineProperties = make([]string, 0)
        for _, section := range Cfg.Sections() </span><span class="cov8" title="1">{
                for _, key := range section.Keys() </span><span class="cov8" title="1">{
                        keyString := fmt.Sprintf("default.%s.%s", section.Name(), key.Name())
                        value, exists := props[keyString]
                        if exists </span><span class="cov8" title="1">{
                                key.SetValue(value)
                                if shouldRedactKey(keyString) </span><span class="cov0" title="0">{
                                        value = "*********"
                                }</span>
                                <span class="cov8" title="1">appliedCommandLineProperties = append(appliedCommandLineProperties, fmt.Sprintf("%s=%s", keyString, value))</span>
                        }
                }
        }
}

func applyCommandLineProperties(props map[string]string) <span class="cov8" title="1">{
        for _, section := range Cfg.Sections() </span><span class="cov8" title="1">{
                for _, key := range section.Keys() </span><span class="cov8" title="1">{
                        keyString := fmt.Sprintf("%s.%s", section.Name(), key.Name())
                        value, exists := props[keyString]
                        if exists </span><span class="cov8" title="1">{
                                key.SetValue(value)
                                appliedCommandLineProperties = append(appliedCommandLineProperties, fmt.Sprintf("%s=%s", keyString, value))
                        }</span>
                }
        }
}

func getCommandLineProperties(args []string) map[string]string <span class="cov8" title="1">{
        props := make(map[string]string)

        for _, arg := range args </span><span class="cov8" title="1">{
                if !strings.HasPrefix(arg, "cfg:") </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">trimmed := strings.TrimPrefix(arg, "cfg:")
                parts := strings.Split(trimmed, "=")
                if len(parts) != 2 </span><span class="cov0" title="0">{
                        log.Fatal(3, "Invalid command line argument", arg)
                        return nil
                }</span>

                <span class="cov8" title="1">props[parts[0]] = parts[1]</span>
        }
        <span class="cov8" title="1">return props</span>
}

func makeAbsolute(path string, root string) string <span class="cov8" title="1">{
        if filepath.IsAbs(path) </span><span class="cov8" title="1">{
                return path
        }</span>
        <span class="cov8" title="1">return filepath.Join(root, path)</span>
}

func evalEnvVarExpression(value string) string <span class="cov8" title="1">{
        regex := regexp.MustCompile(`\${(\w+)}`)
        return regex.ReplaceAllStringFunc(value, func(envVar string) string </span><span class="cov8" title="1">{
                envVar = strings.TrimPrefix(envVar, "${")
                envVar = strings.TrimSuffix(envVar, "}")
                envValue := os.Getenv(envVar)

                // if env variable is hostname and it is emtpy use os.Hostname as default
                if envVar == "HOSTNAME" &amp;&amp; envValue == "" </span><span class="cov8" title="1">{
                        envValue, _ = os.Hostname()
                }</span>

                <span class="cov8" title="1">return envValue</span>
        })
}

func evalConfigValues() <span class="cov8" title="1">{
        for _, section := range Cfg.Sections() </span><span class="cov8" title="1">{
                for _, key := range section.Keys() </span><span class="cov8" title="1">{
                        key.SetValue(evalEnvVarExpression(key.Value()))
                }</span>
        }
}

func loadSpecifedConfigFile(configFile string) error <span class="cov8" title="1">{
        if configFile == "" </span><span class="cov8" title="1">{
                configFile = filepath.Join(HomePath, CustomInitPath)
                // return without error if custom file does not exist
                if !pathExists(configFile) </span><span class="cov8" title="1">{
                        return nil
                }</span>
        }

        <span class="cov8" title="1">userConfig, err := ini.Load(configFile)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Failed to parse %v, %v", configFile, err)
        }</span>

        <span class="cov8" title="1">userConfig.BlockMode = false

        for _, section := range userConfig.Sections() </span><span class="cov8" title="1">{
                for _, key := range section.Keys() </span><span class="cov8" title="1">{
                        if key.Value() == "" </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov8" title="1">defaultSec, err := Cfg.GetSection(section.Name())
                        if err != nil </span><span class="cov0" title="0">{
                                defaultSec, _ = Cfg.NewSection(section.Name())
                        }</span>
                        <span class="cov8" title="1">defaultKey, err := defaultSec.GetKey(key.Name())
                        if err != nil </span><span class="cov0" title="0">{
                                defaultKey, _ = defaultSec.NewKey(key.Name(), key.Value())
                        }</span>
                        <span class="cov8" title="1">defaultKey.SetValue(key.Value())</span>
                }
        }

        <span class="cov8" title="1">configFiles = append(configFiles, configFile)
        return nil</span>
}

func loadConfiguration(args *CommandLineArgs) <span class="cov8" title="1">{
        var err error

        // load config defaults
        defaultConfigFile := path.Join(HomePath, "conf/defaults.ini")
        configFiles = append(configFiles, defaultConfigFile)

        // check if config file exists
        if _, err := os.Stat(defaultConfigFile); os.IsNotExist(err) </span><span class="cov0" title="0">{
                fmt.Println("Grafana-server Init Failed: Could not find config defaults, make sure homepath command line parameter is set or working directory is homepath")
                os.Exit(1)
        }</span>

        // load defaults
        <span class="cov8" title="1">Cfg, err = ini.Load(defaultConfigFile)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println(fmt.Sprintf("Failed to parse defaults.ini, %v", err))
                os.Exit(1)
                return
        }</span>

        <span class="cov8" title="1">Cfg.BlockMode = false

        // command line props
        commandLineProps := getCommandLineProperties(args.Args)
        // load default overrides
        applyCommandLineDefaultProperties(commandLineProps)

        // load specified config file
        err = loadSpecifedConfigFile(args.Config)
        if err != nil </span><span class="cov0" title="0">{
                initLogging()
                log.Fatal(3, err.Error())
        }</span>

        // apply environment overrides
        <span class="cov8" title="1">applyEnvVariableOverrides()

        // apply command line overrides
        applyCommandLineProperties(commandLineProps)

        // evaluate config values containing environment variables
        evalConfigValues()

        // update data path and logging config
        DataPath = makeAbsolute(Cfg.Section("paths").Key("data").String(), HomePath)
        initLogging()</span>
}

func pathExists(path string) bool <span class="cov8" title="1">{
        _, err := os.Stat(path)
        if err == nil </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov8" title="1">if os.IsNotExist(err) </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov0" title="0">return false</span>
}

func setHomePath(args *CommandLineArgs) <span class="cov8" title="1">{
        if args.HomePath != "" </span><span class="cov8" title="1">{
                HomePath = args.HomePath
                return
        }</span>

        <span class="cov0" title="0">HomePath, _ = filepath.Abs(".")
        // check if homepath is correct
        if pathExists(filepath.Join(HomePath, "conf/defaults.ini")) </span><span class="cov0" title="0">{
                return
        }</span>

        // try down one path
        <span class="cov0" title="0">if pathExists(filepath.Join(HomePath, "../conf/defaults.ini")) </span><span class="cov0" title="0">{
                HomePath = filepath.Join(HomePath, "../")
        }</span>
}

var skipStaticRootValidation bool = false

func validateStaticRootPath() error <span class="cov8" title="1">{
        if skipStaticRootValidation </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov0" title="0">if _, err := os.Stat(path.Join(StaticRootPath, "css")); err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">if _, err := os.Stat(StaticRootPath + "_gen/css"); err == nil </span><span class="cov0" title="0">{
                StaticRootPath = StaticRootPath + "_gen"
                return nil
        }</span>

        <span class="cov0" title="0">return fmt.Errorf("Failed to detect generated css or javascript files in static root (%s), have you executed default grunt task?", StaticRootPath)</span>
}

func NewConfigContext(args *CommandLineArgs) error <span class="cov8" title="1">{
        setHomePath(args)
        loadConfiguration(args)

        Env = Cfg.Section("").Key("app_mode").MustString("development")
        InstanceName = Cfg.Section("").Key("instance_name").MustString("unknown_instance_name")
        PluginsPath = makeAbsolute(Cfg.Section("paths").Key("plugins").String(), HomePath)

        server := Cfg.Section("server")
        AppUrl, AppSubUrl = parseAppUrlAndSubUrl(server)

        Protocol = HTTP
        if server.Key("protocol").MustString("http") == "https" </span><span class="cov0" title="0">{
                Protocol = HTTPS
                CertFile = server.Key("cert_file").String()
                KeyFile = server.Key("cert_key").String()
        }</span>

        <span class="cov8" title="1">Domain = server.Key("domain").MustString("localhost")
        HttpAddr = server.Key("http_addr").MustString(DEFAULT_HTTP_ADDR)
        HttpPort = server.Key("http_port").MustString("3000")
        RouterLogging = server.Key("router_logging").MustBool(false)

        EnableGzip = server.Key("enable_gzip").MustBool(false)
        EnforceDomain = server.Key("enforce_domain").MustBool(false)
        StaticRootPath = makeAbsolute(server.Key("static_root_path").String(), HomePath)

        if err := validateStaticRootPath(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // read data proxy settings
        <span class="cov8" title="1">dataproxy := Cfg.Section("dataproxy")
        DataProxyLogging = dataproxy.Key("logging").MustBool(false)

        // read security settings
        security := Cfg.Section("security")
        SecretKey = security.Key("secret_key").String()
        LogInRememberDays = security.Key("login_remember_days").MustInt()
        CookieUserName = security.Key("cookie_username").String()
        CookieRememberName = security.Key("cookie_remember_name").String()
        DisableGravatar = security.Key("disable_gravatar").MustBool(true)

        // read snapshots settings
        snapshots := Cfg.Section("snapshots")
        ExternalSnapshotUrl = snapshots.Key("external_snapshot_url").String()
        ExternalSnapshotName = snapshots.Key("external_snapshot_name").String()
        ExternalEnabled = snapshots.Key("external_enabled").MustBool(true)
        SnapShotRemoveExpired = snapshots.Key("snapshot_remove_expired").MustBool(true)
        SnapShotTTLDays = snapshots.Key("snapshot_TTL_days").MustInt(90)

        //  read data source proxy white list
        DataProxyWhiteList = make(map[string]bool)
        for _, hostAndIp := range security.Key("data_source_proxy_whitelist").Strings(" ") </span><span class="cov0" title="0">{
                DataProxyWhiteList[hostAndIp] = true
        }</span>

        // admin
        <span class="cov8" title="1">AdminUser = security.Key("admin_user").String()
        AdminPassword = security.Key("admin_password").String()

        users := Cfg.Section("users")
        AllowUserSignUp = users.Key("allow_sign_up").MustBool(true)
        AllowUserOrgCreate = users.Key("allow_org_create").MustBool(true)
        AutoAssignOrg = users.Key("auto_assign_org").MustBool(true)
        AutoAssignOrgRole = users.Key("auto_assign_org_role").In("Editor", []string{"Editor", "Admin", "Read Only Editor", "Viewer"})
        VerifyEmailEnabled = users.Key("verify_email_enabled").MustBool(false)
        LoginHint = users.Key("login_hint").String()
        DefaultTheme = users.Key("default_theme").String()

        // auth
        auth := Cfg.Section("auth")
        DisableLoginForm = auth.Key("disable_login_form").MustBool(false)

        // anonymous access
        AnonymousEnabled = Cfg.Section("auth.anonymous").Key("enabled").MustBool(false)
        AnonymousOrgName = Cfg.Section("auth.anonymous").Key("org_name").String()
        AnonymousOrgRole = Cfg.Section("auth.anonymous").Key("org_role").String()

        // auth proxy
        authProxy := Cfg.Section("auth.proxy")
        AuthProxyEnabled = authProxy.Key("enabled").MustBool(false)
        AuthProxyHeaderName = authProxy.Key("header_name").String()
        AuthProxyHeaderProperty = authProxy.Key("header_property").String()
        AuthProxyAutoSignUp = authProxy.Key("auto_sign_up").MustBool(true)
        AuthProxyLdapSyncTtl = authProxy.Key("ldap_sync_ttl").MustInt()
        AuthProxyWhitelist = authProxy.Key("whitelist").String()

        // basic auth
        authBasic := Cfg.Section("auth.basic")
        BasicAuthEnabled = authBasic.Key("enabled").MustBool(true)

        // PhantomJS rendering
        ImagesDir = filepath.Join(DataPath, "png")
        PhantomDir = filepath.Join(HomePath, "vendor/phantomjs")

        analytics := Cfg.Section("analytics")
        ReportingEnabled = analytics.Key("reporting_enabled").MustBool(true)
        CheckForUpdates = analytics.Key("check_for_updates").MustBool(true)
        GoogleAnalyticsId = analytics.Key("google_analytics_ua_id").String()
        GoogleTagManagerId = analytics.Key("google_tag_manager_id").String()

        ldapSec := Cfg.Section("auth.ldap")
        LdapEnabled = ldapSec.Key("enabled").MustBool(false)
        LdapConfigFile = ldapSec.Key("config_file").String()
        LdapAllowSignup = ldapSec.Key("allow_sign_up").MustBool(true)

        alerting := Cfg.Section("alerting")
        AlertingEnabled = alerting.Key("enabled").MustBool(true)
        ExecuteAlerts = alerting.Key("execute_alerts").MustBool(true)

        readSessionConfig()
        readSmtpSettings()
        readQuotaSettings()

        if VerifyEmailEnabled &amp;&amp; !Smtp.Enabled </span><span class="cov0" title="0">{
                log.Warn("require_email_validation is enabled but smpt is disabled")
        }</span>

        <span class="cov8" title="1">GrafanaNetUrl = Cfg.Section("grafana_net").Key("url").MustString("https://grafana.net")

        imageUploadingSection := Cfg.Section("external_image_storage")
        ImageUploadProvider = imageUploadingSection.Key("provider").MustString("internal")
        return nil</span>
}

func readSessionConfig() <span class="cov8" title="1">{
        sec := Cfg.Section("session")
        SessionOptions = session.Options{}
        SessionOptions.Provider = sec.Key("provider").In("memory", []string{"memory", "file", "redis", "mysql", "postgres", "memcache"})
        SessionOptions.ProviderConfig = strings.Trim(sec.Key("provider_config").String(), "\" ")
        SessionOptions.CookieName = sec.Key("cookie_name").MustString("grafana_sess")
        SessionOptions.CookiePath = AppSubUrl
        SessionOptions.Secure = sec.Key("cookie_secure").MustBool()
        SessionOptions.Gclifetime = Cfg.Section("session").Key("gc_interval_time").MustInt64(86400)
        SessionOptions.Maxlifetime = Cfg.Section("session").Key("session_life_time").MustInt64(86400)
        SessionOptions.IDLength = 16

        if SessionOptions.Provider == "file" </span><span class="cov8" title="1">{
                SessionOptions.ProviderConfig = makeAbsolute(SessionOptions.ProviderConfig, DataPath)
                os.MkdirAll(path.Dir(SessionOptions.ProviderConfig), os.ModePerm)
        }</span>

        <span class="cov8" title="1">if SessionOptions.CookiePath == "" </span><span class="cov8" title="1">{
                SessionOptions.CookiePath = "/"
        }</span>
}

func initLogging() <span class="cov8" title="1">{
        // split on comma
        LogModes = strings.Split(Cfg.Section("log").Key("mode").MustString("console"), ",")
        // also try space
        if len(LogModes) == 1 </span><span class="cov8" title="1">{
                LogModes = strings.Split(Cfg.Section("log").Key("mode").MustString("console"), " ")
        }</span>
        <span class="cov8" title="1">LogsPath = makeAbsolute(Cfg.Section("paths").Key("logs").String(), HomePath)
        log.ReadLoggingConfig(LogModes, LogsPath, Cfg)</span>
}

func LogConfigurationInfo() <span class="cov0" title="0">{
        var text bytes.Buffer

        for _, file := range configFiles </span><span class="cov0" title="0">{
                logger.Info("Config loaded from", "file", file)
        }</span>

        <span class="cov0" title="0">if len(appliedCommandLineProperties) &gt; 0 </span><span class="cov0" title="0">{
                for _, prop := range appliedCommandLineProperties </span><span class="cov0" title="0">{
                        logger.Info("Config overriden from command line", "arg", prop)
                }</span>
        }

        <span class="cov0" title="0">if len(appliedEnvOverrides) &gt; 0 </span><span class="cov0" title="0">{
                text.WriteString("\tEnvironment variables used:\n")
                for _, prop := range appliedEnvOverrides </span><span class="cov0" title="0">{
                        logger.Info("Config overriden from Environment variable", "var", prop)
                }</span>
        }

        <span class="cov0" title="0">logger.Info("Path Home", "path", HomePath)
        logger.Info("Path Data", "path", DataPath)
        logger.Info("Path Logs", "path", LogsPath)
        logger.Info("Path Plugins", "path", PluginsPath)</span>
}
</pre>
		
		<pre class="file" id="file181" style="display: none">package setting

import (
        "reflect"
)

type OrgQuota struct {
        User       int64 `target:"org_user"`
        DataSource int64 `target:"data_source"`
        Dashboard  int64 `target:"dashboard"`
        ApiKey     int64 `target:"api_key"`
}

type UserQuota struct {
        Org int64 `target:"org_user"`
}

type GlobalQuota struct {
        Org        int64 `target:"org"`
        User       int64 `target:"user"`
        DataSource int64 `target:"data_source"`
        Dashboard  int64 `target:"dashboard"`
        ApiKey     int64 `target:"api_key"`
        Session    int64 `target:"-"`
}

func (q *OrgQuota) ToMap() map[string]int64 <span class="cov0" title="0">{
        return quotaToMap(*q)
}</span>

func (q *UserQuota) ToMap() map[string]int64 <span class="cov0" title="0">{
        return quotaToMap(*q)
}</span>

func (q *GlobalQuota) ToMap() map[string]int64 <span class="cov0" title="0">{
        return quotaToMap(*q)
}</span>

func quotaToMap(q interface{}) map[string]int64 <span class="cov0" title="0">{
        qMap := make(map[string]int64)
        typ := reflect.TypeOf(q)
        val := reflect.ValueOf(q)

        for i := 0; i &lt; typ.NumField(); i++ </span><span class="cov0" title="0">{
                field := typ.Field(i)
                name := field.Tag.Get("target")
                if name == "" </span><span class="cov0" title="0">{
                        name = field.Name
                }</span>
                <span class="cov0" title="0">if name == "-" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">value := val.Field(i)
                qMap[name] = value.Int()</span>
        }
        <span class="cov0" title="0">return qMap</span>
}

type QuotaSettings struct {
        Enabled bool
        Org     *OrgQuota
        User    *UserQuota
        Global  *GlobalQuota
}

func readQuotaSettings() <span class="cov8" title="1">{
        // set global defaults.
        quota := Cfg.Section("quota")
        Quota.Enabled = quota.Key("enabled").MustBool(false)

        // per ORG Limits
        Quota.Org = &amp;OrgQuota{
                User:       quota.Key("org_user").MustInt64(10),
                DataSource: quota.Key("org_data_source").MustInt64(10),
                Dashboard:  quota.Key("org_dashboard").MustInt64(10),
                ApiKey:     quota.Key("org_api_key").MustInt64(10),
        }

        // per User limits
        Quota.User = &amp;UserQuota{
                Org: quota.Key("user_org").MustInt64(10),
        }

        // Global Limits
        Quota.Global = &amp;GlobalQuota{
                User:       quota.Key("global_user").MustInt64(-1),
                Org:        quota.Key("global_org").MustInt64(-1),
                DataSource: quota.Key("global_data_source").MustInt64(-1),
                Dashboard:  quota.Key("global_dashboard").MustInt64(-1),
                ApiKey:     quota.Key("global_api_key").MustInt64(-1),
                Session:    quota.Key("global_session").MustInt64(-1),
        }

}</span>
</pre>
		
		<pre class="file" id="file182" style="display: none">package setting

type SmtpSettings struct {
        Enabled     bool
        Host        string
        User        string
        Password    string
        CertFile    string
        KeyFile     string
        FromAddress string
        FromName    string
        SkipVerify  bool

        SendWelcomeEmailOnSignUp bool
        TemplatesPattern         string
}

func readSmtpSettings() <span class="cov8" title="1">{
        sec := Cfg.Section("smtp")
        Smtp.Enabled = sec.Key("enabled").MustBool(false)
        Smtp.Host = sec.Key("host").String()
        Smtp.User = sec.Key("user").String()
        Smtp.Password = sec.Key("password").String()
        Smtp.CertFile = sec.Key("cert_file").String()
        Smtp.KeyFile = sec.Key("key_file").String()
        Smtp.FromAddress = sec.Key("from_address").String()
        Smtp.FromName = sec.Key("from_name").String()
        Smtp.SkipVerify = sec.Key("skip_verify").MustBool(false)

        emails := Cfg.Section("emails")
        Smtp.SendWelcomeEmailOnSignUp = emails.Key("welcome_email_on_sign_up").MustBool(false)
        Smtp.TemplatesPattern = emails.Key("templates_pattern").MustString("emails/*.html")
}</span>
</pre>
		
		<pre class="file" id="file183" style="display: none">package tsdb

import "context"

type Batch struct {
        DataSourceId int64
        Queries      QuerySlice
        Depends      map[string]bool
        Done         bool
        Started      bool
}

type BatchSlice []*Batch

func newBatch(dsId int64, queries QuerySlice) *Batch <span class="cov8" title="1">{
        return &amp;Batch{
                DataSourceId: dsId,
                Queries:      queries,
                Depends:      make(map[string]bool),
        }
}</span>

func (bg *Batch) process(ctx context.Context, queryContext *QueryContext) <span class="cov8" title="1">{
        executor, err := getExecutorFor(bg.Queries[0].DataSource)

        if err != nil </span><span class="cov8" title="1">{
                bg.Done = true
                result := &amp;BatchResult{
                        Error:        err,
                        QueryResults: make(map[string]*QueryResult),
                }
                for _, query := range bg.Queries </span><span class="cov8" title="1">{
                        result.QueryResults[query.RefId] = &amp;QueryResult{Error: result.Error}
                }</span>
                <span class="cov8" title="1">queryContext.ResultsChan &lt;- result
                return</span>
        }

        <span class="cov8" title="1">res := executor.Execute(ctx, bg.Queries, queryContext)
        bg.Done = true
        queryContext.ResultsChan &lt;- res</span>
}

func (bg *Batch) addQuery(query *Query) <span class="cov8" title="1">{
        bg.Queries = append(bg.Queries, query)
}</span>

func (bg *Batch) allDependenciesAreIn(context *QueryContext) bool <span class="cov8" title="1">{
        for key := range bg.Depends </span><span class="cov8" title="1">{
                if _, exists := context.Results[key]; !exists </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return true</span>
}

func getBatches(req *Request) (BatchSlice, error) <span class="cov8" title="1">{
        batches := make(BatchSlice, 0)

        for _, query := range req.Queries </span><span class="cov8" title="1">{
                if foundBatch := findMatchingBatchGroup(query, batches); foundBatch != nil </span><span class="cov8" title="1">{
                        foundBatch.addQuery(query)
                }</span><span class="cov8" title="1"> else {
                        newBatch := newBatch(query.DataSource.Id, QuerySlice{query})
                        batches = append(batches, newBatch)

                        for _, refId := range query.Depends </span><span class="cov8" title="1">{
                                for _, batch := range batches </span><span class="cov8" title="1">{
                                        for _, batchQuery := range batch.Queries </span><span class="cov8" title="1">{
                                                if batchQuery.RefId == refId </span><span class="cov8" title="1">{
                                                        newBatch.Depends[refId] = true
                                                }</span>
                                        }
                                }
                        }
                }
        }

        <span class="cov8" title="1">return batches, nil</span>
}

func findMatchingBatchGroup(query *Query, batches BatchSlice) *Batch <span class="cov8" title="1">{
        for _, batch := range batches </span><span class="cov8" title="1">{
                if batch.DataSourceId == query.DataSource.Id </span><span class="cov8" title="1">{
                        return batch
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file184" style="display: none">package tsdb

import (
        "context"
        "fmt"

        "github.com/grafana/grafana/pkg/models"
)

type Executor interface {
        Execute(ctx context.Context, queries QuerySlice, query *QueryContext) *BatchResult
}

var registry map[string]GetExecutorFn

type GetExecutorFn func(dsInfo *models.DataSource) (Executor, error)

func init() <span class="cov8" title="1">{
        registry = make(map[string]GetExecutorFn)
}</span>

func getExecutorFor(dsInfo *models.DataSource) (Executor, error) <span class="cov8" title="1">{
        if fn, exists := registry[dsInfo.Type]; exists </span><span class="cov8" title="1">{
                executor, err := fn(dsInfo)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">return executor, nil</span>
        }
        <span class="cov8" title="1">return nil, fmt.Errorf("Could not find executor for data source type: %s", dsInfo.Type)</span>
}

func RegisterExecutor(pluginId string, fn GetExecutorFn) <span class="cov8" title="1">{
        registry[pluginId] = fn
}</span>
</pre>
		
		<pre class="file" id="file185" style="display: none">package graphite

import (
        "context"
        "encoding/json"
        "fmt"
        "io/ioutil"
        "net/http"
        "net/url"
        "path"
        "regexp"
        "strings"

        "golang.org/x/net/context/ctxhttp"

        "github.com/grafana/grafana/pkg/log"
        "github.com/grafana/grafana/pkg/models"
        "github.com/grafana/grafana/pkg/setting"
        "github.com/grafana/grafana/pkg/tsdb"
)

type GraphiteExecutor struct {
        *models.DataSource
        HttpClient *http.Client
}

func NewGraphiteExecutor(datasource *models.DataSource) (tsdb.Executor, error) <span class="cov0" title="0">{
        httpClient, err := datasource.GetHttpClient()

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;GraphiteExecutor{
                DataSource: datasource,
                HttpClient: httpClient,
        }, nil</span>
}

var (
        glog log.Logger
)

func init() <span class="cov8" title="1">{
        glog = log.New("tsdb.graphite")
        tsdb.RegisterExecutor("graphite", NewGraphiteExecutor)
}</span>

func (e *GraphiteExecutor) Execute(ctx context.Context, queries tsdb.QuerySlice, context *tsdb.QueryContext) *tsdb.BatchResult <span class="cov0" title="0">{
        result := &amp;tsdb.BatchResult{}

        formData := url.Values{
                "from":          []string{"-" + formatTimeRange(context.TimeRange.From)},
                "until":         []string{formatTimeRange(context.TimeRange.To)},
                "format":        []string{"json"},
                "maxDataPoints": []string{"500"},
        }

        for _, query := range queries </span><span class="cov0" title="0">{
                if fullTarget, err := query.Model.Get("targetFull").String(); err == nil </span><span class="cov0" title="0">{
                        formData["target"] = []string{fixIntervalFormat(fullTarget)}
                }</span><span class="cov0" title="0"> else {
                        formData["target"] = []string{fixIntervalFormat(query.Model.Get("target").MustString())}
                }</span>
        }

        <span class="cov0" title="0">if setting.Env == setting.DEV </span><span class="cov0" title="0">{
                glog.Debug("Graphite request", "params", formData)
        }</span>

        <span class="cov0" title="0">req, err := e.createRequest(formData)
        if err != nil </span><span class="cov0" title="0">{
                result.Error = err
                return result
        }</span>

        <span class="cov0" title="0">res, err := ctxhttp.Do(ctx, e.HttpClient, req)
        if err != nil </span><span class="cov0" title="0">{
                result.Error = err
                return result
        }</span>

        <span class="cov0" title="0">data, err := e.parseResponse(res)
        if err != nil </span><span class="cov0" title="0">{
                result.Error = err
                return result
        }</span>

        <span class="cov0" title="0">result.QueryResults = make(map[string]*tsdb.QueryResult)
        queryRes := tsdb.NewQueryResult()

        for _, series := range data </span><span class="cov0" title="0">{
                queryRes.Series = append(queryRes.Series, &amp;tsdb.TimeSeries{
                        Name:   series.Target,
                        Points: series.DataPoints,
                })

                if setting.Env == setting.DEV </span><span class="cov0" title="0">{
                        glog.Debug("Graphite response", "target", series.Target, "datapoints", len(series.DataPoints))
                }</span>
        }

        <span class="cov0" title="0">result.QueryResults["A"] = queryRes
        return result</span>
}

func (e *GraphiteExecutor) parseResponse(res *http.Response) ([]TargetResponseDTO, error) <span class="cov0" title="0">{
        body, err := ioutil.ReadAll(res.Body)
        defer res.Body.Close()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if res.StatusCode/100 != 2 </span><span class="cov0" title="0">{
                glog.Info("Request failed", "status", res.Status, "body", string(body))
                return nil, fmt.Errorf("Request failed status: %v", res.Status)
        }</span>

        <span class="cov0" title="0">var data []TargetResponseDTO
        err = json.Unmarshal(body, &amp;data)
        if err != nil </span><span class="cov0" title="0">{
                glog.Info("Failed to unmarshal graphite response", "error", err, "status", res.Status, "body", string(body))
                return nil, err
        }</span>

        <span class="cov0" title="0">return data, nil</span>
}

func (e *GraphiteExecutor) createRequest(data url.Values) (*http.Request, error) <span class="cov0" title="0">{
        u, _ := url.Parse(e.Url)
        u.Path = path.Join(u.Path, "render")

        req, err := http.NewRequest(http.MethodPost, u.String(), strings.NewReader(data.Encode()))
        if err != nil </span><span class="cov0" title="0">{
                glog.Info("Failed to create request", "error", err)
                return nil, fmt.Errorf("Failed to create request. error: %v", err)
        }</span>

        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/x-www-form-urlencoded")
        if e.BasicAuth </span><span class="cov0" title="0">{
                req.SetBasicAuth(e.BasicAuthUser, e.BasicAuthPassword)
        }</span>

        <span class="cov0" title="0">return req, err</span>
}

func formatTimeRange(input string) string <span class="cov8" title="1">{
        if input == "now" </span><span class="cov8" title="1">{
                return input
        }</span>
        <span class="cov8" title="1">return strings.Replace(strings.Replace(input, "m", "min", -1), "M", "mon", -1)</span>
}

func fixIntervalFormat(target string) string <span class="cov8" title="1">{
        rMinute := regexp.MustCompile(`'(\d+)m'`)
        rMin := regexp.MustCompile("m")
        target = rMinute.ReplaceAllStringFunc(target, func(m string) string </span><span class="cov8" title="1">{
                return rMin.ReplaceAllString(m, "min")
        }</span>)
        <span class="cov8" title="1">rMonth := regexp.MustCompile(`'(\d+)M'`)
        rMon := regexp.MustCompile("M")
        target = rMonth.ReplaceAllStringFunc(target, func(M string) string </span><span class="cov8" title="1">{
                return rMon.ReplaceAllString(M, "mon")
        }</span>)
        <span class="cov8" title="1">return target</span>
}
</pre>
		
		<pre class="file" id="file186" style="display: none">package influxdb

import (
        "context"
        "encoding/json"
        "fmt"
        "net/http"
        "net/url"
        "path"

        "golang.org/x/net/context/ctxhttp"

        "github.com/grafana/grafana/pkg/log"
        "github.com/grafana/grafana/pkg/models"
        "github.com/grafana/grafana/pkg/setting"
        "github.com/grafana/grafana/pkg/tsdb"
)

type InfluxDBExecutor struct {
        *models.DataSource
        QueryParser    *InfluxdbQueryParser
        ResponseParser *ResponseParser
        HttpClient     *http.Client
}

func NewInfluxDBExecutor(datasource *models.DataSource) (tsdb.Executor, error) <span class="cov0" title="0">{
        httpClient, err := datasource.GetHttpClient()

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;InfluxDBExecutor{
                DataSource:     datasource,
                QueryParser:    &amp;InfluxdbQueryParser{},
                ResponseParser: &amp;ResponseParser{},
                HttpClient:     httpClient,
        }, nil</span>
}

var (
        glog log.Logger
)

func init() <span class="cov8" title="1">{
        glog = log.New("tsdb.influxdb")
        tsdb.RegisterExecutor("influxdb", NewInfluxDBExecutor)
}</span>

func (e *InfluxDBExecutor) Execute(ctx context.Context, queries tsdb.QuerySlice, context *tsdb.QueryContext) *tsdb.BatchResult <span class="cov0" title="0">{
        result := &amp;tsdb.BatchResult{}

        query, err := e.getQuery(queries, context)
        if err != nil </span><span class="cov0" title="0">{
                return result.WithError(err)
        }</span>

        <span class="cov0" title="0">rawQuery, err := query.Build(context)
        if err != nil </span><span class="cov0" title="0">{
                return result.WithError(err)
        }</span>

        <span class="cov0" title="0">if setting.Env == setting.DEV </span><span class="cov0" title="0">{
                glog.Debug("Influxdb query", "raw query", rawQuery)
        }</span>

        <span class="cov0" title="0">req, err := e.createRequest(rawQuery)
        if err != nil </span><span class="cov0" title="0">{
                return result.WithError(err)
        }</span>

        <span class="cov0" title="0">resp, err := ctxhttp.Do(ctx, e.HttpClient, req)
        if err != nil </span><span class="cov0" title="0">{
                return result.WithError(err)
        }</span>

        <span class="cov0" title="0">if resp.StatusCode/100 != 2 </span><span class="cov0" title="0">{
                return result.WithError(fmt.Errorf("Influxdb returned statuscode invalid status code: %v", resp.Status))
        }</span>

        <span class="cov0" title="0">var response Response
        dec := json.NewDecoder(resp.Body)
        defer resp.Body.Close()
        dec.UseNumber()
        err = dec.Decode(&amp;response)

        if err != nil </span><span class="cov0" title="0">{
                return result.WithError(err)
        }</span>

        <span class="cov0" title="0">if response.Err != nil </span><span class="cov0" title="0">{
                return result.WithError(response.Err)
        }</span>

        <span class="cov0" title="0">result.QueryResults = make(map[string]*tsdb.QueryResult)
        result.QueryResults["A"] = e.ResponseParser.Parse(&amp;response, query)

        return result</span>
}

func (e *InfluxDBExecutor) getQuery(queries tsdb.QuerySlice, context *tsdb.QueryContext) (*Query, error) <span class="cov0" title="0">{
        for _, v := range queries </span><span class="cov0" title="0">{

                query, err := e.QueryParser.Parse(v.Model, e.DataSource)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">return query, nil</span>
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("query request contains no queries")</span>
}

func (e *InfluxDBExecutor) createRequest(query string) (*http.Request, error) <span class="cov0" title="0">{
        u, _ := url.Parse(e.Url)
        u.Path = path.Join(u.Path, "query")

        req, err := http.NewRequest(http.MethodGet, u.String(), nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">params := req.URL.Query()
        params.Set("q", query)
        params.Set("db", e.Database)
        params.Set("epoch", "s")
        req.URL.RawQuery = params.Encode()

        req.Header.Set("User-Agent", "Grafana")

        if e.BasicAuth </span><span class="cov0" title="0">{
                req.SetBasicAuth(e.BasicAuthUser, e.BasicAuthPassword)
        }</span>

        <span class="cov0" title="0">if !e.BasicAuth &amp;&amp; e.User != "" </span><span class="cov0" title="0">{
                req.SetBasicAuth(e.User, e.Password)
        }</span>

        <span class="cov0" title="0">glog.Debug("Influxdb request", "url", req.URL.String())
        return req, nil</span>
}
</pre>
		
		<pre class="file" id="file187" style="display: none">package influxdb

import (
        "strconv"

        "github.com/grafana/grafana/pkg/components/simplejson"
        "github.com/grafana/grafana/pkg/models"
)

type InfluxdbQueryParser struct{}

func (qp *InfluxdbQueryParser) Parse(model *simplejson.Json, dsInfo *models.DataSource) (*Query, error) <span class="cov8" title="1">{
        policy := model.Get("policy").MustString("default")
        rawQuery := model.Get("query").MustString("")
        useRawQuery := model.Get("rawQuery").MustBool(false)
        alias := model.Get("alias").MustString("")

        measurement := model.Get("measurement").MustString("")

        resultFormat, err := model.Get("resultFormat").String()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">tags, err := qp.parseTags(model)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">groupBys, err := qp.parseGroupBy(model)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">selects, err := qp.parseSelects(model)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">interval := model.Get("interval").MustString("")
        if interval == "" &amp;&amp; dsInfo.JsonData != nil </span><span class="cov8" title="1">{
                dsInterval := dsInfo.JsonData.Get("timeInterval").MustString("")
                if dsInterval != "" </span><span class="cov8" title="1">{
                        interval = dsInterval
                }</span>
        }

        <span class="cov8" title="1">return &amp;Query{
                Measurement:  measurement,
                Policy:       policy,
                ResultFormat: resultFormat,
                GroupBy:      groupBys,
                Tags:         tags,
                Selects:      selects,
                RawQuery:     rawQuery,
                Interval:     interval,
                Alias:        alias,
                UseRawQuery:  useRawQuery,
        }, nil</span>
}

func (qp *InfluxdbQueryParser) parseSelects(model *simplejson.Json) ([]*Select, error) <span class="cov8" title="1">{
        var result []*Select

        for _, selectObj := range model.Get("select").MustArray() </span><span class="cov8" title="1">{
                selectJson := simplejson.NewFromAny(selectObj)
                var parts Select

                for _, partObj := range selectJson.MustArray() </span><span class="cov8" title="1">{
                        part := simplejson.NewFromAny(partObj)
                        queryPart, err := qp.parseQueryPart(part)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov8" title="1">parts = append(parts, *queryPart)</span>
                }

                <span class="cov8" title="1">result = append(result, &amp;parts)</span>
        }

        <span class="cov8" title="1">return result, nil</span>
}

func (*InfluxdbQueryParser) parseTags(model *simplejson.Json) ([]*Tag, error) <span class="cov8" title="1">{
        var result []*Tag
        for _, t := range model.Get("tags").MustArray() </span><span class="cov8" title="1">{
                tagJson := simplejson.NewFromAny(t)
                tag := &amp;Tag{}
                var err error

                tag.Key, err = tagJson.Get("key").String()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">tag.Value, err = tagJson.Get("value").String()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">operator, err := tagJson.Get("operator").String()
                if err == nil </span><span class="cov8" title="1">{
                        tag.Operator = operator
                }</span>

                <span class="cov8" title="1">condition, err := tagJson.Get("condition").String()
                if err == nil </span><span class="cov8" title="1">{
                        tag.Condition = condition
                }</span>

                <span class="cov8" title="1">result = append(result, tag)</span>
        }

        <span class="cov8" title="1">return result, nil</span>
}

func (*InfluxdbQueryParser) parseQueryPart(model *simplejson.Json) (*QueryPart, error) <span class="cov8" title="1">{
        typ, err := model.Get("type").String()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var params []string
        for _, paramObj := range model.Get("params").MustArray() </span><span class="cov8" title="1">{
                param := simplejson.NewFromAny(paramObj)

                stringParam, err := param.String()
                if err == nil </span><span class="cov8" title="1">{
                        params = append(params, stringParam)
                        continue</span>
                }

                <span class="cov8" title="1">intParam, err := param.Int()
                if err == nil </span><span class="cov8" title="1">{
                        params = append(params, strconv.Itoa(intParam))
                        continue</span>
                }

                <span class="cov0" title="0">return nil, err</span>

        }

        <span class="cov8" title="1">qp, err := NewQueryPart(typ, params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return qp, nil</span>
}

func (qp *InfluxdbQueryParser) parseGroupBy(model *simplejson.Json) ([]*QueryPart, error) <span class="cov8" title="1">{
        var result []*QueryPart

        for _, groupObj := range model.Get("groupBy").MustArray() </span><span class="cov8" title="1">{
                groupJson := simplejson.NewFromAny(groupObj)
                queryPart, err := qp.parseQueryPart(groupJson)

                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">result = append(result, queryPart)</span>
        }

        <span class="cov8" title="1">return result, nil</span>
}
</pre>
		
		<pre class="file" id="file188" style="display: none">package influxdb

import (
        "fmt"
        "strconv"
        "strings"
        "time"

        "regexp"

        "github.com/grafana/grafana/pkg/tsdb"
)

var (
        regexpOperatorPattern    *regexp.Regexp = regexp.MustCompile(`^\/.*\/$`)
        regexpMeasurementPattern *regexp.Regexp = regexp.MustCompile(`^\/.*\/$`)
)

func (query *Query) Build(queryContext *tsdb.QueryContext) (string, error) <span class="cov8" title="1">{
        var res string

        if query.UseRawQuery &amp;&amp; query.RawQuery != "" </span><span class="cov8" title="1">{
                res = query.RawQuery
        }</span><span class="cov8" title="1"> else {
                res = query.renderSelectors(queryContext)
                res += query.renderMeasurement()
                res += query.renderWhereClause()
                res += query.renderTimeFilter(queryContext)
                res += query.renderGroupBy(queryContext)
        }</span>

        <span class="cov8" title="1">interval, err := getDefinedInterval(query, queryContext)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">res = strings.Replace(res, "$timeFilter", query.renderTimeFilter(queryContext), 1)
        res = strings.Replace(res, "$interval", interval.Text, 1)
        res = strings.Replace(res, "$__interval_ms", strconv.FormatInt(interval.Value.Nanoseconds()/int64(time.Millisecond), 10), 1)
        res = strings.Replace(res, "$__interval", interval.Text, 1)
        return res, nil</span>
}

func getDefinedInterval(query *Query, queryContext *tsdb.QueryContext) (*tsdb.Interval, error) <span class="cov8" title="1">{
        defaultInterval := tsdb.CalculateInterval(queryContext.TimeRange)

        if query.Interval == "" </span><span class="cov8" title="1">{
                return &amp;defaultInterval, nil
        }</span>

        <span class="cov8" title="1">setInterval := strings.Replace(strings.Replace(query.Interval, "&lt;", "", 1), "&gt;", "", 1)
        parsedSetInterval, err := time.ParseDuration(setInterval)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if strings.Contains(query.Interval, "&gt;") </span><span class="cov0" title="0">{
                if defaultInterval.Value &gt; parsedSetInterval </span><span class="cov0" title="0">{
                        return &amp;defaultInterval, nil
                }</span>
        }

        <span class="cov8" title="1">return &amp;tsdb.Interval{Value: parsedSetInterval, Text: setInterval}, nil</span>
}

func (query *Query) renderTags() []string <span class="cov8" title="1">{
        var res []string
        for i, tag := range query.Tags </span><span class="cov8" title="1">{
                str := ""

                if i &gt; 0 </span><span class="cov8" title="1">{
                        if tag.Condition == "" </span><span class="cov0" title="0">{
                                str += "AND"
                        }</span><span class="cov8" title="1"> else {
                                str += tag.Condition
                        }</span>
                        <span class="cov8" title="1">str += " "</span>
                }

                //If the operator is missing we fall back to sensible defaults
                <span class="cov8" title="1">if tag.Operator == "" </span><span class="cov8" title="1">{
                        if regexpOperatorPattern.Match([]byte(tag.Value)) </span><span class="cov8" title="1">{
                                tag.Operator = "=~"
                        }</span><span class="cov8" title="1"> else {
                                tag.Operator = "="
                        }</span>
                }

                <span class="cov8" title="1">textValue := ""

                // quote value unless regex or number
                if tag.Operator == "=~" || tag.Operator == "!~" </span><span class="cov8" title="1">{
                        textValue = tag.Value
                }</span><span class="cov8" title="1"> else if tag.Operator == "&lt;" || tag.Operator == "&gt;" </span><span class="cov8" title="1">{
                        textValue = tag.Value
                }</span><span class="cov8" title="1"> else {
                        textValue = fmt.Sprintf("'%s'", tag.Value)
                }</span>

                <span class="cov8" title="1">res = append(res, fmt.Sprintf(`%s"%s" %s %s`, str, tag.Key, tag.Operator, textValue))</span>
        }

        <span class="cov8" title="1">return res</span>
}

func (query *Query) renderTimeFilter(queryContext *tsdb.QueryContext) string <span class="cov8" title="1">{
        from := "now() - " + queryContext.TimeRange.From
        to := ""

        if queryContext.TimeRange.To != "now" &amp;&amp; queryContext.TimeRange.To != "" </span><span class="cov8" title="1">{
                to = " and time &lt; now() - " + strings.Replace(queryContext.TimeRange.To, "now-", "", 1)
        }</span>

        <span class="cov8" title="1">return fmt.Sprintf("time &gt; %s%s", from, to)</span>
}

func (query *Query) renderSelectors(queryContext *tsdb.QueryContext) string <span class="cov8" title="1">{
        res := "SELECT "

        var selectors []string
        for _, sel := range query.Selects </span><span class="cov8" title="1">{

                stk := ""
                for _, s := range *sel </span><span class="cov8" title="1">{
                        stk = s.Render(query, queryContext, stk)
                }</span>
                <span class="cov8" title="1">selectors = append(selectors, stk)</span>
        }

        <span class="cov8" title="1">return res + strings.Join(selectors, ", ")</span>
}

func (query *Query) renderMeasurement() string <span class="cov8" title="1">{
        policy := ""
        if query.Policy == "" || query.Policy == "default" </span><span class="cov8" title="1">{
                policy = ""
        }</span><span class="cov8" title="1"> else {
                policy = `"` + query.Policy + `".`
        }</span>

        <span class="cov8" title="1">measurement := query.Measurement

        if !regexpMeasurementPattern.Match([]byte(measurement)) </span><span class="cov8" title="1">{
                measurement = fmt.Sprintf(`"%s"`, measurement)
        }</span>

        <span class="cov8" title="1">return fmt.Sprintf(` FROM %s%s`, policy, measurement)</span>
}

func (query *Query) renderWhereClause() string <span class="cov8" title="1">{
        res := " WHERE "
        conditions := query.renderTags()
        res += strings.Join(conditions, " ")
        if len(conditions) &gt; 0 </span><span class="cov8" title="1">{
                res += " AND "
        }</span>

        <span class="cov8" title="1">return res</span>
}

func (query *Query) renderGroupBy(queryContext *tsdb.QueryContext) string <span class="cov8" title="1">{
        groupBy := ""
        for i, group := range query.GroupBy </span><span class="cov8" title="1">{
                if i == 0 </span><span class="cov8" title="1">{
                        groupBy += " GROUP BY"
                }</span>

                <span class="cov8" title="1">if i &gt; 0 &amp;&amp; group.Type != "fill" </span><span class="cov8" title="1">{
                        groupBy += ", " //fill is so very special. fill is a creep, fill is a weirdo
                }</span><span class="cov8" title="1"> else {
                        groupBy += " "
                }</span>

                <span class="cov8" title="1">groupBy += group.Render(query, queryContext, "")</span>
        }

        <span class="cov8" title="1">return groupBy</span>
}
</pre>
		
		<pre class="file" id="file189" style="display: none">package influxdb

import (
        "fmt"
        "strings"

        "github.com/grafana/grafana/pkg/tsdb"
)

var renders map[string]QueryDefinition

type DefinitionParameters struct {
        Name string
        Type string
}

type QueryDefinition struct {
        Renderer func(query *Query, queryContext *tsdb.QueryContext, part *QueryPart, innerExpr string) string
        Params   []DefinitionParameters
}

func init() <span class="cov8" title="1">{
        renders = make(map[string]QueryDefinition)

        renders["field"] = QueryDefinition{Renderer: fieldRenderer}

        renders["spread"] = QueryDefinition{Renderer: functionRenderer}
        renders["count"] = QueryDefinition{Renderer: functionRenderer}
        renders["distinct"] = QueryDefinition{Renderer: functionRenderer}
        renders["integral"] = QueryDefinition{Renderer: functionRenderer}
        renders["mean"] = QueryDefinition{Renderer: functionRenderer}
        renders["median"] = QueryDefinition{Renderer: functionRenderer}
        renders["sum"] = QueryDefinition{Renderer: functionRenderer}

        renders["derivative"] = QueryDefinition{
                Renderer: functionRenderer,
                Params:   []DefinitionParameters{{Name: "duration", Type: "interval"}},
        }

        renders["non_negative_derivative"] = QueryDefinition{
                Renderer: functionRenderer,
                Params:   []DefinitionParameters{{Name: "duration", Type: "interval"}},
        }
        renders["difference"] = QueryDefinition{Renderer: functionRenderer}
        renders["moving_average"] = QueryDefinition{
                Renderer: functionRenderer,
                Params:   []DefinitionParameters{{Name: "window", Type: "number"}},
        }
        renders["stddev"] = QueryDefinition{Renderer: functionRenderer}
        renders["time"] = QueryDefinition{
                Renderer: functionRenderer,
                Params:   []DefinitionParameters{{Name: "interval", Type: "time"}},
        }
        renders["fill"] = QueryDefinition{
                Renderer: functionRenderer,
                Params:   []DefinitionParameters{{Name: "fill", Type: "string"}},
        }
        renders["elapsed"] = QueryDefinition{
                Renderer: functionRenderer,
                Params:   []DefinitionParameters{{Name: "duration", Type: "interval"}},
        }
        renders["bottom"] = QueryDefinition{
                Renderer: functionRenderer,
                Params:   []DefinitionParameters{{Name: "count", Type: "int"}},
        }

        renders["first"] = QueryDefinition{Renderer: functionRenderer}
        renders["last"] = QueryDefinition{Renderer: functionRenderer}
        renders["max"] = QueryDefinition{Renderer: functionRenderer}
        renders["min"] = QueryDefinition{Renderer: functionRenderer}
        renders["percentile"] = QueryDefinition{
                Renderer: functionRenderer,
                Params:   []DefinitionParameters{{Name: "nth", Type: "int"}},
        }
        renders["top"] = QueryDefinition{
                Renderer: functionRenderer,
                Params:   []DefinitionParameters{{Name: "count", Type: "int"}},
        }
        renders["tag"] = QueryDefinition{
                Renderer: fieldRenderer,
                Params:   []DefinitionParameters{{Name: "tag", Type: "string"}},
        }

        renders["math"] = QueryDefinition{Renderer: suffixRenderer}
        renders["alias"] = QueryDefinition{Renderer: aliasRenderer}
}</span>

func fieldRenderer(query *Query, queryContext *tsdb.QueryContext, part *QueryPart, innerExpr string) string <span class="cov8" title="1">{
        if part.Params[0] == "*" </span><span class="cov0" title="0">{
                return "*"
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf(`"%s"`, part.Params[0])</span>
}

func functionRenderer(query *Query, queryContext *tsdb.QueryContext, part *QueryPart, innerExpr string) string <span class="cov8" title="1">{
        for i, param := range part.Params </span><span class="cov8" title="1">{
                if part.Type == "time" &amp;&amp; param == "auto" </span><span class="cov8" title="1">{
                        part.Params[i] = "$__interval"
                }</span>
        }

        <span class="cov8" title="1">if innerExpr != "" </span><span class="cov8" title="1">{
                part.Params = append([]string{innerExpr}, part.Params...)
        }</span>

        <span class="cov8" title="1">params := strings.Join(part.Params, ", ")

        return fmt.Sprintf("%s(%s)", part.Type, params)</span>
}

func suffixRenderer(query *Query, queryContext *tsdb.QueryContext, part *QueryPart, innerExpr string) string <span class="cov8" title="1">{
        return fmt.Sprintf("%s %s", innerExpr, part.Params[0])
}</span>

func aliasRenderer(query *Query, queryContext *tsdb.QueryContext, part *QueryPart, innerExpr string) string <span class="cov8" title="1">{
        return fmt.Sprintf(`%s AS "%s"`, innerExpr, part.Params[0])
}</span>

func (r QueryDefinition) Render(query *Query, queryContext *tsdb.QueryContext, part *QueryPart, innerExpr string) string <span class="cov0" title="0">{
        return r.Renderer(query, queryContext, part, innerExpr)
}</span>

func NewQueryPart(typ string, params []string) (*QueryPart, error) <span class="cov8" title="1">{
        def, exist := renders[typ]

        if !exist </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Missing query definition for %s", typ)
        }</span>

        <span class="cov8" title="1">return &amp;QueryPart{
                Type:   typ,
                Params: params,
                Def:    def,
        }, nil</span>
}

type QueryPart struct {
        Def    QueryDefinition
        Type   string
        Params []string
}

func (qp *QueryPart) Render(query *Query, queryContext *tsdb.QueryContext, expr string) string <span class="cov8" title="1">{
        return qp.Def.Renderer(query, queryContext, qp, expr)
}</span>
</pre>
		
		<pre class="file" id="file190" style="display: none">package influxdb

import (
        "encoding/json"
        "fmt"
        "regexp"
        "strconv"
        "strings"

        "github.com/grafana/grafana/pkg/components/null"
        "github.com/grafana/grafana/pkg/tsdb"
)

type ResponseParser struct{}

var (
        legendFormat *regexp.Regexp
)

func init() <span class="cov8" title="1">{
        legendFormat = regexp.MustCompile(`\[\[(\w+?)*\]\]*|\$\s*(\w+?)*`)
}</span>

func (rp *ResponseParser) Parse(response *Response, query *Query) *tsdb.QueryResult <span class="cov8" title="1">{
        queryRes := tsdb.NewQueryResult()

        for _, result := range response.Results </span><span class="cov8" title="1">{
                queryRes.Series = append(queryRes.Series, rp.transformRows(result.Series, queryRes, query)...)
        }</span>

        <span class="cov8" title="1">return queryRes</span>
}

func (rp *ResponseParser) transformRows(rows []Row, queryResult *tsdb.QueryResult, query *Query) tsdb.TimeSeriesSlice <span class="cov8" title="1">{
        var result tsdb.TimeSeriesSlice

        for _, row := range rows </span><span class="cov8" title="1">{
                for columnIndex, column := range row.Columns </span><span class="cov8" title="1">{
                        if column == "time" </span><span class="cov8" title="1">{
                                continue</span>
                        }

                        <span class="cov8" title="1">var points tsdb.TimeSeriesPoints
                        for _, valuePair := range row.Values </span><span class="cov8" title="1">{
                                point, err := rp.parseTimepoint(valuePair, columnIndex)
                                if err == nil </span><span class="cov8" title="1">{
                                        points = append(points, point)
                                }</span>
                        }
                        <span class="cov8" title="1">result = append(result, &amp;tsdb.TimeSeries{
                                Name:   rp.formatSerieName(row, column, query),
                                Points: points,
                        })</span>
                }
        }

        <span class="cov8" title="1">return result</span>
}

func (rp *ResponseParser) formatSerieName(row Row, column string, query *Query) string <span class="cov8" title="1">{
        if query.Alias == "" </span><span class="cov8" title="1">{
                return rp.buildSerieNameFromQuery(row, column)
        }</span>

        <span class="cov8" title="1">nameSegment := strings.Split(row.Name, ".")

        result := legendFormat.ReplaceAllFunc([]byte(query.Alias), func(in []byte) []byte </span><span class="cov8" title="1">{
                aliasFormat := string(in)
                aliasFormat = strings.Replace(aliasFormat, "[[", "", 1)
                aliasFormat = strings.Replace(aliasFormat, "]]", "", 1)
                aliasFormat = strings.Replace(aliasFormat, "$", "", 1)

                if aliasFormat == "m" || aliasFormat == "measurement" </span><span class="cov8" title="1">{
                        return []byte(query.Measurement)
                }</span>
                <span class="cov8" title="1">if aliasFormat == "col" </span><span class="cov8" title="1">{
                        return []byte(column)
                }</span>

                <span class="cov8" title="1">pos, err := strconv.Atoi(aliasFormat)
                if err == nil &amp;&amp; len(nameSegment) &gt;= pos </span><span class="cov8" title="1">{
                        return []byte(nameSegment[pos])
                }</span>

                <span class="cov8" title="1">if !strings.HasPrefix(aliasFormat, "tag_") </span><span class="cov8" title="1">{
                        return in
                }</span>

                <span class="cov8" title="1">tagKey := strings.Replace(aliasFormat, "tag_", "", 1)
                tagValue, exist := row.Tags[tagKey]
                if exist </span><span class="cov8" title="1">{
                        return []byte(tagValue)
                }</span>

                <span class="cov0" title="0">return in</span>
        })

        <span class="cov8" title="1">return string(result)</span>
}

func (rp *ResponseParser) buildSerieNameFromQuery(row Row, column string) string <span class="cov8" title="1">{
        var tags []string

        for k, v := range row.Tags </span><span class="cov8" title="1">{
                tags = append(tags, fmt.Sprintf("%s: %s", k, v))
        }</span>

        <span class="cov8" title="1">tagText := ""
        if len(tags) &gt; 0 </span><span class="cov8" title="1">{
                tagText = fmt.Sprintf(" { %s }", strings.Join(tags, " "))
        }</span>

        <span class="cov8" title="1">return fmt.Sprintf("%s.%s%s", row.Name, column, tagText)</span>
}

func (rp *ResponseParser) parseTimepoint(valuePair []interface{}, valuePosition int) (tsdb.TimePoint, error) <span class="cov8" title="1">{
        var value null.Float = rp.parseValue(valuePair[valuePosition])

        timestampNumber, _ := valuePair[0].(json.Number)
        timestamp, err := timestampNumber.Float64()
        if err != nil </span><span class="cov0" title="0">{
                return tsdb.TimePoint{}, err
        }</span>

        <span class="cov8" title="1">return tsdb.NewTimePoint(value, timestamp), nil</span>
}

func (rp *ResponseParser) parseValue(value interface{}) null.Float <span class="cov8" title="1">{
        number, ok := value.(json.Number)
        if !ok </span><span class="cov0" title="0">{
                return null.FloatFromPtr(nil)
        }</span>

        <span class="cov8" title="1">fvalue, err := number.Float64()
        if err == nil </span><span class="cov8" title="1">{
                return null.FloatFrom(fvalue)
        }</span>

        <span class="cov8" title="1">ivalue, err := number.Int64()
        if err == nil </span><span class="cov0" title="0">{
                return null.FloatFrom(float64(ivalue))
        }</span>

        <span class="cov8" title="1">return null.FloatFromPtr(nil)</span>
}
</pre>
		
		<pre class="file" id="file191" style="display: none">package tsdb

import (
        "fmt"
        "time"
)

var (
        defaultRes  int64         = 1500
        minInterval time.Duration = 1 * time.Millisecond
        year        time.Duration = time.Hour * 24 * 365
        day         time.Duration = time.Hour * 24 * 365
)

type Interval struct {
        Text  string
        Value time.Duration
}

func CalculateInterval(timerange *TimeRange) Interval <span class="cov8" title="1">{
        interval := time.Duration((timerange.MustGetTo().UnixNano() - timerange.MustGetFrom().UnixNano()) / defaultRes)

        if interval &lt; minInterval </span><span class="cov0" title="0">{
                return Interval{Text: formatDuration(minInterval), Value: interval}
        }</span>

        <span class="cov8" title="1">return Interval{Text: formatDuration(roundInterval(interval)), Value: interval}</span>
}

func formatDuration(inter time.Duration) string <span class="cov8" title="1">{
        if inter &gt;= year </span><span class="cov8" title="1">{
                return fmt.Sprintf("%dy", inter/year)
        }</span>

        <span class="cov8" title="1">if inter &gt;= day </span><span class="cov0" title="0">{
                return fmt.Sprintf("%dd", inter/day)
        }</span>

        <span class="cov8" title="1">if inter &gt;= time.Hour </span><span class="cov8" title="1">{
                return fmt.Sprintf("%dh", inter/time.Hour)
        }</span>

        <span class="cov8" title="1">if inter &gt;= time.Minute </span><span class="cov8" title="1">{
                return fmt.Sprintf("%dm", inter/time.Minute)
        }</span>

        <span class="cov8" title="1">if inter &gt;= time.Second </span><span class="cov8" title="1">{
                return fmt.Sprintf("%ds", inter/time.Second)
        }</span>

        <span class="cov8" title="1">if inter &gt;= time.Millisecond </span><span class="cov8" title="1">{
                return fmt.Sprintf("%dms", inter/time.Millisecond)
        }</span>

        <span class="cov0" title="0">return "1ms"</span>
}

func roundInterval(interval time.Duration) time.Duration <span class="cov8" title="1">{
        switch true </span>{
        // 0.015s
        case interval &lt;= 15*time.Millisecond:<span class="cov0" title="0">
                return time.Millisecond * 10</span> // 0.01s
        // 0.035s
        case interval &lt;= 35*time.Millisecond:<span class="cov8" title="1">
                return time.Millisecond * 20</span> // 0.02s
        // 0.075s
        case interval &lt;= 75*time.Millisecond:<span class="cov8" title="1">
                return time.Millisecond * 50</span> // 0.05s
        // 0.15s
        case interval &lt;= 150*time.Millisecond:<span class="cov0" title="0">
                return time.Millisecond * 100</span> // 0.1s
        // 0.35s
        case interval &lt;= 350*time.Millisecond:<span class="cov8" title="1">
                return time.Millisecond * 200</span> // 0.2s
        // 0.75s
        case interval &lt;= 750*time.Millisecond:<span class="cov8" title="1">
                return time.Millisecond * 500</span> // 0.5s
        // 1.5s
        case interval &lt;= 1500*time.Millisecond:<span class="cov8" title="1">
                return time.Millisecond * 1000</span> // 1s
        // 3.5s
        case interval &lt;= 3500*time.Millisecond:<span class="cov8" title="1">
                return time.Millisecond * 2000</span> // 2s
        // 7.5s
        case interval &lt;= 7500*time.Millisecond:<span class="cov0" title="0">
                return time.Millisecond * 5000</span> // 5s
        // 12.5s
        case interval &lt;= 12500*time.Millisecond:<span class="cov0" title="0">
                return time.Millisecond * 10000</span> // 10s
        // 17.5s
        case interval &lt;= 17500*time.Millisecond:<span class="cov0" title="0">
                return time.Millisecond * 15000</span> // 15s
        // 25s
        case interval &lt;= 25000*time.Millisecond:<span class="cov0" title="0">
                return time.Millisecond * 20000</span> // 20s
        // 45s
        case interval &lt;= 45000*time.Millisecond:<span class="cov0" title="0">
                return time.Millisecond * 30000</span> // 30s
        // 1.5m
        case interval &lt;= 90000*time.Millisecond:<span class="cov0" title="0">
                return time.Millisecond * 60000</span> // 1m
        // 3.5m
        case interval &lt;= 210000*time.Millisecond:<span class="cov0" title="0">
                return time.Millisecond * 120000</span> // 2m
        // 7.5m
        case interval &lt;= 450000*time.Millisecond:<span class="cov0" title="0">
                return time.Millisecond * 300000</span> // 5m
        // 12.5m
        case interval &lt;= 750000*time.Millisecond:<span class="cov0" title="0">
                return time.Millisecond * 600000</span> // 10m
        // 12.5m
        case interval &lt;= 1050000*time.Millisecond:<span class="cov0" title="0">
                return time.Millisecond * 900000</span> // 15m
        // 25m
        case interval &lt;= 1500000*time.Millisecond:<span class="cov0" title="0">
                return time.Millisecond * 1200000</span> // 20m
        // 45m
        case interval &lt;= 2700000*time.Millisecond:<span class="cov0" title="0">
                return time.Millisecond * 1800000</span> // 30m
        // 1.5h
        case interval &lt;= 5400000*time.Millisecond:<span class="cov0" title="0">
                return time.Millisecond * 3600000</span> // 1h
        // 2.5h
        case interval &lt;= 9000000*time.Millisecond:<span class="cov0" title="0">
                return time.Millisecond * 7200000</span> // 2h
        // 4.5h
        case interval &lt;= 16200000*time.Millisecond:<span class="cov0" title="0">
                return time.Millisecond * 10800000</span> // 3h
        // 9h
        case interval &lt;= 32400000*time.Millisecond:<span class="cov0" title="0">
                return time.Millisecond * 21600000</span> // 6h
        // 24h
        case interval &lt;= 86400000*time.Millisecond:<span class="cov0" title="0">
                return time.Millisecond * 43200000</span> // 12h
        // 48h
        case interval &lt;= 172800000*time.Millisecond:<span class="cov0" title="0">
                return time.Millisecond * 86400000</span> // 24h
        // 1w
        case interval &lt;= 604800000*time.Millisecond:<span class="cov0" title="0">
                return time.Millisecond * 86400000</span> // 24h
        // 3w
        case interval &lt;= 1814400000*time.Millisecond:<span class="cov0" title="0">
                return time.Millisecond * 604800000</span> // 1w
        // 2y
        case interval &lt; 3628800000*time.Millisecond:<span class="cov0" title="0">
                return time.Millisecond * 2592000000</span> // 30d
        default:<span class="cov0" title="0">
                return time.Millisecond * 31536000000</span> // 1y
        }
}
</pre>
		
		<pre class="file" id="file192" style="display: none">package tsdb

import (
        "github.com/grafana/grafana/pkg/components/null"
        "github.com/grafana/grafana/pkg/components/simplejson"
        "github.com/grafana/grafana/pkg/models"
)

type Query struct {
        RefId         string
        Model         *simplejson.Json
        Depends       []string
        DataSource    *models.DataSource
        Results       []*TimeSeries
        Exclude       bool
        MaxDataPoints int64
        IntervalMs    int64
}

type QuerySlice []*Query

type Request struct {
        TimeRange *TimeRange
        Queries   QuerySlice
}

type Response struct {
        BatchTimings []*BatchTiming          `json:"timings"`
        Results      map[string]*QueryResult `json:"results"`
}

type BatchTiming struct {
        TimeElapsed int64
}

type BatchResult struct {
        Error        error
        QueryResults map[string]*QueryResult
        Timings      *BatchTiming
}

func (br *BatchResult) WithError(err error) *BatchResult <span class="cov0" title="0">{
        br.Error = err
        return br
}</span>

type QueryResult struct {
        Error  error           `json:"error"`
        RefId  string          `json:"refId"`
        Series TimeSeriesSlice `json:"series"`
}

type TimeSeries struct {
        Name   string            `json:"name"`
        Points TimeSeriesPoints  `json:"points"`
        Tags   map[string]string `json:"tags"`
}

type TimePoint [2]null.Float
type TimeSeriesPoints []TimePoint
type TimeSeriesSlice []*TimeSeries

func NewQueryResult() *QueryResult <span class="cov0" title="0">{
        return &amp;QueryResult{
                Series: make(TimeSeriesSlice, 0),
        }
}</span>

func NewTimePoint(value null.Float, timestamp float64) TimePoint <span class="cov0" title="0">{
        return TimePoint{value, null.FloatFrom(timestamp)}
}</span>

func NewTimeSeriesPointsFromArgs(values ...float64) TimeSeriesPoints <span class="cov0" title="0">{
        points := make(TimeSeriesPoints, 0)

        for i := 0; i &lt; len(values); i += 2 </span><span class="cov0" title="0">{
                points = append(points, NewTimePoint(null.FloatFrom(values[i]), values[i+1]))
        }</span>

        <span class="cov0" title="0">return points</span>
}

func NewTimeSeries(name string, points TimeSeriesPoints) *TimeSeries <span class="cov0" title="0">{
        return &amp;TimeSeries{
                Name:   name,
                Points: points,
        }
}</span>
</pre>
		
		<pre class="file" id="file193" style="display: none">package mqe

import (
        "context"
        "net/http"
        "net/url"
        "path"
        "strings"

        "github.com/grafana/grafana/pkg/components/simplejson"
        "github.com/grafana/grafana/pkg/log"
        "github.com/grafana/grafana/pkg/models"
        "github.com/grafana/grafana/pkg/setting"
        "github.com/grafana/grafana/pkg/tsdb"

        "golang.org/x/net/context/ctxhttp"
)

var (
        MaxWorker int = 4
)

type apiClient struct {
        *models.DataSource
        log            log.Logger
        httpClient     *http.Client
        responseParser *ResponseParser
}

func NewApiClient(httpClient *http.Client, datasource *models.DataSource) *apiClient <span class="cov0" title="0">{
        return &amp;apiClient{
                DataSource:     datasource,
                log:            log.New("tsdb.mqe"),
                httpClient:     httpClient,
                responseParser: NewResponseParser(),
        }
}</span>

func (e *apiClient) PerformRequests(ctx context.Context, queries []QueryToSend) (*tsdb.QueryResult, error) <span class="cov0" title="0">{
        queryResult := &amp;tsdb.QueryResult{}

        queryCount := len(queries)
        jobsChan := make(chan QueryToSend, queryCount)
        resultChan := make(chan []*tsdb.TimeSeries, queryCount)
        errorsChan := make(chan error, 1)
        for w := 1; w &lt;= MaxWorker; w++ </span><span class="cov0" title="0">{
                go e.spawnWorker(ctx, w, jobsChan, resultChan, errorsChan)
        }</span>

        <span class="cov0" title="0">for _, v := range queries </span><span class="cov0" title="0">{
                jobsChan &lt;- v
        }</span>
        <span class="cov0" title="0">close(jobsChan)

        resultCounter := 0
        for </span><span class="cov0" title="0">{
                select </span>{
                case timeseries := &lt;-resultChan:<span class="cov0" title="0">
                        queryResult.Series = append(queryResult.Series, timeseries...)
                        resultCounter++

                        if resultCounter == queryCount </span><span class="cov0" title="0">{
                                close(resultChan)
                                return queryResult, nil
                        }</span>
                case err := &lt;-errorsChan:<span class="cov0" title="0">
                        return nil, err</span>
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return nil, ctx.Err()</span>
                }
        }
}

func (e *apiClient) spawnWorker(ctx context.Context, id int, jobs chan QueryToSend, results chan []*tsdb.TimeSeries, errors chan error) <span class="cov0" title="0">{
        e.log.Debug("Spawning worker", "id", id)
        for query := range jobs </span><span class="cov0" title="0">{
                if setting.Env == setting.DEV </span><span class="cov0" title="0">{
                        e.log.Debug("Sending request", "query", query.RawQuery)
                }</span>

                <span class="cov0" title="0">req, err := e.createRequest(query.RawQuery)

                resp, err := ctxhttp.Do(ctx, e.httpClient, req)
                if err != nil </span><span class="cov0" title="0">{
                        errors &lt;- err
                        return
                }</span>

                <span class="cov0" title="0">series, err := e.responseParser.Parse(resp, query)
                if err != nil </span><span class="cov0" title="0">{
                        errors &lt;- err
                        return
                }</span>

                <span class="cov0" title="0">results &lt;- series</span>
        }
        <span class="cov0" title="0">e.log.Debug("Worker is complete", "id", id)</span>
}

func (e *apiClient) createRequest(query string) (*http.Request, error) <span class="cov0" title="0">{
        u, err := url.Parse(e.Url)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">u.Path = path.Join(u.Path, "query")

        payload := simplejson.New()
        payload.Set("query", query)

        jsonPayload, err := payload.MarshalJSON()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequest(http.MethodPost, u.String(), strings.NewReader(string(jsonPayload)))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">req.Header.Set("User-Agent", "Grafana")
        req.Header.Set("Content-Type", "application/json")

        if e.BasicAuth </span><span class="cov0" title="0">{
                req.SetBasicAuth(e.BasicAuthUser, e.BasicAuthPassword)
        }</span>

        <span class="cov0" title="0">return req, nil</span>
}
</pre>
		
		<pre class="file" id="file194" style="display: none">package mqe

import (
        "github.com/grafana/grafana/pkg/components/simplejson"
        "github.com/grafana/grafana/pkg/models"
        "github.com/grafana/grafana/pkg/tsdb"
)

func NewQueryParser() *QueryParser <span class="cov0" title="0">{
        return &amp;QueryParser{}
}</span>

type QueryParser struct{}

func (qp *QueryParser) Parse(model *simplejson.Json, dsInfo *models.DataSource, queryContext *tsdb.QueryContext) (*Query, error) <span class="cov8" title="1">{
        query := &amp;Query{TimeRange: queryContext.TimeRange}
        query.AddClusterToAlias = model.Get("addClusterToAlias").MustBool(false)
        query.AddHostToAlias = model.Get("addHostToAlias").MustBool(false)
        query.UseRawQuery = model.Get("rawQuery").MustBool(false)
        query.RawQuery = model.Get("query").MustString("")

        query.Cluster = model.Get("cluster").MustStringArray([]string{})
        query.Hosts = model.Get("hosts").MustStringArray([]string{})

        var metrics []Metric
        var err error
        for _, metricsObj := range model.Get("metrics").MustArray() </span><span class="cov8" title="1">{
                metricJson := simplejson.NewFromAny(metricsObj)
                var m Metric

                m.Alias = metricJson.Get("alias").MustString("")
                m.Metric, err = metricJson.Get("metric").String()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">metrics = append(metrics, m)</span>
        }

        <span class="cov8" title="1">query.Metrics = metrics

        var functions []Function
        for _, functionListObj := range model.Get("functionList").MustArray() </span><span class="cov8" title="1">{
                functionListJson := simplejson.NewFromAny(functionListObj)
                var f Function

                f.Func = functionListJson.Get("func").MustString("")
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">if f.Func != "" </span><span class="cov8" title="1">{
                        functions = append(functions, f)
                }</span>
        }

        <span class="cov8" title="1">query.FunctionList = functions

        return query, nil</span>
}
</pre>
		
		<pre class="file" id="file195" style="display: none">package mqe

import (
        "context"
        "net/http"

        "github.com/grafana/grafana/pkg/log"
        "github.com/grafana/grafana/pkg/models"
        "github.com/grafana/grafana/pkg/tsdb"
)

type MQEExecutor struct {
        *models.DataSource
        queryParser *QueryParser
        apiClient   *apiClient
        httpClient  *http.Client
        log         log.Logger
        tokenClient *TokenClient
}

func NewMQEExecutor(dsInfo *models.DataSource) (tsdb.Executor, error) <span class="cov0" title="0">{
        httpclient, err := dsInfo.GetHttpClient()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;MQEExecutor{
                DataSource:  dsInfo,
                httpClient:  httpclient,
                log:         log.New("tsdb.mqe"),
                queryParser: NewQueryParser(),
                apiClient:   NewApiClient(httpclient, dsInfo),
                tokenClient: NewTokenClient(dsInfo),
        }, nil</span>
}

func init() <span class="cov8" title="1">{
        tsdb.RegisterExecutor("mqe-datasource", NewMQEExecutor)
}</span>

type QueryToSend struct {
        RawQuery string
        Metric   Metric
        QueryRef *Query
}

func (e *MQEExecutor) Execute(ctx context.Context, queries tsdb.QuerySlice, queryContext *tsdb.QueryContext) *tsdb.BatchResult <span class="cov0" title="0">{
        result := &amp;tsdb.BatchResult{}

        availableSeries, err := e.tokenClient.GetTokenData(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return result.WithError(err)
        }</span>

        <span class="cov0" title="0">var mqeQueries []*Query
        for _, v := range queries </span><span class="cov0" title="0">{
                q, err := e.queryParser.Parse(v.Model, e.DataSource, queryContext)
                if err != nil </span><span class="cov0" title="0">{
                        return result.WithError(err)
                }</span>
                <span class="cov0" title="0">mqeQueries = append(mqeQueries, q)</span>
        }

        <span class="cov0" title="0">var rawQueries []QueryToSend
        for _, v := range mqeQueries </span><span class="cov0" title="0">{
                queries, err := v.Build(availableSeries.Metrics)
                if err != nil </span><span class="cov0" title="0">{
                        return result.WithError(err)
                }</span>

                <span class="cov0" title="0">rawQueries = append(rawQueries, queries...)</span>
        }

        <span class="cov0" title="0">e.log.Debug("Sending request", "url", e.DataSource.Url)

        queryResult, err := e.apiClient.PerformRequests(ctx, rawQueries)
        if err != nil </span><span class="cov0" title="0">{
                return result.WithError(err)
        }</span>

        <span class="cov0" title="0">result.QueryResults = make(map[string]*tsdb.QueryResult)
        result.QueryResults["A"] = queryResult

        return result</span>
}
</pre>
		
		<pre class="file" id="file196" style="display: none">package mqe

import (
        "encoding/json"
        "io/ioutil"
        "net/http"
        "strconv"
        "strings"

        "fmt"

        "regexp"

        "github.com/grafana/grafana/pkg/components/null"
        "github.com/grafana/grafana/pkg/log"
        "github.com/grafana/grafana/pkg/tsdb"
)

func NewResponseParser() *ResponseParser <span class="cov8" title="1">{
        return &amp;ResponseParser{
                log: log.New("tsdb.mqe"),
        }
}</span>

var (
        indexAliasPattern    *regexp.Regexp
        wildcardAliasPattern *regexp.Regexp
)

func init() <span class="cov8" title="1">{
        indexAliasPattern = regexp.MustCompile(`\$(\d)`)
        wildcardAliasPattern = regexp.MustCompile(`[*!]`)
}</span>

type MQEResponse struct {
        Success bool               `json:"success"`
        Name    string             `json:"name"`
        Body    []MQEResponseSerie `json:"body"`
}

type ResponseTimeRange struct {
        Start      int64 `json:"start"`
        End        int64 `json:"end"`
        Resolution int64 `json:"Resolution"`
}

type MQEResponseSerie struct {
        Query     string            `json:"query"`
        Name      string            `json:"name"`
        Type      string            `json:"type"`
        Series    []MQESerie        `json:"series"`
        TimeRange ResponseTimeRange `json:"timerange"`
}

type MQESerie struct {
        Values []null.Float      `json:"values"`
        Tagset map[string]string `json:"tagset"`
}

type ResponseParser struct {
        log log.Logger
}

func (parser *ResponseParser) Parse(res *http.Response, queryRef QueryToSend) ([]*tsdb.TimeSeries, error) <span class="cov8" title="1">{
        body, err := ioutil.ReadAll(res.Body)
        defer res.Body.Close()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if res.StatusCode/100 != 2 </span><span class="cov0" title="0">{
                parser.log.Error("Request failed", "status code", res.StatusCode, "body", string(body))
                return nil, fmt.Errorf("Returned invalid statuscode")
        }</span>

        <span class="cov8" title="1">var data *MQEResponse = &amp;MQEResponse{}
        err = json.Unmarshal(body, data)
        if err != nil </span><span class="cov0" title="0">{
                parser.log.Info("Failed to unmarshal response", "error", err, "status", res.Status, "body", string(body))
                return nil, err
        }</span>

        <span class="cov8" title="1">if !data.Success </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Request failed.")
        }</span>

        <span class="cov8" title="1">var series []*tsdb.TimeSeries
        for _, body := range data.Body </span><span class="cov8" title="1">{
                for _, mqeSerie := range body.Series </span><span class="cov8" title="1">{
                        serie := &amp;tsdb.TimeSeries{
                                Tags: map[string]string{},
                                Name: parser.formatLegend(body, mqeSerie, queryRef),
                        }
                        for key, value := range mqeSerie.Tagset </span><span class="cov8" title="1">{
                                serie.Tags[key] = value
                        }</span>

                        <span class="cov8" title="1">for i, value := range mqeSerie.Values </span><span class="cov8" title="1">{
                                timestamp := body.TimeRange.Start + int64(i)*body.TimeRange.Resolution
                                serie.Points = append(serie.Points, tsdb.NewTimePoint(value, float64(timestamp)))
                        }</span>

                        <span class="cov8" title="1">series = append(series, serie)</span>
                }
        }

        <span class="cov8" title="1">return series, nil</span>
}

func (parser *ResponseParser) formatLegend(body MQEResponseSerie, mqeSerie MQESerie, queryToSend QueryToSend) string <span class="cov8" title="1">{
        namePrefix := ""

        //append predefined tags to seriename
        for key, value := range mqeSerie.Tagset </span><span class="cov8" title="1">{
                if key == "cluster" &amp;&amp; queryToSend.QueryRef.AddClusterToAlias </span><span class="cov8" title="1">{
                        namePrefix += value + " "
                }</span>
        }
        <span class="cov8" title="1">for key, value := range mqeSerie.Tagset </span><span class="cov8" title="1">{
                if key == "host" &amp;&amp; queryToSend.QueryRef.AddHostToAlias </span><span class="cov8" title="1">{
                        namePrefix += value + " "
                }</span>
        }

        <span class="cov8" title="1">return namePrefix + parser.formatName(body, queryToSend)</span>
}

func (parser *ResponseParser) formatName(body MQEResponseSerie, queryToSend QueryToSend) string <span class="cov8" title="1">{
        if indexAliasPattern.MatchString(queryToSend.Metric.Alias) </span><span class="cov8" title="1">{
                return parser.indexAlias(body, queryToSend)
        }</span>

        <span class="cov8" title="1">if wildcardAliasPattern.MatchString(queryToSend.Metric.Metric) &amp;&amp; wildcardAliasPattern.MatchString(queryToSend.Metric.Alias) </span><span class="cov8" title="1">{
                return parser.wildcardAlias(body, queryToSend)
        }</span>

        <span class="cov8" title="1">return body.Name</span>
}

func (parser *ResponseParser) wildcardAlias(body MQEResponseSerie, queryToSend QueryToSend) string <span class="cov8" title="1">{
        regString := strings.Replace(queryToSend.Metric.Metric, `*`, `(.*)`, 1)
        reg, err := regexp.Compile(regString)
        if err != nil </span><span class="cov0" title="0">{
                return queryToSend.Metric.Alias
        }</span>

        <span class="cov8" title="1">matches := reg.FindAllStringSubmatch(queryToSend.RawQuery, -1)

        if len(matches) == 0 || len(matches[0]) &lt; 2 </span><span class="cov0" title="0">{
                return queryToSend.Metric.Alias
        }</span>

        <span class="cov8" title="1">return matches[0][1]</span>
}

func (parser *ResponseParser) indexAlias(body MQEResponseSerie, queryToSend QueryToSend) string <span class="cov8" title="1">{
        queryNameParts := strings.Split(queryToSend.Metric.Metric, `.`)

        name := indexAliasPattern.ReplaceAllStringFunc(queryToSend.Metric.Alias, func(in string) string </span><span class="cov8" title="1">{
                positionName := strings.TrimSpace(strings.Replace(in, "$", "", 1))

                pos, err := strconv.Atoi(positionName)
                if err != nil </span><span class="cov0" title="0">{
                        return ""
                }</span>

                <span class="cov8" title="1">for i, part := range queryNameParts </span><span class="cov8" title="1">{
                        if i == pos-1 </span><span class="cov8" title="1">{
                                return strings.TrimSpace(part)
                        }</span>
                }

                <span class="cov0" title="0">return ""</span>
        })

        <span class="cov8" title="1">return strings.Replace(name, " ", ".", -1)</span>
}
</pre>
		
		<pre class="file" id="file197" style="display: none">package mqe

import (
        "context"
        "encoding/json"
        "fmt"
        "io/ioutil"
        "net/http"
        "net/url"
        "path"
        "time"

        "golang.org/x/net/context/ctxhttp"

        "strconv"

        "github.com/grafana/grafana/pkg/log"
        "github.com/grafana/grafana/pkg/models"
        "github.com/patrickmn/go-cache"
)

var tokenCache *cache.Cache

func init() <span class="cov8" title="1">{
        tokenCache = cache.New(5*time.Minute, 30*time.Second)
}</span>

type TokenClient struct {
        log        log.Logger
        Datasource *models.DataSource
        HttpClient *http.Client
}

func NewTokenClient(datasource *models.DataSource) *TokenClient <span class="cov0" title="0">{
        httpClient, _ := datasource.GetHttpClient()

        return &amp;TokenClient{
                log:        log.New("tsdb.mqe.tokenclient"),
                Datasource: datasource,
                HttpClient: httpClient,
        }
}</span>

func (client *TokenClient) GetTokenData(ctx context.Context) (*TokenBody, error) <span class="cov0" title="0">{
        key := strconv.FormatInt(client.Datasource.Id, 10)

        item, found := tokenCache.Get(key)
        if found </span><span class="cov0" title="0">{
                if result, ok := item.(*TokenBody); ok </span><span class="cov0" title="0">{
                        return result, nil
                }</span>
        }

        <span class="cov0" title="0">b, err := client.RequestTokenData(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">tokenCache.Set(key, b, cache.DefaultExpiration)

        return b, nil</span>
}

func (client *TokenClient) RequestTokenData(ctx context.Context) (*TokenBody, error) <span class="cov0" title="0">{
        u, _ := url.Parse(client.Datasource.Url)
        u.Path = path.Join(u.Path, "token")

        req, err := http.NewRequest(http.MethodGet, u.String(), nil)
        if err != nil </span><span class="cov0" title="0">{
                client.log.Info("Failed to create request", "error", err)
        }</span>

        <span class="cov0" title="0">res, err := ctxhttp.Do(ctx, client.HttpClient, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">body, err := ioutil.ReadAll(res.Body)
        defer res.Body.Close()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if res.StatusCode/100 != 2 </span><span class="cov0" title="0">{
                client.log.Info("Request failed", "status", res.Status, "body", string(body))
                return nil, fmt.Errorf("Request failed status: %v", res.Status)
        }</span>

        <span class="cov0" title="0">var result *TokenResponse
        err = json.Unmarshal(body, &amp;result)
        if err != nil </span><span class="cov0" title="0">{
                client.log.Info("Failed to unmarshal response", "error", err, "status", res.Status, "body", string(body))
                return nil, err
        }</span>

        <span class="cov0" title="0">if !result.Success </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Request failed for unknown reason.")
        }</span>

        <span class="cov0" title="0">return &amp;result.Body, nil</span>
}
</pre>
		
		<pre class="file" id="file198" style="display: none">package mqe

import (
        "fmt"

        "strings"

        "regexp"

        "github.com/grafana/grafana/pkg/log"
        "github.com/grafana/grafana/pkg/tsdb"
)

type Metric struct {
        Metric string
        Alias  string
}

type Function struct {
        Func string
}

type Query struct {
        Metrics           []Metric
        Hosts             []string
        Cluster           []string
        FunctionList      []Function
        AddClusterToAlias bool
        AddHostToAlias    bool

        TimeRange   *tsdb.TimeRange
        UseRawQuery bool
        RawQuery    string
}

var (
        containsWildcardPattern *regexp.Regexp = regexp.MustCompile(`\*`)
)

func (q *Query) Build(availableSeries []string) ([]QueryToSend, error) <span class="cov8" title="1">{
        var queriesToSend []QueryToSend
        where := q.buildWhereClause()
        functions := q.buildFunctionList()

        for _, metric := range q.Metrics </span><span class="cov8" title="1">{
                alias := ""
                if metric.Alias != "" </span><span class="cov8" title="1">{
                        alias = fmt.Sprintf(" {%s}", metric.Alias)
                }</span>

                <span class="cov8" title="1">if !containsWildcardPattern.Match([]byte(metric.Metric)) </span><span class="cov8" title="1">{
                        rawQuery := q.renderQuerystring(metric.Metric, functions, alias, where, q.TimeRange)
                        queriesToSend = append(queriesToSend, QueryToSend{
                                RawQuery: rawQuery,
                                QueryRef: q,
                                Metric:   metric,
                        })
                }</span><span class="cov8" title="1"> else {
                        m := strings.Replace(metric.Metric, "*", ".*", -1)
                        mp, err := regexp.Compile(m)

                        if err != nil </span><span class="cov0" title="0">{
                                log.Error2("failed to compile regex for ", "metric", m)
                                continue</span>
                        }

                        //TODO: this lookup should be cached
                        <span class="cov8" title="1">for _, wildcardMatch := range availableSeries </span><span class="cov8" title="1">{
                                if mp.Match([]byte(wildcardMatch)) </span><span class="cov8" title="1">{
                                        rawQuery := q.renderQuerystring(wildcardMatch, functions, alias, where, q.TimeRange)
                                        queriesToSend = append(queriesToSend, QueryToSend{
                                                RawQuery: rawQuery,
                                                QueryRef: q,
                                                Metric:   metric,
                                        })
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">return queriesToSend, nil</span>
}

func (q *Query) renderQuerystring(path, functions, alias, where string, timerange *tsdb.TimeRange) string <span class="cov8" title="1">{
        return fmt.Sprintf(
                "`%s`%s%s %s from %v to %v",
                path,
                functions,
                alias,
                where,
                q.TimeRange.GetFromAsMsEpoch(),
                q.TimeRange.GetToAsMsEpoch())
}</span>

func (q *Query) buildFunctionList() string <span class="cov8" title="1">{
        functions := ""
        for _, v := range q.FunctionList </span><span class="cov8" title="1">{
                functions = fmt.Sprintf("%s|%s", functions, v.Func)
        }</span>

        <span class="cov8" title="1">return functions</span>
}

func (q *Query) buildWhereClause() string <span class="cov8" title="1">{
        hasApps := len(q.Cluster) &gt; 0
        hasHosts := len(q.Hosts) &gt; 0

        where := ""
        if hasHosts || hasApps </span><span class="cov8" title="1">{
                where += "where "
        }</span>

        <span class="cov8" title="1">if hasApps </span><span class="cov8" title="1">{
                apps := strings.Join(q.Cluster, "', '")
                where += fmt.Sprintf("cluster in ('%s')", apps)
        }</span>

        <span class="cov8" title="1">if hasHosts &amp;&amp; hasApps </span><span class="cov8" title="1">{
                where += " and "
        }</span>

        <span class="cov8" title="1">if hasHosts </span><span class="cov8" title="1">{
                hosts := strings.Join(q.Hosts, "', '")
                where += fmt.Sprintf("host in ('%s')", hosts)
        }</span>

        <span class="cov8" title="1">return where</span>
}

type TokenBody struct {
        Metrics []string
}

type TokenResponse struct {
        Success bool
        Body    TokenBody
}
</pre>
		
		<pre class="file" id="file199" style="display: none">package opentsdb

import (
        "context"
        "fmt"
        "path"
        "strconv"
        "strings"

        "golang.org/x/net/context/ctxhttp"

        "encoding/json"
        "io/ioutil"
        "net/http"
        "net/url"

        "github.com/grafana/grafana/pkg/components/null"
        "github.com/grafana/grafana/pkg/log"
        "github.com/grafana/grafana/pkg/models"
        "github.com/grafana/grafana/pkg/setting"
        "github.com/grafana/grafana/pkg/tsdb"
)

type OpenTsdbExecutor struct {
        *models.DataSource
        httpClient *http.Client
}

func NewOpenTsdbExecutor(datasource *models.DataSource) (tsdb.Executor, error) <span class="cov0" title="0">{
        httpClient, err := datasource.GetHttpClient()

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;OpenTsdbExecutor{
                DataSource: datasource,
                httpClient: httpClient,
        }, nil</span>
}

var (
        plog log.Logger
)

func init() <span class="cov8" title="1">{
        plog = log.New("tsdb.opentsdb")
        tsdb.RegisterExecutor("opentsdb", NewOpenTsdbExecutor)
}</span>

func (e *OpenTsdbExecutor) Execute(ctx context.Context, queries tsdb.QuerySlice, queryContext *tsdb.QueryContext) *tsdb.BatchResult <span class="cov0" title="0">{
        result := &amp;tsdb.BatchResult{}

        var tsdbQuery OpenTsdbQuery

        tsdbQuery.Start = queryContext.TimeRange.GetFromAsMsEpoch()
        tsdbQuery.End = queryContext.TimeRange.GetToAsMsEpoch()

        for _, query := range queries </span><span class="cov0" title="0">{
                metric := e.buildMetric(query)
                tsdbQuery.Queries = append(tsdbQuery.Queries, metric)
        }</span>

        <span class="cov0" title="0">if setting.Env == setting.DEV </span><span class="cov0" title="0">{
                plog.Debug("OpenTsdb request", "params", tsdbQuery)
        }</span>

        <span class="cov0" title="0">req, err := e.createRequest(tsdbQuery)
        if err != nil </span><span class="cov0" title="0">{
                result.Error = err
                return result
        }</span>

        <span class="cov0" title="0">res, err := ctxhttp.Do(ctx, e.httpClient, req)
        if err != nil </span><span class="cov0" title="0">{
                result.Error = err
                return result
        }</span>

        <span class="cov0" title="0">queryResult, err := e.parseResponse(tsdbQuery, res)
        if err != nil </span><span class="cov0" title="0">{
                return result.WithError(err)
        }</span>

        <span class="cov0" title="0">result.QueryResults = queryResult
        return result</span>
}

func (e *OpenTsdbExecutor) createRequest(data OpenTsdbQuery) (*http.Request, error) <span class="cov0" title="0">{
        u, _ := url.Parse(e.Url)
        u.Path = path.Join(u.Path, "api/query")

        postData, err := json.Marshal(data)

        req, err := http.NewRequest(http.MethodPost, u.String(), strings.NewReader(string(postData)))
        if err != nil </span><span class="cov0" title="0">{
                plog.Info("Failed to create request", "error", err)
                return nil, fmt.Errorf("Failed to create request. error: %v", err)
        }</span>

        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/json")
        if e.BasicAuth </span><span class="cov0" title="0">{
                req.SetBasicAuth(e.BasicAuthUser, e.BasicAuthPassword)
        }</span>

        <span class="cov0" title="0">return req, err</span>
}

func (e *OpenTsdbExecutor) parseResponse(query OpenTsdbQuery, res *http.Response) (map[string]*tsdb.QueryResult, error) <span class="cov0" title="0">{

        queryResults := make(map[string]*tsdb.QueryResult)
        queryRes := tsdb.NewQueryResult()

        body, err := ioutil.ReadAll(res.Body)
        defer res.Body.Close()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if res.StatusCode/100 != 2 </span><span class="cov0" title="0">{
                plog.Info("Request failed", "status", res.Status, "body", string(body))
                return nil, fmt.Errorf("Request failed status: %v", res.Status)
        }</span>

        <span class="cov0" title="0">var data []OpenTsdbResponse
        err = json.Unmarshal(body, &amp;data)
        if err != nil </span><span class="cov0" title="0">{
                plog.Info("Failed to unmarshal opentsdb response", "error", err, "status", res.Status, "body", string(body))
                return nil, err
        }</span>

        <span class="cov0" title="0">for _, val := range data </span><span class="cov0" title="0">{
                series := tsdb.TimeSeries{
                        Name: val.Metric,
                }

                for timeString, value := range val.DataPoints </span><span class="cov0" title="0">{
                        timestamp, err := strconv.ParseFloat(timeString, 64)
                        if err != nil </span><span class="cov0" title="0">{
                                plog.Info("Failed to unmarshal opentsdb timestamp", "timestamp", timeString)
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">series.Points = append(series.Points, tsdb.NewTimePoint(null.FloatFrom(value), timestamp))</span>
                }

                <span class="cov0" title="0">queryRes.Series = append(queryRes.Series, &amp;series)</span>
        }

        <span class="cov0" title="0">queryResults["A"] = queryRes
        return queryResults, nil</span>
}

func (e *OpenTsdbExecutor) buildMetric(query *tsdb.Query) map[string]interface{} <span class="cov8" title="1">{

        metric := make(map[string]interface{})

        // Setting metric and aggregator
        metric["metric"] = query.Model.Get("metric").MustString()
        metric["aggregator"] = query.Model.Get("aggregator").MustString()

        // Setting downsampling options
        disableDownsampling := query.Model.Get("disableDownsampling").MustBool()
        if !disableDownsampling </span><span class="cov8" title="1">{
                downsampleInterval := query.Model.Get("downsampleInterval").MustString()
                if downsampleInterval == "" </span><span class="cov8" title="1">{
                        downsampleInterval = "1m" //default value for blank
                }</span>
                <span class="cov8" title="1">downsample := downsampleInterval + "-" + query.Model.Get("downsampleAggregator").MustString()
                if query.Model.Get("downsampleFillPolicy").MustString() != "none" </span><span class="cov8" title="1">{
                        metric["downsample"] = downsample + "-" + query.Model.Get("downsampleFillPolicy").MustString()
                }</span><span class="cov8" title="1"> else {
                        metric["downsample"] = downsample
                }</span>
        }

        // Setting rate options
        <span class="cov8" title="1">if query.Model.Get("shouldComputeRate").MustBool() </span><span class="cov8" title="1">{

                metric["rate"] = true
                rateOptions := make(map[string]interface{})
                rateOptions["counter"] = query.Model.Get("isCounter").MustBool()

                counterMax, counterMaxCheck := query.Model.CheckGet("counterMax")
                if counterMaxCheck </span><span class="cov8" title="1">{
                        rateOptions["counterMax"] = counterMax.MustFloat64()
                }</span>

                <span class="cov8" title="1">resetValue, resetValueCheck := query.Model.CheckGet("counterResetValue")
                if resetValueCheck </span><span class="cov8" title="1">{
                        rateOptions["resetValue"] = resetValue.MustFloat64()
                }</span>

                <span class="cov8" title="1">metric["rateOptions"] = rateOptions</span>
        }

        // Setting tags
        <span class="cov8" title="1">tags, tagsCheck := query.Model.CheckGet("tags")
        if tagsCheck &amp;&amp; len(tags.MustMap()) &gt; 0 </span><span class="cov8" title="1">{
                metric["tags"] = tags.MustMap()
        }</span>

        // Setting filters
        <span class="cov8" title="1">filters, filtersCheck := query.Model.CheckGet("filters")
        if filtersCheck &amp;&amp; len(filters.MustArray()) &gt; 0 </span><span class="cov0" title="0">{
                metric["filters"] = filters.MustArray()
        }</span>

        <span class="cov8" title="1">return metric</span>

}
</pre>
		
		<pre class="file" id="file200" style="display: none">package prometheus

import (
        "context"
        "fmt"
        "regexp"
        "strings"
        "time"

        "net/http"

        "github.com/grafana/grafana/pkg/components/null"
        "github.com/grafana/grafana/pkg/log"
        "github.com/grafana/grafana/pkg/models"
        "github.com/grafana/grafana/pkg/tsdb"
        "github.com/prometheus/client_golang/api/prometheus"
        pmodel "github.com/prometheus/common/model"
)

type PrometheusExecutor struct {
        *models.DataSource
        Transport *http.Transport
}

type basicAuthTransport struct {
        *http.Transport

        username string
        password string
}

func (bat basicAuthTransport) RoundTrip(req *http.Request) (*http.Response, error) <span class="cov0" title="0">{
        req.SetBasicAuth(bat.username, bat.password)
        return bat.Transport.RoundTrip(req)
}</span>

func NewPrometheusExecutor(dsInfo *models.DataSource) (tsdb.Executor, error) <span class="cov0" title="0">{
        transport, err := dsInfo.GetHttpTransport()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;PrometheusExecutor{
                DataSource: dsInfo,
                Transport:  transport,
        }, nil</span>
}

var (
        plog         log.Logger
        legendFormat *regexp.Regexp
)

func init() <span class="cov8" title="1">{
        plog = log.New("tsdb.prometheus")
        tsdb.RegisterExecutor("prometheus", NewPrometheusExecutor)
        legendFormat = regexp.MustCompile(`\{\{\s*(.+?)\s*\}\}`)
}</span>

func (e *PrometheusExecutor) getClient() (prometheus.QueryAPI, error) <span class="cov0" title="0">{
        cfg := prometheus.Config{
                Address:   e.DataSource.Url,
                Transport: e.Transport,
        }

        if e.BasicAuth </span><span class="cov0" title="0">{
                cfg.Transport = basicAuthTransport{
                        Transport: e.Transport,
                        username:  e.BasicAuthUser,
                        password:  e.BasicAuthPassword,
                }
        }</span>

        <span class="cov0" title="0">client, err := prometheus.New(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return prometheus.NewQueryAPI(client), nil</span>
}

func (e *PrometheusExecutor) Execute(ctx context.Context, queries tsdb.QuerySlice, queryContext *tsdb.QueryContext) *tsdb.BatchResult <span class="cov0" title="0">{
        result := &amp;tsdb.BatchResult{}

        client, err := e.getClient()
        if err != nil </span><span class="cov0" title="0">{
                return result.WithError(err)
        }</span>

        <span class="cov0" title="0">query, err := parseQuery(queries, queryContext)
        if err != nil </span><span class="cov0" title="0">{
                return result.WithError(err)
        }</span>

        <span class="cov0" title="0">timeRange := prometheus.Range{
                Start: query.Start,
                End:   query.End,
                Step:  query.Step,
        }

        value, err := client.QueryRange(ctx, query.Expr, timeRange)

        if err != nil </span><span class="cov0" title="0">{
                return result.WithError(err)
        }</span>

        <span class="cov0" title="0">queryResult, err := parseResponse(value, query)
        if err != nil </span><span class="cov0" title="0">{
                return result.WithError(err)
        }</span>
        <span class="cov0" title="0">result.QueryResults = queryResult
        return result</span>
}

func formatLegend(metric pmodel.Metric, query *PrometheusQuery) string <span class="cov8" title="1">{
        if query.LegendFormat == "" </span><span class="cov8" title="1">{
                return metric.String()
        }</span>

        <span class="cov8" title="1">result := legendFormat.ReplaceAllFunc([]byte(query.LegendFormat), func(in []byte) []byte </span><span class="cov8" title="1">{
                labelName := strings.Replace(string(in), "{{", "", 1)
                labelName = strings.Replace(labelName, "}}", "", 1)
                labelName = strings.TrimSpace(labelName)
                if val, exists := metric[pmodel.LabelName(labelName)]; exists </span><span class="cov8" title="1">{
                        return []byte(val)
                }</span>

                <span class="cov8" title="1">return in</span>
        })

        <span class="cov8" title="1">return string(result)</span>
}

func parseQuery(queries tsdb.QuerySlice, queryContext *tsdb.QueryContext) (*PrometheusQuery, error) <span class="cov0" title="0">{
        queryModel := queries[0]

        expr, err := queryModel.Model.Get("expr").String()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">step, err := queryModel.Model.Get("step").Int64()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">format := queryModel.Model.Get("legendFormat").MustString("")

        start, err := queryContext.TimeRange.ParseFrom()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">end, err := queryContext.TimeRange.ParseTo()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;PrometheusQuery{
                Expr:         expr,
                Step:         time.Second * time.Duration(step),
                LegendFormat: format,
                Start:        start,
                End:          end,
        }, nil</span>
}

func parseResponse(value pmodel.Value, query *PrometheusQuery) (map[string]*tsdb.QueryResult, error) <span class="cov0" title="0">{
        queryResults := make(map[string]*tsdb.QueryResult)
        queryRes := tsdb.NewQueryResult()

        data, ok := value.(pmodel.Matrix)
        if !ok </span><span class="cov0" title="0">{
                return queryResults, fmt.Errorf("Unsupported result format: %s", value.Type().String())
        }</span>

        <span class="cov0" title="0">for _, v := range data </span><span class="cov0" title="0">{
                series := tsdb.TimeSeries{
                        Name: formatLegend(v.Metric, query),
                        Tags: map[string]string{},
                }

                for k, v := range v.Metric </span><span class="cov0" title="0">{
                        series.Tags[string(k)] = string(v)
                }</span>

                <span class="cov0" title="0">for _, k := range v.Values </span><span class="cov0" title="0">{
                        series.Points = append(series.Points, tsdb.NewTimePoint(null.FloatFrom(float64(k.Value)), float64(k.Timestamp.Unix()*1000)))
                }</span>

                <span class="cov0" title="0">queryRes.Series = append(queryRes.Series, &amp;series)</span>
        }

        <span class="cov0" title="0">queryResults["A"] = queryRes
        return queryResults, nil</span>
}
</pre>
		
		<pre class="file" id="file201" style="display: none">package tsdb

import "sync"

type QueryContext struct {
        TimeRange   *TimeRange
        Queries     QuerySlice
        Results     map[string]*QueryResult
        ResultsChan chan *BatchResult
        Lock        sync.RWMutex
        BatchWaits  sync.WaitGroup
}

func NewQueryContext(queries QuerySlice, timeRange *TimeRange) *QueryContext <span class="cov8" title="1">{
        return &amp;QueryContext{
                TimeRange:   timeRange,
                Queries:     queries,
                ResultsChan: make(chan *BatchResult),
                Results:     make(map[string]*QueryResult),
        }
}</span>
</pre>
		
		<pre class="file" id="file202" style="display: none">package tsdb

import "context"

type HandleRequestFunc func(ctx context.Context, req *Request) (*Response, error)

func HandleRequest(ctx context.Context, req *Request) (*Response, error) <span class="cov8" title="1">{
        context := NewQueryContext(req.Queries, req.TimeRange)

        batches, err := getBatches(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">currentlyExecuting := 0

        for _, batch := range batches </span><span class="cov8" title="1">{
                if len(batch.Depends) == 0 </span><span class="cov8" title="1">{
                        currentlyExecuting += 1
                        batch.Started = true
                        go batch.process(ctx, context)
                }</span>
        }

        <span class="cov8" title="1">response := &amp;Response{}

        for currentlyExecuting != 0 </span><span class="cov8" title="1">{
                select </span>{
                case batchResult := &lt;-context.ResultsChan:<span class="cov8" title="1">
                        currentlyExecuting -= 1

                        response.BatchTimings = append(response.BatchTimings, batchResult.Timings)

                        if batchResult.Error != nil </span><span class="cov8" title="1">{
                                return nil, batchResult.Error
                        }</span>

                        <span class="cov8" title="1">for refId, result := range batchResult.QueryResults </span><span class="cov8" title="1">{
                                context.Results[refId] = result
                        }</span>

                        <span class="cov8" title="1">for _, batch := range batches </span><span class="cov8" title="1">{
                                // not interested in started batches
                                if batch.Started </span><span class="cov8" title="1">{
                                        continue</span>
                                }

                                <span class="cov8" title="1">if batch.allDependenciesAreIn(context) </span><span class="cov8" title="1">{
                                        currentlyExecuting += 1
                                        batch.Started = true
                                        go batch.process(ctx, context)
                                }</span>
                        }
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return nil, ctx.Err()</span>
                }
        }

        <span class="cov8" title="1">response.Results = context.Results
        return response, nil</span>
}
</pre>
		
		<pre class="file" id="file203" style="display: none">package tsdb

import (
        "fmt"
        "strconv"
        "strings"
        "time"
)

func NewTimeRange(from, to string) *TimeRange <span class="cov8" title="1">{
        return &amp;TimeRange{
                From: from,
                To:   to,
                Now:  time.Now(),
        }
}</span>

type TimeRange struct {
        From string
        To   string
        Now  time.Time
}

func (tr *TimeRange) GetFromAsMsEpoch() int64 <span class="cov0" title="0">{
        return tr.MustGetFrom().UnixNano() / int64(time.Millisecond)
}</span>

func (tr *TimeRange) GetToAsMsEpoch() int64 <span class="cov0" title="0">{
        return tr.MustGetTo().UnixNano() / int64(time.Millisecond)
}</span>

func (tr *TimeRange) MustGetFrom() time.Time <span class="cov8" title="1">{
        if res, err := tr.ParseFrom(); err != nil </span><span class="cov0" title="0">{
                return time.Unix(0, 0)
        }</span><span class="cov8" title="1"> else {
                return res
        }</span>
}

func (tr *TimeRange) MustGetTo() time.Time <span class="cov8" title="1">{
        if res, err := tr.ParseTo(); err != nil </span><span class="cov0" title="0">{
                return time.Unix(0, 0)
        }</span><span class="cov8" title="1"> else {
                return res
        }</span>
}

func tryParseUnixMsEpoch(val string) (time.Time, bool) <span class="cov8" title="1">{
        if val, err := strconv.ParseInt(val, 10, 64); err == nil </span><span class="cov8" title="1">{
                seconds := val / 1000
                nano := (val - seconds*1000) * 1000000
                return time.Unix(seconds, nano), true
        }</span>
        <span class="cov8" title="1">return time.Time{}, false</span>
}

func (tr *TimeRange) ParseFrom() (time.Time, error) <span class="cov8" title="1">{
        if res, ok := tryParseUnixMsEpoch(tr.From); ok </span><span class="cov8" title="1">{
                return res, nil
        }</span>

        <span class="cov8" title="1">fromRaw := strings.Replace(tr.From, "now-", "", 1)
        diff, err := time.ParseDuration("-" + fromRaw)
        if err != nil </span><span class="cov8" title="1">{
                return time.Time{}, err
        }</span>

        <span class="cov8" title="1">return tr.Now.Add(diff), nil</span>
}

func (tr *TimeRange) ParseTo() (time.Time, error) <span class="cov8" title="1">{
        if tr.To == "now" </span><span class="cov8" title="1">{
                return tr.Now, nil
        }</span><span class="cov8" title="1"> else if strings.HasPrefix(tr.To, "now-") </span><span class="cov8" title="1">{
                withoutNow := strings.Replace(tr.To, "now-", "", 1)

                diff, err := time.ParseDuration("-" + withoutNow)
                if err != nil </span><span class="cov0" title="0">{
                        return time.Time{}, nil
                }</span>

                <span class="cov8" title="1">return tr.Now.Add(diff), nil</span>
        }

        <span class="cov8" title="1">if res, ok := tryParseUnixMsEpoch(tr.To); ok </span><span class="cov8" title="1">{
                return res, nil
        }</span>

        <span class="cov8" title="1">return time.Time{}, fmt.Errorf("cannot parse to value %s", tr.To)</span>
}
</pre>
		
		<pre class="file" id="file204" style="display: none">package util

import (
        "crypto/hmac"
        "crypto/md5"
        "crypto/rand"
        "crypto/sha256"
        "encoding/base64"
        "encoding/hex"
        "errors"
        "fmt"
        "hash"
        "strings"
)

// source: https://github.com/gogits/gogs/blob/9ee80e3e5426821f03a4e99fad34418f5c736413/modules/base/tool.go#L58
func GetRandomString(n int, alphabets ...byte) string <span class="cov8" title="1">{
        const alphanum = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
        var bytes = make([]byte, n)
        rand.Read(bytes)
        for i, b := range bytes </span><span class="cov8" title="1">{
                if len(alphabets) == 0 </span><span class="cov8" title="1">{
                        bytes[i] = alphanum[b%byte(len(alphanum))]
                }</span><span class="cov0" title="0"> else {
                        bytes[i] = alphabets[b%byte(len(alphabets))]
                }</span>
        }
        <span class="cov8" title="1">return string(bytes)</span>
}

func EncodePassword(password string, salt string) string <span class="cov0" title="0">{
        newPasswd := PBKDF2([]byte(password), []byte(salt), 10000, 50, sha256.New)
        return fmt.Sprintf("%x", newPasswd)
}</span>

// Encode string to md5 hex value.
func EncodeMd5(str string) string <span class="cov0" title="0">{
        m := md5.New()
        m.Write([]byte(str))
        return hex.EncodeToString(m.Sum(nil))
}</span>

// http://code.google.com/p/go/source/browse/pbkdf2/pbkdf2.go?repo=crypto
func PBKDF2(password, salt []byte, iter, keyLen int, h func() hash.Hash) []byte <span class="cov8" title="1">{
        prf := hmac.New(h, password)
        hashLen := prf.Size()
        numBlocks := (keyLen + hashLen - 1) / hashLen

        var buf [4]byte
        dk := make([]byte, 0, numBlocks*hashLen)
        U := make([]byte, hashLen)
        for block := 1; block &lt;= numBlocks; block++ </span><span class="cov8" title="1">{
                // N.B.: || means concatenation, ^ means XOR
                // for each block T_i = U_1 ^ U_2 ^ ... ^ U_iter
                // U_1 = PRF(password, salt || uint(i))
                prf.Reset()
                prf.Write(salt)
                buf[0] = byte(block &gt;&gt; 24)
                buf[1] = byte(block &gt;&gt; 16)
                buf[2] = byte(block &gt;&gt; 8)
                buf[3] = byte(block)
                prf.Write(buf[:4])
                dk = prf.Sum(dk)
                T := dk[len(dk)-hashLen:]
                copy(U, T)

                // U_n = PRF(password, U_(n-1))
                for n := 2; n &lt;= iter; n++ </span><span class="cov8" title="1">{
                        prf.Reset()
                        prf.Write(U)
                        U = U[:0]
                        U = prf.Sum(U)
                        for x := range U </span><span class="cov8" title="1">{
                                T[x] ^= U[x]
                        }</span>
                }
        }
        <span class="cov8" title="1">return dk[:keyLen]</span>
}

func GetBasicAuthHeader(user string, password string) string <span class="cov8" title="1">{
        var userAndPass = user + ":" + password
        return "Basic " + base64.StdEncoding.EncodeToString([]byte(userAndPass))
}</span>

func DecodeBasicAuthHeader(header string) (string, string, error) <span class="cov8" title="1">{
        var code string
        parts := strings.SplitN(header, " ", 2)
        if len(parts) == 2 &amp;&amp; parts[0] == "Basic" </span><span class="cov8" title="1">{
                code = parts[1]
        }</span>

        <span class="cov8" title="1">decoded, err := base64.StdEncoding.DecodeString(code)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>

        <span class="cov8" title="1">userAndPass := strings.SplitN(string(decoded), ":", 2)
        if len(userAndPass) != 2 </span><span class="cov0" title="0">{
                return "", "", errors.New("Invalid basic auth header")
        }</span>

        <span class="cov8" title="1">return userAndPass[0], userAndPass[1], nil</span>
}
</pre>
		
		<pre class="file" id="file205" style="display: none">package util

import (
        "crypto/aes"
        "crypto/cipher"
        "crypto/rand"
        "crypto/sha256"
        "io"

        "github.com/grafana/grafana/pkg/log"
)

const saltLength = 8

func Decrypt(payload []byte, secret string) []byte <span class="cov8" title="1">{
        salt := payload[:saltLength]
        key := encryptionKeyToBytes(secret, string(salt))

        block, err := aes.NewCipher(key)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(4, err.Error())
        }</span>

        // The IV needs to be unique, but not secure. Therefore it's common to
        // include it at the beginning of the ciphertext.
        <span class="cov8" title="1">if len(payload) &lt; aes.BlockSize </span><span class="cov0" title="0">{
                log.Fatal(4, "payload too short")
        }</span>
        <span class="cov8" title="1">iv := payload[saltLength : saltLength+aes.BlockSize]
        payload = payload[saltLength+aes.BlockSize:]

        stream := cipher.NewCFBDecrypter(block, iv)

        // XORKeyStream can work in-place if the two arguments are the same.
        stream.XORKeyStream(payload, payload)
        return payload</span>
}

func Encrypt(payload []byte, secret string) []byte <span class="cov8" title="1">{
        salt := GetRandomString(saltLength)

        key := encryptionKeyToBytes(secret, salt)
        block, err := aes.NewCipher(key)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(4, err.Error())
        }</span>

        // The IV needs to be unique, but not secure. Therefore it's common to
        // include it at the beginning of the ciphertext.
        <span class="cov8" title="1">ciphertext := make([]byte, saltLength+aes.BlockSize+len(payload))
        copy(ciphertext[:saltLength], []byte(salt))
        iv := ciphertext[saltLength : saltLength+aes.BlockSize]
        if _, err := io.ReadFull(rand.Reader, iv); err != nil </span><span class="cov0" title="0">{
                log.Fatal(4, err.Error())
        }</span>

        <span class="cov8" title="1">stream := cipher.NewCFBEncrypter(block, iv)
        stream.XORKeyStream(ciphertext[saltLength+aes.BlockSize:], payload)

        return ciphertext</span>
}

// Key needs to be 32bytes
func encryptionKeyToBytes(secret, salt string) []byte <span class="cov8" title="1">{
        return PBKDF2([]byte(secret), []byte(salt), 10000, 32, sha256.New)
}</span>
</pre>
		
		<pre class="file" id="file206" style="display: none">package util

import (
        "errors"
        "fmt"
        "io/ioutil"
        "os"
        "path/filepath"
)

//WalkSkipDir is the Error returned when we want to skip descending into a directory
var WalkSkipDir = errors.New("skip this directory")

//WalkFunc is a callback function called for each path as a directory is walked
//If resolvedPath != "", then we are following symbolic links.
type WalkFunc func(resolvedPath string, info os.FileInfo, err error) error

//Walk walks a path, optionally following symbolic links, and for each path,
//it calls the walkFn passed.
//
//It is similar to filepath.Walk, except that it supports symbolic links and
//can detect infinite loops while following sym links.
//It solves the issue where your WalkFunc needs a path relative to the symbolic link
//(resolving links within walkfunc loses the path to the symbolic link for each traversal).
func Walk(path string, followSymlinks bool, detectSymlinkInfiniteLoop bool, walkFn WalkFunc) error <span class="cov0" title="0">{
        info, err := os.Lstat(path)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">var symlinkPathsFollowed map[string]bool
        var resolvedPath string
        if followSymlinks </span><span class="cov0" title="0">{
                resolvedPath = path
                if detectSymlinkInfiniteLoop </span><span class="cov0" title="0">{
                        symlinkPathsFollowed = make(map[string]bool, 8)
                }</span>
        }
        <span class="cov0" title="0">return walk(path, info, resolvedPath, symlinkPathsFollowed, walkFn)</span>
}

//walk walks the path. It is a helper/sibling function to Walk.
//It takes a resolvedPath into consideration. This way, paths being walked are
//always relative to the path argument, even if symbolic links were resolved).
//
//If resolvedPath is "", then we are not following symbolic links.
//If symlinkPathsFollowed is not nil, then we need to detect infinite loop.
func walk(path string, info os.FileInfo, resolvedPath string, symlinkPathsFollowed map[string]bool, walkFn WalkFunc) error <span class="cov0" title="0">{
        if info == nil </span><span class="cov0" title="0">{
                return errors.New("Walk: Nil FileInfo passed")
        }</span>
        <span class="cov0" title="0">err := walkFn(resolvedPath, info, nil)
        if err != nil </span><span class="cov0" title="0">{
                if info.IsDir() &amp;&amp; err == WalkSkipDir </span><span class="cov0" title="0">{
                        err = nil
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        <span class="cov0" title="0">if resolvedPath != "" &amp;&amp; info.Mode()&amp;os.ModeSymlink == os.ModeSymlink </span><span class="cov0" title="0">{
                path2, err := os.Readlink(resolvedPath)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                //vout("SymLink Path: %v, links to: %v", resolvedPath, path2)
                <span class="cov0" title="0">if symlinkPathsFollowed != nil </span><span class="cov0" title="0">{
                        if _, ok := symlinkPathsFollowed[path2]; ok </span><span class="cov0" title="0">{
                                errMsg := "Potential SymLink Infinite Loop. Path: %v, Link To: %v"
                                return fmt.Errorf(errMsg, resolvedPath, path2)
                        }</span><span class="cov0" title="0"> else {
                                symlinkPathsFollowed[path2] = true
                        }</span>
                }
                <span class="cov0" title="0">info2, err := os.Lstat(path2)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return walk(path, info2, path2, symlinkPathsFollowed, walkFn)</span>
        }
        <span class="cov0" title="0">if info.IsDir() </span><span class="cov0" title="0">{
                list, err := ioutil.ReadDir(path)
                if err != nil </span><span class="cov0" title="0">{
                        return walkFn(resolvedPath, info, err)
                }</span>
                <span class="cov0" title="0">var subFiles = make([]subFile, 0)
                for _, fileInfo := range list </span><span class="cov0" title="0">{
                        path2 := filepath.Join(path, fileInfo.Name())
                        var resolvedPath2 string
                        if resolvedPath != "" </span><span class="cov0" title="0">{
                                resolvedPath2 = filepath.Join(resolvedPath, fileInfo.Name())
                        }</span>
                        <span class="cov0" title="0">subFiles = append(subFiles, subFile{path: path2, resolvedPath: resolvedPath2, fileInfo: fileInfo})</span>
                }

                <span class="cov0" title="0">if containsDistFolder(subFiles) </span><span class="cov0" title="0">{
                        err := walk(
                                filepath.Join(path, "dist"),
                                info,
                                filepath.Join(resolvedPath, "dist"),
                                symlinkPathsFollowed,
                                walkFn)

                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }<span class="cov0" title="0"> else {
                        for _, p := range subFiles </span><span class="cov0" title="0">{
                                err = walk(p.path, p.fileInfo, p.resolvedPath, symlinkPathsFollowed, walkFn)

                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                }

                <span class="cov0" title="0">return nil</span>
        }
        <span class="cov0" title="0">return nil</span>
}

type subFile struct {
        path, resolvedPath string
        fileInfo           os.FileInfo
}

func containsDistFolder(subFiles []subFile) bool <span class="cov0" title="0">{
        for _, p := range subFiles </span><span class="cov0" title="0">{
                if p.fileInfo.IsDir() &amp;&amp; p.fileInfo.Name() == "dist" </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file207" style="display: none">package util

func StringsFallback2(val1 string, val2 string) string <span class="cov8" title="1">{
        return stringsFallback(val1, val2)
}</span>

func StringsFallback3(val1 string, val2 string, val3 string) string <span class="cov8" title="1">{
        return stringsFallback(val1, val2, val3)
}</span>

func stringsFallback(vals ...string) string <span class="cov8" title="1">{
        for _, v := range vals </span><span class="cov8" title="1">{
                if v != "" </span><span class="cov8" title="1">{
                        return v
                }</span>
        }
        <span class="cov0" title="0">return ""</span>
}
</pre>
		
		<pre class="file" id="file208" style="display: none">package util

import (
        "net/url"
        "strings"
)

type UrlQueryReader struct {
        values url.Values
}

func NewUrlQueryReader(url *url.URL) *UrlQueryReader <span class="cov0" title="0">{
        return &amp;UrlQueryReader{
                values: url.Query(),
        }
}</span>

func (r *UrlQueryReader) Get(name string, def string) string <span class="cov0" title="0">{
        val := r.values[name]
        if len(val) == 0 </span><span class="cov0" title="0">{
                return def
        }</span>

        <span class="cov0" title="0">return val[0]</span>
}

func JoinUrlFragments(a, b string) string <span class="cov8" title="1">{
        aslash := strings.HasSuffix(a, "/")
        bslash := strings.HasPrefix(b, "/")

        if len(b) == 0 </span><span class="cov8" title="1">{
                return a
        }</span>

        <span class="cov8" title="1">switch </span>{
        case aslash &amp;&amp; bslash:<span class="cov0" title="0">
                return a + b[1:]</span>
        case !aslash &amp;&amp; !bslash:<span class="cov8" title="1">
                return a + "/" + b</span>
        }
        <span class="cov8" title="1">return a + b</span>
}
</pre>
		
		<pre class="file" id="file209" style="display: none">package util

import (
        "regexp"
        "strings"
)

const (
        emailRegexPattern string = "^(((([a-zA-Z]|\\d|[!#\\$%&amp;'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\x{00A0}-\\x{D7FF}\\x{F900}-\\x{FDCF}\\x{FDF0}-\\x{FFEF}])+(\\.([a-zA-Z]|\\d|[!#\\$%&amp;'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\x{00A0}-\\x{D7FF}\\x{F900}-\\x{FDCF}\\x{FDF0}-\\x{FFEF}])+)*)|((\\x22)((((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(([\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x7f]|\\x21|[\\x23-\\x5b]|[\\x5d-\\x7e]|[\\x{00A0}-\\x{D7FF}\\x{F900}-\\x{FDCF}\\x{FDF0}-\\x{FFEF}])|(\\([\\x01-\\x09\\x0b\\x0c\\x0d-\\x7f]|[\\x{00A0}-\\x{D7FF}\\x{F900}-\\x{FDCF}\\x{FDF0}-\\x{FFEF}]))))*(((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(\\x22)))@((([a-zA-Z]|\\d|[\\x{00A0}-\\x{D7FF}\\x{F900}-\\x{FDCF}\\x{FDF0}-\\x{FFEF}])|(([a-zA-Z]|\\d|[\\x{00A0}-\\x{D7FF}\\x{F900}-\\x{FDCF}\\x{FDF0}-\\x{FFEF}])([a-zA-Z]|\\d|-|\\.|_|~|[\\x{00A0}-\\x{D7FF}\\x{F900}-\\x{FDCF}\\x{FDF0}-\\x{FFEF}])*([a-zA-Z]|\\d|[\\x{00A0}-\\x{D7FF}\\x{F900}-\\x{FDCF}\\x{FDF0}-\\x{FFEF}])))\\.)+(([a-zA-Z]|[\\x{00A0}-\\x{D7FF}\\x{F900}-\\x{FDCF}\\x{FDF0}-\\x{FFEF}])|(([a-zA-Z]|[\\x{00A0}-\\x{D7FF}\\x{F900}-\\x{FDCF}\\x{FDF0}-\\x{FFEF}])([a-zA-Z]|\\d|-|\\.|_|~|[\\x{00A0}-\\x{D7FF}\\x{F900}-\\x{FDCF}\\x{FDF0}-\\x{FFEF}])*([a-zA-Z]|[\\x{00A0}-\\x{D7FF}\\x{F900}-\\x{FDCF}\\x{FDF0}-\\x{FFEF}])))\\.?$"
)

var (
        regexEmail = regexp.MustCompile(emailRegexPattern)
)

func IsEmail(str string) bool <span class="cov0" title="0">{
        return regexEmail.MatchString(strings.ToLower(str))
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
